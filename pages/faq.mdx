---
layout: '@layouts/Docs.astro'
sidebar-title: FAQ
page-title:  FAQ

---

# FAQ 



## Alerts 

-   [How do I make an alert available from my script?](/pine-script-docs/faq#how-do-imake-an-alert-available-from-my-script)
    -   `` Using \`alertcondition()\`: <PageFaq_Alerts_HowDoIMakeAnAlertAvailableFromMyScript_UsingAlertcondition> ``
    -   `` Using order fills in \`strategy()\` scripts: <PageFaq_Alerts_HowDoIMakeAnAlertAvailableFromMyScript_UsingOrderFillsInStrategyScripts> ``
    -   `` Using \`alert()\`: <PageFaq_Alerts_HowDoIMakeAnAlertAvailableFromMyScript_UsingAlert> ``
-   [If I make changes to my script, will it affect my alert?](/pine-script-docs/faq#if-imake-changes-to-my-script-will-it-affect-my-alert)
-   [I have a custom script that generates alerts. How do I run it on many symbols?](/pine-script-docs/faq#ihave-acustom-script-that-generates-alerts-how-do-irun-it-on-many-symbols)
-   [Is it possible to use a string that varies as an argument to the alertcondition() function’s message = parameter?](/pine-script-docs/faq#is-it-possible-to-use-astring-that-varies-as-an-argument-to-the-alertcondition-functions-message=parameter)
-   [How can I include values that change in my alerts?](/pine-script-docs/faq#how-can-iinclude-values-that-change-in-my-alerts)
-   [How can I create JSON messages in my alerts?](/pine-script-docs/faq#how-can-icreate-json-messages-in-my-alerts)
-   [Can my Pine strategy or indicator place automated orders in markets?](/pine-script-docs/faq#can-my-pine-strategy-or-indicator-place-automated-orders-in-markets)
-   [How can I send alerts from my script to Discord?](/pine-script-docs/faq#how-can-isend-alerts-from-my-script-to-discord)
-   [How can I send alerts to Telegram?](/pine-script-docs/faq#how-can-isend-alerts-to-telegram)
-   [Why did my alerts get stopped?](/pine-script-docs/faq#why-did-my-alerts-get-stopped)
-   [Why is my alert firing when it's not supposed to?](/pine-script-docs/faq#why-is-my-alert-firing-when-its-not-supposed-to)
-   [How can I run my alert on a timer or delay?](/pine-script-docs/faq#how-can-irun-my-alert-on-atimer-or-delay)
-   [How can I trigger an alert only once when the condition is true the first time?](/pine-script-docs/faq#how-can-itrigger-an-alert-only-once-when-the-condition-is-true-the-first-time)

### How do I make an alert available from my script? 

There are three ways in which users can add
[alerts](/pine-script-docs/concepts/alerts) to their scripts.

#### Using \`alertcondition()\`: 

The
[alertcondition()](https://www.tradingview.com/pine-script-reference/v5/#fun_alertcondition)
is a function that enables the creation of individual customized alert
triggers based on specific conditions within indicator scripts only.

-   An indicator can include multiple calls to this function.
-   The function cannot be used in
    [local scope](/pine-script-docs/faq#what-does-scope-mean).
-   Note that `alertcondition()` does not *create* an alert. Each call
    adds a corresponding alert option to the *\"Condition\"* dropdown in
    the *\"Create Alert\"* dialog box that must be activated by the
    user.
-   Each alert condition that is activated in the alert UI counts
    towards the maximum number of alerts allowed by the user\'s plan.
-   Every call to the `alertcondition()` function in a script
    contributes to the script\'s overall
    [plot count limit](/pine-script-docs/writing/limitations#plot-limits).
-   Including the `alertcondition()` function in strategy scripts will
    not result in compilation errors. However, this function cannot
    generate alerts when used in strategy scripts.
-   The message argument primarily requires a \"simple string\", but it
    allows for limited inclusion of script variables to dynamically
    populate the string through the use of
    [placeholders](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Alerts.html#placeholders).
-   The `alertcondition()` function was initially introduced as the
    primary alert capability in Pine Script. However, it has since been
    superseded by the
    [alert()](https://www.tradingview.com/pine-script-reference/v5/#fun_alert)
    function, which is applicable in both strategies and indicators, and
    by [order fill
    events](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Alerts.html#order-fill-events)
    specifically for strategies. Despite this, `alertcondition()`
    continues to be available for backward compatibility and for its
    unique ability to add a single alert to the alert dropdown.

See the [User Manual
page](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Alerts.html#alertcondition-events)
on `alertcondition()` for more info. The structure to create an alert
condition is illustrated in the code example below:

``` pine
//@version=5
indicator("Simple alert", overlay = true)
// Create condition to trigger alert.
bool triggerCondition = close > close[1]
// Use `triggerCondition` in the `alertcondition()` function. Define a title for the alert in the menu and message to send with the alert. 
alertcondition(triggerCondition, title = "Create Alert dialog box name", message = "Text sent with alert.")
// Plot a shape when `triggerCondition` is true to visually mark where alerts occur.
plotshape(triggerCondition, "Trigger Condition", shape.xcross, color = color.fuchsia)
```

In this example, we demonstrate the use of a simple condition within the
`alertcondition()` function, assigning it an arbitrary title and alert
message. Additionally, we plot a shape on the chart to visually indicate
the bars where alerts are triggered.

#### Using order fills in \`strategy()\` scripts: 

In Pine Script™, an *order fill event* is triggered by the broker
emulator when it executes a simulated order in realtime, mirroring the
process of a trade order being filled in a real-world broker or exchange
scenario.

-   [Order fill
    events](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Alerts.html#order-fill-events)
    specifically pertain to strategy scripts and are not available in
    indicators.
-   Each `strategy.*()` order function comes with this integrated alert
    capability that triggers upon the fulfillment of an order by the
    broker emulator. Often, this means no additional logic is required
    for alerts in a strategy script.
-   Strategy *order fill alerts* are superior to using the
    [alert()](https://www.tradingview.com/pine-script-reference/v5/#fun_alert)
    function in strategies because they are inherently synchronized with
    the behavior of the broker emulator. This synchronization reduces
    the likelihood of [repainting](/pine-script-docs/concepts/repainting), improving the reliability of the alerts.
-   For instance, An *order fill event* occurs when the broker emulator
    executes a simulated order, akin to a real trade being filled by a
    broker/exchange, independent of the order\'s placement time or the
    script\'s ability to detect its fulfillment, contrasting with
    [alert()](https://www.tradingview.com/pine-script-reference/v5/#fun_alert)
    which depends on these factors.
-   While not required for *order fill events*, the `alert_message`
    argument in `strategy.*()` order functions can deliver custom
    messages during these events. It accepts a "series string", enabling
    dynamic construction using any script variable and strategy-based
    placeholders, as detailed in the Help Centre article about [strategy
    alerts](https://www.tradingview.com/chart/?solution=43000481368).
-   It\'s important to understand that users have two options for
    handling alert messages for *order fill events*:
    -   They can enter a generic message in the alert message box that
        applies to all alerts generated by the script.
    -   They can use the `alert_message` argument in each order function
        to create unique messages for each event. When opting for the
        latter approach, using unique messages, it\'s essential to
        include the `{{strategy.order.alert_message}}` placeholder in
        the alert message box. This placeholder ensures that the
        specific string defined in each order function\'s
        `alert_message` is correctly transferred to the alert.
    -   Note that
        [placeholders](https://www.tradingview.com/support/solutions/43000531021-how-to-use-a-variable-value-in-alert/)
        can be used in either the alert message box or the
        `alert_message` argument.
-   The `@strategy_alert_message`
    [compiler annotation](/pine-script-docs/language/script-structure#compiler-annotations) allows users to set a default message for order fill
    alerts, which auto-populates the \"Message\" field in the alert
    creation dialogue.

``` pine
//@version=5

// This annotation auto-populates the alert dialogue with the `alert_message` string during an order fill event.
// @strategy_alert_message {{strategy.order.alert_message}}

strategy("Alert Message Demo", overlay = true)

// Declare two moving averages to create entry conditions from.
float fastMa = ta.sma(close, 5)
float slowMa = ta.sma(close, 10)
// Declare two persistent variables that will hold our stop-loss and take-profit values.
var float limit = na
var float stop  = na

// Check if `fastMa` has crossed over `slowMa` and that we are not already in a position. Place an entry and exit order. 
//      • We set the `limit` to 2% above the close and the stop to 1% below.
//      • We use a combo of script variables and placeholders in the alert strings for demonstration.
//      • The exit alert will show the order direction, position size, ticker, and order price.
//      • The entry alert includes the same values plus the stop and limit price.
if ta.crossover(fastMa, slowMa) and strategy.position_size == 0
    limit := close * 1.02
    stop  := close * 0.99
    string exitString  = "{{strategy.order.action}} {{strategy.position_size}} {{ticker}} @ {{strategy.order.price}}"
    string entryString = exitString + " TP: " + str.tostring(limit, format.mintick) + " SL: " + 
      str.tostring(stop, format.mintick)
    strategy.entry("Buy", strategy.long, alert_message = entryString)
    strategy.exit("Exit", "Buy", stop = stop, limit = limit, alert_message = exitString)

// Plot the MAs, stop, and limit values on the chart.
plot(fastMa, "Fast MA", color.aqua)
plot(slowMa, "Slow MA", color.orange)
plot(strategy.position_size > 0 ? limit : na, "Limit", color.green, style = plot.style_linebr)
plot(strategy.position_size > 0 ? stop  : na, "Stop",  color.red,   style = plot.style_linebr)
```

In our example strategy, we place a 2:1 *bracket order* at the point
where a fast moving average crosses over a slower moving average. The
stop loss is set at 1% below the closing price of the bar where the
condition is met, while the take profit is set at 2% above this price.
We utilize *order fill alerts*, which use unique alert strings in the
`alert_message` arguments of the
[order placement commands](/pine-script-docs/concepts/strategies#order-placement-commands) to notify about entries and exits. These strings combine
placeholders and variables, displaying details like order action,
position size, ticker symbol, order price, and for entry orders, the
*stop* and *limit* prices.

Note that:

    -   Including *stop* and *limit* prices in the entry order allows
        for pre-placing pending exit orders via a third-party execution
        engine, which can be activated before the conditions for exit
        are actually met.

#### Using \`alert()\`: 

The [alert() function
event](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Alerts.html#alert-function-events),
an upgrade from
[alertcondition()](https://www.tradingview.com/pine-script-reference/v5/#fun_alertcondition),
operates in local scopes,supports \"series string\" messages, and
consolidates multiple script alerts into a single slot, counting towards
the user\'s maximum alert limit.

-   The
    [alert()](https://www.tradingview.com/pine-script-reference/v5/#fun_alert)
    function can be used in indicators or strategies
-   Each `alert()` call does not contribute toward the
    [plot count limit](/pine-script-docs/writing/limitations#plot-limits), as `alertcondition()` does.
-   The *alert frequency* is set directly in the function call by
    specifying the `freq` parameter.
-   Its `message` argument accepts \"series string\" enabling dynamic
    construction of custom messages using any variable within a script.
-   Unlike `alertcondition()`, the `alert()` function has no `condition`
    parameter, and as such, is typically placed in
    [local scope](/pine-script-docs/faq#what-does-scope-mean) to be executed when the branch logic allows.
-   All `alert()` calls are grouped under a single header in the
    *\"Create Alert\"* dropdown titled *\"Any alert() function call\"*
    in the alert dialog box that must be activated by the user. Once
    activated, each `alert()` instance will execute according to its
    defined logic and the frequency specified within its function. To
    enable only specific alerts to operate at any time, one would need
    to implement [selective alert()
    calls](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Alerts.html#using-selective-alert-calls).
-   The `alert()` function\'s `message` argument will not dynamically
    populate messages with *placeholders* in the way that *order fill
    alerts* and `alertcondition()` do.
-   In [strategy
    scripts](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Alerts.html#in-strategies),
    while *order fill alerts* are designed to synchronize with the
    *broker emulator*, they are limited to events related to order
    execution only. In contrast, the `alert()` function can be utilized
    for a broader range of events that *order fill alerts* cannot
    accommodate. Specifically, `alert()` is advantageous for
    pre-execution activities, such as placing or updating orders. For
    example, it can be used to place *stop* or *limit* entry orders
    before their execution, or to communicate with a third-party
    execution engine for updating a *trailing stop order* incrementally
    on each bar.

See the User Manual page on [script
alerts](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Alerts.html#script-alerts)
for additional info. In this demonstration, we use the `alert()`
function to notify when long and short conditions occur, to communicate
the initial stop loss value, and to send updates on the stop loss value
as it changes with the trailing stop on each bar:

``` pine
//@version=5
indicator("Vstop alert", overlay = true)

import TradingView/ta/7 as TVta

// Calculate ATR trailing stop and determine trend direction.
[stopValue, trendUp] = TVta.vStop(close, 20, 2)

// Round the stop value to mintick for accuracy in comparison operators.
float stop = math.round_to_mintick(stopValue)

// Check for trend changes.
bool  trendReversal = trendUp != trendUp[1]
bool  trendToDn     = trendReversal and not trendUp
bool  trendToUp     = trendReversal and     trendUp
// Create color variables for the plot display.
color plotColor     = trendUp ? color.green : color.red
color lineColor     = trendReversal ? color(na) : plotColor

// Plot the stop value to the chart. Plot a circle on trend changes.
plot(stop, "V-Stop", lineColor)
plot(trendReversal ? stop : na, "Beg. Circle", plotColor, 3, plot.style_circles)

// Convert the stop value to string for use in the alert messages.
string stopStr = str.tostring(stop)

// Check if the trend changed to up. Send a long alert with the initial stop value.
if trendToUp
    alert("Long alert. Stop @ " + stopStr, alert.freq_once_per_bar_close)

// Check if the trend changed to down. Send a short alert with the initial stop value.
if trendToDn
    alert("Short alert. Stop @ " + stopStr, alert.freq_once_per_bar_close)

// Check if the stop value has progressed since the prior bar and send an alert to update the stop value.
if (trendUp and stop > stop[1] or not trendUp and stop < stop[1]) and not trendReversal
    alert('Update stop to ' + stopStr, alert.freq_once_per_bar_close)
```

In our example, we use the `vstop()` function from our
[ta](https://www.tradingview.com/script/BICzyhq0-ta/) library to
calculate a stop value based on the [Average True
Range](https://www.tradingview.com/u/?solution=43000501823#published-scripts)
(ATR), which trails the closing price to form a trend-following system.
Whenever there\'s a shift in the trend, either to an upward or downward
direction, we issue an alert. This alert includes a dynamically
constructed string that indicates the direction of the trend and the
current `stop` value. Additionally, whenever the `stop` value progresses
from one bar to the next, we issue an update alert at the close of each
bar including the new value.

### If I make changes to my script, will it affect my alert? 

No, not without creating a new alert.

When you create an alert in the chart\'s UI, the system saves a snapshot
of the script, its inputs, and the chart\'s main symbol and timeframe on
its servers. This snapshot represents an independent copy of your script
logic, functioning as a distinct instance of your script. Therefore, any
changes you later make to the script\'s inputs, logic, or the associated
chart will not impact alerts that were already created. If you wish to
incorporate any recent changes into an active alert, you must first
delete the existing alert and then create a new one with the updated
context.

### I have a custom script that generates alerts. How do I run it on many symbols? 

To manage alerts across multiple symbols using a custom script, your
first option is to set an individual alert on each symbol.
Unfortunately, there is no automated method to set the same alert across
many symbols simultaneously in a single action. It\'s also important to
note that the TradingView
[screener](https://www.tradingview.com/screener/) can only operate with
its built-in filters and doesn\'t support custom Pine Script™.

To effectively run a custom script that generates alerts on multiple
symbols, you can use the
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
function to call data from a pre-set limited list of symbols, up to a
maximum of 40 symbols. This approach enables monitoring multiple symbols
with a single script and allows you to generate alerts that include the
symbol\'s name, by using
[placeholders](https://www.tradingview.com/support/solutions/43000531021-how-to-use-a-variable-value-in-alert/)
or dynamically constructed strings in your alert text. If you look up
\"[screener](https://www.tradingview.com/scripts/search/screener/)\" in
the Community Collection, you will find a few script examples that
utilize this technique. Here is an example incorporating just 3 symbols:

![image](@assets/images/Alerts-I-have-a-custom-script-that-generates-alerts-how-do-i-run-it-on-many-symbols-1.png)

``` pine
//@version=5
indicator("Screener demo", overlay = true)

// Declare inputs for the alert symbols and the timeframe to run the alerts on. Default is the current chart timeframe.
string tfInput      = input.timeframe("", "Timeframe")
string symbol1Input = input.symbol("BINANCE:ETHUSDT", "Symbol 1")
string symbol2Input = input.symbol("BINANCE:BATUSDT", "Symbol 2")
string symbol3Input = input.symbol("BINANCE:SOLUSDT", "Symbol 3")

// @function                Analyzes the RSI and EMA indicators to generate trading alerts based on specific crossover and crossunder events:
//                              1. RSI crossing over or under the 50 level.
//                              2. Price crossing over or under the 50-period EMA.
// @returns                 (string) A string containing formatted alert messages with relevant
//                          values that pertain to each crossover and crossunder event detected.
checkForRsiConditions() =>
    float  rsi = ta.rsi(close, 14)
    float  ema = ta.ema(close, 50)
    string alertMessage = ""
    if ta.crossover(rsi, 50)
        alertMessage += str.format("RSI ({0}) crossed over 50 for {1} on {2} timeframe!\n", rsi, syminfo.ticker, timeframe.period)
    if ta.crossunder(rsi, 50)
        alertMessage += str.format("RSI ({0}) crossed under 50 for {1} on {2} timeframe!\n", rsi, syminfo.ticker, timeframe.period)
    if ta.crossover(close, ema)
        alertMessage += str.format("Crossover of 50 EMA for {0} on {1} timeframe. Price is {2}", syminfo.ticker, timeframe.period, close)
    if ta.crossunder(close, ema)
        alertMessage += str.format("Crossunder of 50 EMA for {0} on {1} timeframe. Price is {2}", syminfo.ticker, timeframe.period, close)

// @function                Executes the `checkForRsiConditions()` function within the context of the provided symbol and 
//                          timeframe. If the function returns a message, an alert containing that message is triggered.
// @param symbol            (simple string) The symbol on which to check for conditions.
// @param tf                (simple string) The timeframe to check for conditions on.
// @param freq              (const string) The frequency of the alert. Optional. Default is `alert.freq_once_per_bar`.
// @returns                 (void) The function has no explicit return, but triggers an alert with the message if the
//                          conditions defined within the `checkForRsiConditions()` function are met.
checkForAlert(simple string symbol, simple string tf, const string freq = alert.freq_once_per_bar) =>
    string msg = request.security(symbol, tf, checkForRsiConditions())
    if msg != msg[1] and str.length(msg) > 0
        alert(msg, freq)

// Check for alerts on the input symbols and timeframe.
checkForAlert(symbol1Input, tfInput)
checkForAlert(symbol2Input, tfInput)
checkForAlert(symbol3Input, tfInput)
// Continue with additional symbols up to a maximum of 40...
```

**In our script we:**

-   First create inputs for a timeframe, and three symbols. These inputs
    will be used in the
    [request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
    function to call our alert data from three different instruments on
    a given timeframe. Note that the default timeframe is set to the
    current chart\'s timeframe.

-   Define a function called `checkForRsiConditions()`. In this
    function, we create conditions using the RSI and EMA:

    -   RSI crossing over or under the 50 level.

    \- Price crossing over or under the 50-period EMA. When any of these
    conditions are met, the function constructs and returns a string
    variable. This string dynamically includes information about the
    specific condition that was met and the details of the symbol it
    pertains to.

-   Define a function named `checkForAlert()`. This function utilizes
    [request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
    with a specified timeframe and symbol to execute the
    `checkForRsiConditions()` function within the context of the chosen
    symbol. Should a message be returned by `checkForRsiConditions()`
    for the requested symbol, the `checkForAlert()` function uses the
    [alert()](https://www.tradingview.com/pine-script-reference/v5/#fun_alert)
    function, which delivers the message in an alert.

-   Call the function once for each provided symbol to monitor their
    respective data feeds. This process checks for our conditions on
    each symbol, and if these conditions are met, it triggers an alert
    for that symbol.

In our example script, the `checkForAlert()` function has the potential
to be called a maximum of 40 times, allowing for the capability to
monitor up to 40 different symbols. This limitation is due to the
maximum number of calls allowed by
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
being capped at 40.

### Is it possible to use a string that varies as an argument to the alertcondition() function's message = parameter? 

In the context of the
[alertcondition()](https://www.tradingview.com/pine-script-reference/v5/#fun_alertcondition)
function, particularly its message parameter, it\'s important to
understand the limitations and capabilities for incorporating dynamic
content. The message parameter cannot be constructed with script
variables that change over time, as it requires a
\"[const](/pine-script-docs/language/type-system#const)\" string determined at compile time. This limitation means
you can\'t use string variables with \"series\"
[qualifiers](/pine-script-docs/language/type-system#qualifiers)
that vary from bar to bar during the script\'s execution.

However, you can still introduce dynamic elements in the message through
the use of
[placeholders](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Alerts.html#placeholders).
These placeholders are specifically designed to incorporate variable
values that can change with each bar into the message parameter. When an
alert is activated, these placeholders are automatically substituted
with the corresponding dynamic values. This method is the only way to
include variability in the messages for alerts generated by the
`alertcondition()` function.

Here we demonstrate a simple alert condition example that utilizes
placeholders to incorporate dynamic values into the alert message:

``` pine
//@version=5
indicator("Placeholder Demo")

[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)
plot(macdLine,   "MACD",   color.blue)
plot(signalLine, "Signal", color.orange)
plot(histLine,   "Hist.",  color.red, style = plot.style_histogram)

bool crossUp = ta.crossover(macdLine,  signalLine)
bool crossDn = ta.crossunder(macdLine, signalLine)

alertcondition(crossUp, "MACD Cross Up",   "MACD cross up on {{exchange}}:{{ticker}}\nprice = {{close}}\nvolume = {{volume}}")
alertcondition(crossDn, "MACD Cross Down", "MACD cross down on {{exchange}}:{{ticker}}\nprice = {{close}}\nvolume = {{volume}}")
```

### How can I include values that change in my alerts? 

In Pine Script™, there are three primary methods to include dynamic
values in alerts: using
[placeholders](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Alerts.html#placeholders)
in
[alertcondition()](https://www.tradingview.com/pine-script-reference/v5/#fun_alertcondition),
using \"series\" strings in
[alert()](https://www.tradingview.com/pine-script-reference/v5/#fun_alert),
and using \"series\" strings and/or strategy placeholders for
strategies. Here\'s a brief overview of each:

1.  **Using placeholders in alertcondition():** Placeholders like
    `{{close}}`, `{{volume}}`, etc., can be used in your alert message
    to include realtime values from your script. This method is
    straightforward and commonly used for basic alerts.

    ``` pine
    //@version=5
    indicator("")
    float avgVol = ta.sma(volume, 20)
    plot(volume, "Volume", close >= open ? color.green : color.red ,style = plot.style_columns)
    plot(avgVol, "20 SMA", color.yellow)
    alertcondition(volume > avgVol, "Volume alert", "Volume ({{plot_0}}) > average ({{plot_1}})")
    ```

2.  **Using \"series\" strings in alert():** For more customization, you
    can use a
    \"[series](/pine-script-docs/language/type-system#series)\" string within the
    [alert()](https://www.tradingview.com/pine-script-reference/v5/#fun_alert)
    function. This allows the alert to dynamically include values
    directly from the script\'s series, offering more flexibility in
    what information is relayed.

    ``` pine
    //@version=5
    indicator("")
    float avgVol = ta.sma(volume, 20)
    plot(volume, "Volume", close >= open ? color.green : color.red ,style = plot.style_columns)
    plot(avgVol, "20 SMA", color.yellow)
    if volume > avgVol
        alert(str.format("Volume {0} > average {1}", volume, avgVol))
    ```

3.  **For strategies - \"series\" strings and/or strategy
    placeholders:** When dealing with [strategy
    alerts](https://www.tradingview.com/support/solutions/43000481368-strategy-alerts/),
    you can utilize \"series\" strings, strategy-specific placeholders,
    or a combination of both. This provides the most comprehensive way
    to include dynamic information, such as strategy execution details,
    in your alerts.

    ``` pine
    //@version=5
    //@strategy_alert_message {{strategy.order.alert_message}}

    strategy("My strategy", overlay = true, default_qty_type = strategy.cash, default_qty_value = 10000, initial_capital = 10000)
    bool longCondition  = ta.crossover(ta.sma(close,  14), ta.sma(close, 28))
    bool shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))
    string alertMessage = "{{strategy.market_position}} {{strategy.position_size}} {{ticker}} @ {{strategy.order.price}}" +
     "\nCurrent equity: " + str.tostring(strategy.equity) +
     "\nMax Drawdown: "   + str.tostring(strategy.max_drawdown_percent, "#.##") + "%" +
     "\nMax Runup: "      + str.tostring(strategy.max_runup_percent,    "#.##") + "%" +
     "\nNet Profit: "     + str.tostring(strategy.netprofit_percent,    "#.##") + "%"
    if longCondition
        strategy.entry("My Long Entry Id", strategy.long, alert_message = alertMessage)
    if shortCondition
        strategy.entry("My Short Entry Id", strategy.short, alert_message = alertMessage)
    ```

To access a comprehensive list of placeholders and detailed examples,
please visit the [Help Center
article](https://www.tradingview.com/support/solutions/43000531021-how-to-use-a-variable-value-in-alert/)
dedicated to integrating variable values in your alerts. For an in-depth
understanding of the three types of alerts, refer to the
[FAQ section](/pine-script-docs/faq#how-do-imake-an-alert-available-from-my-script) about incorporating alerts into your scripts, as well as the
alert-specific section in the
[User Manual](/pine-script-docs/concepts/alerts).

### How can I create JSON messages in my alerts? 

In Pine Script™, while there are no native functions to directly produce
JSON, you can create JSON messages by dynamically constructing strings.
This is particularly useful when using
[webhooks](https://www.tradingview.com/support/solutions/43000529348-about-webhooks/)
for sending alerts. Here\'s how you can do it:

1.  **Learn JSON basics:** JSON, or JavaScript Object Notation, is a
    format for data exchange. It\'s important to ensure that the string
    you construct adheres to the JSON format, with proper keys and
    values enclosed in curly braces `{}` and separated by commas.
    Familiarize yourself with JSON on its [wiki
    page](https://en.wikipedia.org/wiki/JSON).
2.  **Create a JSON string in Pine Script™:** Manually construct a
    JSON-formatted string within your Pine Script. Ensure that keys and
    string values are enclosed in double quotes.
3.  **Integration with webhooks:**
    [Webhooks](https://www.tradingview.com/support/solutions/43000529348-about-webhooks/)
    enable realtime communication between applications by having a
    server send POST requests to a designated URL following certain
    events. To use this with TradingView alerts, first select the
    webhook option in the alert setup. Then, enter your application\'s
    webhook URL in the alert UI. Once the alert is triggered, it will
    automatically send a POST request containing your alert\'s JSON
    message in the body of the request to your application.
4.  **Content-type consideration:** TradingView will use the
    \"application/json\" content-type header for valid JSON messages. If
    the message isn\'t valid JSON, it defaults to \"text/plain\". Since
    many applications anticipate receiving webhook data in JSON format,
    ensuring that your message is correctly formatted as JSON is crucial
    for the successful transmission and processing of data through
    webhooks.
5.  **Validate and troubleshoot your JSON messages:** It's crucial to
    test your JSON string format to ensure it\'s valid and meets your
    requirements. Incorrect formatting can lead to errors in processing
    the webhook requests. Here are some ways you can test your JSON:
    -   **Email testing:** Initially, test your JSON by sending alerts
        to an email address. This allows you to see how the JSON message
        is rendered, mimicking the way your application would process
        it. Inspect and modify the format as needed based on this
        review.
    -   **Online JSON validator:** Copy your alert message from your
        email and paste it in an online [JSON validation
        tool](https://jsonlint.com/) to check the correctness of your
        JSON messages. These tools can also improve readability by
        prettifying your JSON.
    -   **Use API client applications:** For further troubleshooting,
        free applications like Postman or Insomnia can be useful. These
        API clients allow you to send requests and view server
        responses, making it easier to test and refine your alert
        messages. You can send your JSON you received in your email
        directly to your endpoint, view the responses, and make
        necessary adjustments until the desired response is achieved.
        This step-by-step approach aids in pinpointing and resolving
        issues that may not be apparent when directly sending alerts
        from TradingView.

Here are some examples of different ways to construct strings in Pine
Script™ in JSON format:

``` pine
//@version=5
indicator("JSON example", overlay = true)

// Define an ema, create cross conditions, and plot the ema on the chart.
float ema = ta.ema(close, 21)
bool crossUp = ta.crossover(close,  ema)
bool crossDn = ta.crossunder(close, ema)
plot(ta.ema(close, 21))

// ————— Method 1 - Separate alerts with static messages.
string alertMessage1a = '{"method": 1, "action": "buy", "direction": "long", "text": "Price crossed above EMA"}'
string alertMessage1b = '{"method": 1, "action": "sell", "direction": "short", "text": "Price crossed below EMA"}'
alertcondition(crossUp, "Method 1 - Cross up",   alertMessage1a)
alertcondition(crossDn, "Method 1 - Cross down", alertMessage1b)

// Rendered alert:
// {
//     "method": 1,
//     "action": "buy",
//     "direction": "long",
//     "text": "Price crossed above EMA"
// }

// ————— Method 2 - Using placeholders for dynamic values.
string alertMessage2 = '{"method": 2, "price": {{close}}, "volume": {{volume}}, "ema": {{plot_0}}}'
alertcondition(crossUp, "Method 2 - Cross Up", alertMessage2)

// Rendered alert:
// {
//     "method": 2,
//     "price": 2066.29,
//     "volume": 100.859,
//     "ema": 2066.286
// }

// ————— Method 3 - String concatenation using dynamic values.
string alertMessage3 =
 '{"method": 3, "price": ' + str.tostring(close) + ', "volume": ' + str.tostring(volume) + ', "ema": ' + str.tostring(ema) + '}'
if crossUp
    alert(alertMessage3, alert.freq_once_per_bar_close)

// Rendered alert:
// {
//     "method": 3,
//     "price": 2052.27,
//     "volume": 107.683,
//     "ema": 2052.168
// }
```

In our example script, we demonstrate 3 methods to construct strings in
Pine Script™ in JSON format:

1.  **Method 1: Static JSON Strings**

    This method involves creating static JSON strings as separate alert
    messages. It\'s a straightforward approach where the content of the
    alert message is predefined and does not change dynamically with
    script variables. This method is easy to implement and is best
    suited for alerts where the message content is fixed and does not
    require realtime data from the script. However, it lacks the
    flexibility to include dynamic script data.

2.  **Method 2: Placeholders for Dynamic Values**

    This method utilizes
    [placeholders](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Alerts.html#placeholders)
    within the JSON string, which are replaced with realtime script
    values when the alert is triggered. For example, `alertMessage2` has
    placeholders such as `{{close}}`, `{{volume}}`, and `{{plot_0}}`,
    which dynamically update with the current close price, volume, and
    the value of the first plot (EMA) when the alert is activated.
    Suitable for alerts requiring realtime data, this approach offers
    more flexibility than static messages but is confined to the list of
    available predefined placeholders.

3.  **Method 3: Dynamic String Concatenation**

    This method involves dynamically constructing the JSON string by
    concatenating static text parts with dynamically evaluated script
    values. In our example script, `alertMessage3` is created by
    combining static JSON structure elements with dynamic values
    converted to strings using
    [str.tostring()](https://www.tradingview.com/pine-script-reference/v5/#fun_str.tostring).
    This approach is highly customizable and allows for the creation of
    complex JSON structures with dynamic data or any value from your
    script, making it suitable for more advanced alerts. However, it
    requires careful string construction to ensure the JSON format is
    valid and can be more verbose than the simpler methods.

:::warning[Notice!]
Method 2 is also an attractive option when dealing with
[strategy alerts](/pine-script-docs/faq#using-order-fills-in-strategy-scripts) due to the comprehensive list of [strategy-specific
placeholders](https://www.tradingview.com/support/solutions/43000481368-strategy-alerts/).
These placeholders can be used directly in your script within the
`alert_message` argument of strategy `order
placement commands <PageStrategies_OrdersAndEntries_OrderPlacementCommands>` or in the alert message box of the alert UI.
:::

### Can my Pine strategy or indicator place automated orders in markets? 

No, Pine Script™ strategies and indicators on TradingView cannot
directly place automated orders on exchanges. However, there are
indirect methods available for those looking to integrate automation
into their trading strategies.

TradingView does provide broker integration, but it\'s important to
understand that this feature is designed for manual, discretionary
trading. The platform does not support full API integration for
automated trading with the brokers it collaborates with. This means you
cannot directly link your Pine Script™ strategy or indicator to your
brokerage account for automatic order execution.

However, a popular workaround involves the use of
[alerts](/pine-script-docs/concepts/alerts). Pine Script™ can be
used to generate
[webhooks](https://www.tradingview.com/support/solutions/43000529348-about-webhooks/)
from alert events based on specific conditions or criteria. These
webhooks can then be sent to an intermediary application or a
third-party order execution engine. This engine acts as a bridge,
receiving the webhook and then executing orders on your behalf through
the exchange\'s API. This approach effectively turns alerts into a
trigger for automated trading, albeit outside the TradingView
environment.

The scope of markets you can access through this method depends largely
on the third-party execution engine you choose. There is a healthy
ecosystem of such engines available, capable of handling a variety of
market types including conventional and crypto markets. Here is a list
of some execution engines available for different markets:

**CFD, Commodities, Forex, Futures, Indices, Options, Stocks:**

-   [TradingConnector](https://www.tradingconnector.com/)
-   [TradeRelay](http://www.traderelay.net/)
-   [NextLevelBot](https://nextlevelbot.com/) (specifically for India)

**Crypto Markets:**

-   [3commas](https://3commas.io/)
-   [Aleeert](https://aleeert.com/)
-   [Alertatron](https://alertatron.com/docs/automated-trading/trading-faq)
-   [Autoview](https://autoview.with.pink/)
-   [Cornix](https://cornix.io/)
-   [Cryptocurrencies.Ai](https://blog.aldrin.com/how-to-trade-with-trading-view-alerts-3678fe22b16d)
-   [CryptoHopper](https://docs.cryptohopper.com/docs/apps/cryptohopper-tradingview-webhooks/)
-   [Gunbot with TradingView
    add-on](https://wiki.gunthy.org/how-to-work-with-gunbot/extra-modules/tradingview-alerts)
-   [HaasOnline](https://help.haasonline.com/docs/custom-trade-bots/email-bot/tradingview-alert-guide)
-   [Jackrabbit Relay](https://github.com/rapmd73/JackrabbitRelay/wiki)
    (free option)
-   [Jubot](https://www.jubot.io/)
-   [NextLevelBot](https://nextlevelbot.com/)
-   [ProfitTrailer](https://profittrailer.com/product/pt-tradingview-integration/)
-   [ProfitView](https://profitview.app/)
-   [TradingBot](https://tradingbot-solutions.com/trading-academy/tradingview-webhook-crypto-trading-bot/)
-   [TradeRelay](http://www.traderelay.net/)
-   [WunderTrading](https://trading.wunderbit.co/) (free option)
-   [Zignaly](https://zignaly.com/#cryptoTradingBot) (free option)

It\'s worth noting that while this list provides a range of options,
TradingView *does not* officially support or affiliate with any of these
services. The reliability, cost, and performance of these services are
independent of TradingView, and users should exercise due diligence when
selecting an execution engine. This includes researching each service's
track record, understanding their security measures, comparing fee
structures, considering the markets they can access, and analyzing each
service's capability to perform specific trading tasks, such as the
range of order types they support, their execution speed, and the
ability to handle complex trading strategies. Ensure that the service
aligns with your specific trading needs, risk tolerance, and budget.
Remember, while this method facilitates a form of automated trading, it
is not a fully integrated solution, and therefore, the reliability and
implementation of trade operations are not guaranteed.

For users with technical expertise, particularly in coding, there is the
possibility of creating your own intermediary application. This custom
solution could serve a similar purpose as third-party execution engines,
enabling the capture and processing of alerts from TradingView and
interfacing directly with the exchange\'s API to execute orders.
Building your own application offers a higher degree of customization
and control, allowing you to tailor the system to your specific trading
strategies and preferences. However, this approach requires a
significant investment of time and technical skill, and it's crucial to
ensure robust security measures and reliable performance. Undertaking
this project is an independent effort and users engage in these projects
at their own risk. TradingView does not provide support for the
development of such custom solutions.

In summary, while direct automated order placement is not possible
through Pine Script™ strategies and indicators, the platform does offer
the flexibility to use alerts in conjunction with external tools and
applications to achieve a similar outcome. This approach requires
additional setup and consideration of the tools and services used for
execution.

### How can I send alerts from my script to Discord? 

Sending [alerts](/pine-script-docs/concepts/alerts) from your
Pine Script™ to Discord can be achieved using
[webhooks](https://www.tradingview.com/support/solutions/43000529348-about-webhooks/).
Webhooks are automated communication methods that allow applications to
interact. By integrating webhooks in your script, you can post messages
in a Discord chat room, provided you have the appropriate permissions on
the Discord server. Let\'s walk through how you can set up your script
alerts to Discord, starting with a simple script example:

![image](@assets/images/Alerts-How-can-i-send-alerts-from-my-script-to-discord-1.png)

``` pine
//@version=5
indicator("Discord demo", overlay = true)
// Calculate a Donchian channel using the TV ta library.
import TradingView/ta/7 as TVta
int lengthInput = input.int(10, "Channel length")
[highest, lowest, middle] = TVta.donchian(lengthInput)
// Create conditions checking for a new channel high or low.
bool isNewHi = high > highest[1]
bool isNewLo = low  <  lowest[1]
// Plot the Donchian channel and fill between the midpoint and the upper and lower halves.
hi  = plot(highest, "Channel high", color.new(color.fuchsia, 70))
mid = plot(middle,  "Channel mid.", color.new(color.gray,    70))
lo  = plot(lowest,  "Channel low",  color.new(color.lime,    70))
fill(mid, hi, color.new(color.fuchsia, 95))
fill(mid, lo, color.new(color.lime,    95))
// Plot shapes to mark new highs and lows to visually identify where alerts will occur.
plotshape(isNewHi, "isNewHi", shape.arrowup,   location.abovebar, color.new(color.lime,    70))
plotshape(isNewLo, "isNewLo", shape.arrowdown, location.belowbar, color.new(color.fuchsia, 70))
// Create two alert conditions, one for new highs, and one for new lows.
// We format the message for Discord in the following JSON format:
//      {"content": "Your message here"}
alertcondition(isNewHi, "New High Discord", '{"content": "New high ({{high}}) on {{ticker}} on {{interval}} chart!"}')
alertcondition(isNewLo, "New Low Discord", '{"content": "New low ({{low}}) on {{ticker}} on {{interval}} chart!"}')
// For testing, you can create an alert condition that will trigger right away, like the following alert condition.
// Set this alert frequency for "only once" when configuring your alert to test your webhook.
alertcondition(true, "For testing", '{"content": "Test test one two one two"}')
```

Our example script showcases how to trigger two types of alerts: one for
new highs and another for new lows in a [Donchian
channel](https://www.tradingview.com/support/solutions/43000502253-donchian-channels-dc/).
The key is to use the
[alertcondition()](https://www.tradingview.com/pine-script-reference/v5/#fun_alertcondition)
function, where we format the message for Discord in [JSON
format](https://en.wikipedia.org/wiki/JSON). The
`{"content": "Your message here"}` format is the minimum requirement for
sending messages to Discord. For advanced JSON message configurations,
consult [Discord\'s webhooks
guide](https://birdie0.github.io/discord-webhooks-guide/index.html).
Note that this example uses
[placeholders](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Alerts.html#placeholders)
to dynamically populate the alert message with script values, like the
new high or low price, the chart\'s symbol, and timeframe when the alert
is triggered. Additionally, for guidance on integrating dynamic values
in alert messages, consult the \"`How can I include
values that change in my alerts? <PageFaq_Alerts_HowCanIIncludeValuesThatChangeInMyAlerts>`\" section in the FAQ.

To effectively set up these alerts in TradingView and link them to your
Discord, follow these steps:

**Step 1:** Create a Discord webhook

-   **Open Discord:**
    -   Log in to your Discord account.
    -   Navigate to the server where you want to receive notifications.
-   **Create a webhook:**
    -   Go to the server settings (right click on the server name, then
        select \"Server Settings\").
    -   Select the \"Integrations\" tab.
    -   Click on \"Webhooks\" and then \"New Webhook\".
    -   Name your webhook and select the channel where messages will be
        posted.
    -   Copy the Webhook URL by clicking \"Copy Webhook URL\". This URL
        is the address where your alert\'s webhooks will be sent to link
        TradingView with Discord.

**Step 2:** Set up an alert on TradingView

-   **Open TradingView:**
    -   Log in to your TradingView account.
    -   Navigate to the chart where you want to set an alert.
    -   Add our example indicator to the chart.
-   **Create an alert:**
    -   Click on the \"Alert\" icon (bell symbol) on the top toolbar, or
        the 3 dots when highlighting the title of the indicator on the
        chart.
    -   Make sure the \"Discord demo\" script is selected in the
        condition list. Select \"New high Discord\" alert in the
        selection drop down.
    -   In the alert notification settings, choose \"Webhook URL\" as
        the delivery method.
    -   Paste the Discord webhook URL you copied earlier into the
        \"Webhook URL\" field.
    -   Create a second alert for the \"New low Discord\" and repeat the
        steps to set up the webhook. Note that each mention of the
        [alertcondition()](https://www.tradingview.com/pine-script-reference/v5/#fun_alertcondition)
        function requires alert setup. We have 2 alert conditions in our
        script, so two alerts are to be configured.

**Step 3:** Test and monitor

-   **Test your alert:**
    -   Before relying on actual trading alerts, it\'s helpful to test
        the webhook integration to confirm everything is working as
        expected. This preemptive step helps avoid delays or missed
        alerts due to setup issues.
    -   Our script includes a special \"For testing\" alert condition
        designed to fire immediately when configured. To test your
        Discord webhook, set up this test alert by following the steps
        outlined above, but ensure you set the frequency to \"Only
        once.\" This prevents the alert from triggering multiple times.
    -   Once this test condition is met, TradingView should immediately
        send a notification to your specified Discord channel. Check
        your Discord to confirm the alert is received as expected.
-   **Monitor notifications:**
    -   After confirming that the webhook works as expected with the
        test alert, wait for the script to fire alerts.
    -   When the scripts alert conditions are met, your Discord channel
        will now receive messages like the following:

![image](@assets/images/Alerts-How-can-i-send-alerts-from-my-script-to-discord-2.png)

**Tips and Troubleshooting**

-   **Alert Conditions:** Verify your alert conditions on TradingView to
    ensure they are set up as intended. Check that alerts are actually
    triggering in your alert window.
-   **Check Webhook URL:** Ensure the webhook URL is correctly copied
    from Discord to TradingView.
-   **JSON Format:** If the message isn\'t displaying correctly in
    Discord, check if the JSON format is required and properly used. The
    required format is: `{"content": "Your message here"}`
-   **Discord Permissions:** Ensure your Discord account has the
    necessary permissions to create and manage webhooks on the server.

:::warning[Notice!]
For further guidance, explore
[how do I make an alert available from my Script](/pine-script-docs/faq#how-do-imake-an-alert-available-from-my-script) and review the
[alert-specific](/pine-script-docs/concepts/alerts) section of
the User Manual. Additionally, our FAQ provides insights on effectively
[sending JSON messages from your scripts](/pine-script-docs/faq#how-can-icreate-json-messages-in-my-alerts).
:::

### How can I send alerts to Telegram? 

Integrating TradingView alerts with Telegram directly can be challenging
due to protocol differences and specific formatting requirements.
Telegram\'s API, particularly its
[sendMessage](https://core.telegram.org/bots/api#sendmessage) method,
requires messages in a distinct format, which does not naturally align
with how TradingView sends its webhook alerts. For more details on
TradingView\'s webhook format, refer to our [Help
Center](https://www.tradingview.com/support/solutions/43000529348-about-webhooks/)
article.

**Solution:** Using an Intermediary Service

To effectively connect TradingView and Telegram, you can use an
intermediary service. This service acts as a bridge, receiving webhook
alerts from TradingView, formatting them as required by Telegram, and
then forwarding them to your Telegram bot. While setting up such a
service requires some technical know-how, it\'s a feasible solution even
for those with limited experience.

**Steps for Setup:**

1.  **Choose an Intermediary Service:** Opt for a platform like Zapier,
    Integromat, Pipedream, or consider developing a custom server script
    using Node.js or Python.
2.  **Configure TradingView Webhook:** In TradingView, set up your
    alerts to send webhook requests to the URL provided by your chosen
    intermediary service.
3.  **Intermediary Processing:** Configure the intermediary to parse
    TradingView\'s incoming requests and reformat them for Telegram's
    API.
4.  **Forward to Telegram:** Have the intermediary service send the
    formatted message to your Telegram bot using the `sendMessage`
    method.

**Additional Resources:**

-   For a practical demonstration, check out this step-by-step [video
    tutorial](https://www.tradingview.com/chart/BTCUSDTPERP/7wzCx7yr-How-to-Send-Alerts-from-Tradingview-to-Telegram/)
    available on TradingView. It guides you through setting up the
    intermediary service and integrating it with both TradingView and
    Telegram.
-   If you\'re seeking more advanced, developer-oriented details, the
    Telegram Bot API [documentation](https://core.telegram.org/bots)
    offers comprehensive technical insights.

### Why did my alerts get stopped? 

Experiencing issues with TradingView alerts not firing can be due to
various reasons. It's important to accurately diagnose the issue to
apply the correct solution. Here are some common causes and their
solutions:

**Alert configuration:**

-   To ensure your script\'s alert functions are active, you must
    manually configure and activate them from TradingView\'s alert UI.
    Simply including alert functions in your script does not activate
    them on the server. Make sure your alerts are [properly set
    up](https://www.tradingview.com/support/solutions/43000595315-how-to-set-up-alerts/)
    to become active.

**Check alert logs:**

-   Sometimes, the problem may lie in receiving notifications, not with
    the alert functionality itself. To verify if your alerts are
    actually triggering, check the [alert
    manager](https://www.tradingview.com/support/solutions/43000595311-manage-alerts/)
    in TradingView.

**Check for repainting:**

-   If your alerts are firing at different times than expected, it might
    not be a case of them stopping. Often, this is due to repainting in
    your script rather than a malfunction. For a deeper understanding of
    repainting and how it affects alerts, refer to the section on
    repainting in the [User Manual](/pine-script-docs/concepts/repainting).

**Alerts frequency limit:**

-   TradingView has a [frequency
    limit](https://www.tradingview.com/support/solutions/43000690939-alert-was-triggered-too-often-and-stopped/)
    for alerts. If more than 15 alerts are triggered within a 3-minute
    window, the system will automatically halt further alerts. This is
    to prevent excessive notifications and potential server overload.

**Script errors:**

-   Runtime errors in your script can lead to halted alerts. While your
    script might not show errors initially, it can encounter issues when
    running continuously on the server. Common script errors that can
    stop alerts include:
    -   **Array size limitations:** Arrays in Pine Script are limited to
        [100,000 items](/pine-script-docs/language/arrays#array-is-too-large). Exceeding this limit will cause errors. Incorporate
        methods that
        [mitigate the size](/pine-script-docs/language/arrays#removing) of arrays to prevent them from becoming larger than
        the limit.
    -   **Calculation errors:** Conditional code execution may lead to
        errors only under specific circumstances.
    -   **Excessive historical referencing:** Overextending historical
        data references can lead to script errors. More on historical
        buffers can be found
        [here](https://www.tradingview.com/pine-script-docs/en/v5/Error_messages.html#pine-script-cannot-determine-the-referencing-length-of-a-series-try-using-max-bars-back-in-the-indicator-or-strategy-function).
    -   **Long execution loops:** If loop execution time exceeds the
        500ms limitation, it can error out your script. Learn more about
        loop computation time
        [here](https://www.tradingview.com/pine-script-docs/en/v5/Error_messages.html#loop-is-too-long-500-ms).

**Other technical difficulties:**

-   For a comprehensive list of common script errors and troubleshooting
    tips, see the section on [error
    messages](https://www.tradingview.com/pine-script-docs/en/v5/Error_messages.html#error-messages)
    in the User Manual.

Understanding these common pitfalls can help you diagnose why your
alerts might have stopped and how to resolve the issue effectively.

### Why is my alert firing when it\'s not supposed to? 

If you find that your TradingView alerts are firing unexpectedly in
relation to what your indicator displays on the chart, it\'s often due
to [repainting](/pine-script-docs/concepts/repainting) in your
script. Repainting occurs when there\'s a discrepancy between how your
script behaves in realtime versus calculations made on historical data.
This phenomenon is particularly noticeable when setting alerts, as these
are designed to function within the realtime data stream. Initially,
when you load a chart, it displays historical data and only switches to
realtime data from the point of the first realtime bar. This can result
in observable differences if your script processes realtime and
historical data differently.

The following are the most commonly encountered issues that can lead to
discrepancies between the behavior of your alerts and the historical
calculations of your script:

-   **Alerts firing before bar close:** Most indicators can exhibit some
    form of repainting, showing one value on historical bars and
    [fluctuating results](/pine-script-docs/concepts/repainting#fluid-data-values) in realtime until the bar closes. This occurs because
    historical bars present a single, fixed set of data, whereas
    realtime bars are subject to multiple price updates before they
    close. Similarly, alerts can fire on these fluctuating price updates
    as a bar forms, which may differ from the stable values observed on
    historical or fully-formed bars. [To mitigate
    this](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Alerts.html#avoiding-repainting-with-alerts),
    configure your alerts to trigger \"on bar close.\" This ensures that
    alerts reflect the final state of the realtime bar, aligning with
    the established values on historical bars.
-   **Using calc_on_every_tick in strategies:** When a
    [strategy](/pine-script-docs/concepts/strategies) script is
    configured to recalculate on every price update using the
    `calc_on_every_tick` setting, it can lead to orders and alerts being
    triggered mid-bar in realtime. This behavior is a notable departure
    from that observed on historical bars where calculations are
    typically executed at bar close. Note that when this happens, it
    also invalidates backtesting results, as they are not representative
    of the strategy's behavior in realtime. To avoid this form of
    repainting, set `calc_on_every_tick` to `false` in the
    [strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
    function, or in the properties tab of the strategy\'s settings menu.
    To better understand how modifying the calculation settings of
    strategies affects how your strategy performs, refer to the section
    on
    [altering the calculation behavior](/pine-script-docs/concepts/strategies#altering-calculation-behavior) of strategies.
-   **Incorrect use of request.security() calls:** Incorrect usage of
    [request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
    calls will result in data discrepancies on historical bars that
    cannot be reproduced in realtime. Ensure you follow best practices
    for non-repainting calls, especially when requesting higher
    timeframe data. Detailed guidance on the proper use of
    `request.security()` can be found in our sections on
    [repainting higher timeframe calls](/pine-script-docs/concepts/repainting#repainting-request-security-calls) and
    [other timeframes and data](/pine-script-docs/concepts/other-timeframes-and-data). To see practical examples that illustrate the correct
    usage of `request.security()` alongside some improper variants, be
    sure to consult the [\`security()\`
    revisited](https://www.tradingview.com/script/00jFIl5w-security-revisited-PineCoders/)
    publication by PineCoders.
-   **Unavoidable data revisions:** Occasionally, historical data feeds
    undergo
    [revisions](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Repainting.html#revision-of-historical-data)
    by data suppliers, which can include adjustments to settlement
    prices or volumes. These unavoidable revisions can result in
    discrepancies, where an alert triggered by your script does not
    align with the script\'s output when reloaded with historical data.
    This discrepancy can be observed in stocks, for example, where
    realtime volume values vary from historical data due to block
    trades, or other trade types not included in intraday volume data.
    Additionally, the volume reporting rules for realtime data can vary
    from those for historical data for the same instrument, further
    contributing to these discrepancies. The [Volume
    X-ray](https://www.tradingview.com/script/tPsEizhp-Volume-X-ray-LucF/)
    script not only explores the intricacies of volume data reporting
    and restatement but also highlights possible differences in volume
    data feeds, providing in-depth insights in its detailed description.

For a comprehensive understanding of the nuances of repainting and its
impact on your scripts, reading the section on
[repainting](/pine-script-docs/concepts/repainting) in the Pine
Script™ User Manual, along with the linked resources provided in this
FAQ entry is highly recommended.

### How can I run my alert on a timer or delay? 

Implementing a timer or delay for
[alerts](/pine-script-docs/concepts/alerts) in Pine Script™ can
be challenging due to the inherent limitations of the runtime
environment. Pine Script™ [only executes on price updates in
realtime](https://www.tradingview.com/pine-script-docs/en/v5/language/Execution_model.html#calculation-based-on-realtime-bars),
which means without new price data, the script and consequently the
alerts, won\'t run. Here are some key considerations:

1.  **Non-uniform price updates:** The time between price updates can
    vary, particularly in markets with low liquidity such as micro cap
    penny stocks, where extended intervals between transactions are
    common. This variability means that a set delay might extend beyond
    its intended duration if a new price update doesn\'t occur promptly.
    As a result, both the script and any related alerts will remain
    inactive until the next price tick occurs, which could lead to
    unanticipated delays.
2.  **Market closure impact:** Alerts won\'t be sent when the market is
    closed, as there are no price updates to trigger script execution.
    This means that if a delay were to extend beyond the end of a
    trading session, the delay condition cannot be identified until the
    script runs again on the next session.

Considering these limitations, a more reliable solution might be to use
an intermediary application for delaying alerts. Many third-party order
execution engines and custom web applications allow for specifying
delays more effectively, functioning independently of price update
constraints.

Our script example, \"Delayed alert\", showcases an attempt to
effectively implement a time-delayed alert using Pine Script™:

![image](@assets/images/Alerts-How-can-i-run-my-alert-on-a-timer-or-delay-1.png)

``` pine
//@version=5
indicator("Delayed alert", overlay = true)

import PineCoders/Time/4 as PCtime

string TIME_TT  = "The delay's duration and units. This specifies the continuous duration for which the condition must be true before triggering the alert."
string RESET_TT = "When checked, the duration will reset every time a new realtime bar begins."
string TU0      = "seconds", string TU1 = "minutes", string TU2 = "hours",  

int    durationInput = input.int(20,     "Condition must last",     minval  = 1,       inline = "00")
string timeUnitInput = input.string(TU0, "",                        tooltip = TIME_TT, inline = "00", options = [TU0, TU1, TU2])
bool   resetInput    = input.bool(false, "Reset timing on new bar", tooltip = RESET_TT)
int    maLengthInput = input.int(9,      "Ma length")

// Calculate a SMA with `maLengthInput` length.
float ma = ta.sma(close, maLengthInput)
// Condition to check if the close is greater than the SMA.
bool cond = close > ma
// Time the duration the condition has been true.
int secSince = PCtime.secondsSince(cond, resetInput and barstate.isnew)
// Condition to check if the duration is greater than the input timer.
bool timeAlert = secSince > (PCtime.timeFrom("bar", durationInput, timeUnitInput) - time) / 1000
// Format a time string for the timer label.
string alertTime = str.format_time(secSince * 1000, "mm:ss")

plot(ma, "MA")

// Set the contents for the label depending on the stage of the alert timer.
string alertString = switch
    timeAlert => "Timed Alert Triggered\n\n" + alertTime
    cond      => "Condition Detected...\n\nTimer count\n" + alertTime
    =>           "Waiting for condition..."

// Display alert timer using a label. Update values on the last bar for efficiency.
if barstate.islast
    // Declare a basic label once.
    var label condTime = label.new(na, na, yloc = yloc.abovebar, style = label.style_label_lower_left, textcolor = chart.fg_color)
    // Update label for changes to location, color, and text.
    label.set_x(condTime, bar_index)
    label.set_text(condTime, alertString)
    label.set_color(condTime, color.new(timeAlert ? color.green : cond ? color.orange : color.red, 50))

// Create a flag to ensure alert is triggered only once each time the delay timer is exceeded.
varip bool isFirstOccurrence = true
// Fire alert if timer is triggered.
if timeAlert and isFirstOccurrence
    alert(str.format("{0} {1} Delayed Alert Triggered", durationInput, timeUnitInput), alert.freq_all)

// Toggle the flag to `false` when alert triggers, and reset when the condition clears.
isFirstOccurrence := not timeAlert
```

**In our script we:**

-   Import the `secondsSince()` function from the PineCoder\'s
    [time](https://www.tradingview.com/script/tyeeNU9I-Time/) library.
    -   The `secondsSince()` function determines the duration, in
        seconds, during which a certain condition remains continuously
        true. The timing commences when this condition shifts from a
        false to true state. Should the condition revert to false or an
        optional resetting condition be met, the timing sequence
        restarts. If \"*Reset timing on new bar*\" is enabled in the
        example script user menu, the function restarts its timing at
        the onset of a new bar.
    -   Note that the function only works in real time as historical
        bars have a limited number of data points per bar. It relies on
        realtime updates and the times that they occur.
-   Provide two inputs, `durationInput` and `timeUnitInput`, that
    together denote the amount of time a condition must persist as true
    for the delay. The amount of time is derived from the `timeFrom()`
    function of the PineCoder\'s
    [time](https://www.tradingview.com/script/tyeeNU9I-Time/) library,
    which accepts a time quantity and its unit. This calculated time is
    then compared with the time from the `secondsSince()` function to
    check if the duration condition has been fulfilled.
-   To provide a visual representation of the alert delay mechanism, we
    set a label to change through three distinct states, each indicated
    by a different color and corresponding text description. These
    states reflect the current stage of the delay process:
    1.  **Red** - Awaiting condition.
    2.  **Yellow** - Condition met and delay initiated.
    3.  **Green** - Timer has surpassed the set duration, simulating a
        delayed alert.
-   Trigger an alert when the timer has surpassed the set duration. We
    use a boolean flag, which ensures the alert triggers only once per
    occurrence. We format the alert text to indicate how much time the
    delay was set for.

While this script provides a basic implementation of a time-delayed
alert, it\'s important to remember the limitations of Pine Script™ in
realtime market conditions. For more nuanced or reliable delay
mechanisms, consider using external tools or services as mentioned
earlier.

:::warning[Notice!]
The unique functionality of the `secondsSince()` function is made
possible by the
[varip](https://www.tradingview.com/pine-script-reference/v5/#kw_varip)
keyword. This key feature allows the function to track and retain the
duration for which a specified condition remains true, across realtime
script executions. Unlike standard variables that reset with each
intrabar update,
[varip](https://www.tradingview.com/pine-script-reference/v5/#kw_varip)
variables maintain their state and escape the *rollback process*,
enabling the `secondsSince()` function to accurately calculate the
uninterrupted time since a condition first became true.
:::

For a deeper understanding of the functionality of variables declared
with
[varip](https://www.tradingview.com/pine-script-reference/v5/#kw_varip)
and their applications - Explore the
[varip variable declaration](/pine-script-docs/language/variable-declarations#varip) in the User Manual. - Refer to the Pine Script™
[execution model](/pine-script-docs/language/execution-model) for
more on realtime calculations and the *rollback process*. - Consult the
PineCoder\'s [Using \`varip\`
variables](https://www.tradingview.com/script/ppQxBISk-Using-varip-variables-PineCoders/)
publication.

### How can I trigger an alert only once when the condition is true the first time? 

It\'s common to encounter scenarios where you need an
[alert](/pine-script-docs/concepts/alerts) to be triggered only
once when a specific condition is met for the first time. This
requirement is often needed to avoid redundant alerts and to isolate
specific conditions or changes of state. For instance, where alerts are
linked to a
[third-party order execution engine](/pine-script-docs/faq#can-my-pine-strategy-or-indicator-place-automated-orders-in-markets), repeated alerts for the same condition can inadvertently
lead to multiple orders being placed, resulting in unintended trades or
overexposure. Below, we discuss several methods to effectively manage
and avoid redundant alerts:

**Understanding Alert Frequency**

Pine Script™ offers several
[methods to incorporate alerts](/pine-script-docs/faq#how-do-imake-an-alert-available-from-my-script) into your scripts. For indicators, there is
[alertcondition()](https://www.tradingview.com/pine-script-reference/v5/#fun_alertcondition)
and
[alert()](https://www.tradingview.com/pine-script-reference/v5/#fun_alert).
`alertcondition()`, when configured via the alert UI, allows
[frequency](https://www.tradingview.com/support/solutions/43000474415-differences-between-alert-frequencies/)
settings like *\'only once\'*, *\'once per bar\'*, or *\'once per bar
close\'*. The \'only once\' option triggers only on the first condition
met but would require manual reset for subsequent alerts. `alert()`, in
contrast, is controlled by the script\'s logic only. For either
function, to achieve *recurring alerts* that activate only at the
initial occurrence of a condition, manipulating the script\'s logic is
necessary.

**Using Conditional Statements**

A straightforward method to trigger an alert once involves using
specific conditional statements that identify the first occurrence.
Rather than relying on a continuous condition like `close > ma`, which
may remain true for multiple bars, using a condition like
`ta.crossover(close, ma)` ensures the alert triggers only on the first
bar where the crossover occurs. By simply refining the alert-triggering
logic to focus on the specific event of interest, we naturally mitigate
repeated or redundant alerts.

**Implementing State Control**

In more complex scenarios, managing the state of your script is
effective. This involves setting flags or states that change only at
certain events. For instance, switching from a *bearish* to *bullish*
state only when a specific bullish condition is met for the first time,
and not reacting to further bullish signals until a *bearish* state is
initiated.

Our example script, \"Single alert\", demonstrates an effective way to
manage state transitions and trigger alerts only at the first instance
of state changes:

![image](@assets/images/Alerts-How-can-i-trigger-an-alert-only-once-when-the-condition-is-true-the-first-time-1.png)

``` pine
//@version=5
indicator("Single alert", overlay = true)

// ————— Calculations: Determine highest/lowest values over last `lengthInput` bars.
int   lengthInput = input.int(20, "Length")
float highest     = ta.highest(lengthInput)
float lowest      = ta.lowest(lengthInput)
// ————— Trigger conditions: Define bull and bear signals. Bull signal is triggered by a new high, and bear by a new low.
bool bullSignal = high == highest
bool bearSignal = low  == lowest
// ————— State change flags: Set true on state transition bars only.
bool changeToBull = false
bool changeToBear = false
// ————— State tracking: `isBull` is set to true for bull state, false for bear. It's set only at the initial switch to the opposite condition.
// This variable's state is retained bar to bar because we use the `var` keyword to declare it.
var bool isBull = false
// ————— State transitions: Allow a switch from bull to bear or bear to bull; ignore repeated signals in current state.
// Set the state change flags to true only on the first bar where a new signal appears.
if bullSignal and not isBull
    isBull       := true
    changeToBull := true
else if bearSignal and isBull
    isBull       := false
    changeToBear := true

// Plot highest and lowest values.
plot(highest, "Highest", color.new(color.green, 80), 2)
plot(lowest,  "Lowest",  color.new(color.red,   80), 2)
// Background color: Green for bull, none for bear.
bgcolor(isBull ? color.new(color.green, 90) : na)
// State change markers: Display "ALERT" text on bars where a state change occurs and an alert would trigger.
plotchar(changeToBull, "Change to Bull state", "▲", location.belowbar, color.new(color.lime, 30), size = size.small, text = "BULL\nALERT")
plotchar(changeToBear, "Change to Bear state", "▼", location.abovebar, color.new(color.red,  30), size = size.small, text = "BEAR\nALERT")
// Signal markers: Display for repeated signals within the current state.
// These signals would trigger redundant alerts if not for the state tracking flag preventing them.
plotchar(bullSignal and not changeToBull, "Bull signal", "▲", location.belowbar, color.green,  size = size.tiny)
plotchar(bearSignal and not changeToBear, "Bear signal", "▼", location.abovebar, color.maroon, size = size.tiny)

// Alerts: Trigger on state changes only.
if changeToBull
    alert("Change to bull state")
if changeToBear
    alert("Change to bear state")
```

In this script, we manage two states -- bull and bear -- and set
conditions for transitioning between these states. Alerts are configured
to trigger only at the transition points, preventing redundant alerts
within a continuous state. This is visually represented with alert
markers on the chart and background color. Smaller arrows highlight
signals occurring within the current state, which, thanks to the state
tracking flag, do not trigger redundant alerts.

**Key Takeaways:**

-   By carefully managing alert conditions and script logic, you can
    ensure that your alerts only fire on certain events.
-   Remember to adjust the [alert
    frequency](https://www.tradingview.com/support/solutions/43000474415-differences-between-alert-frequencies/)
    settings in the TradingView UI when using `alertcondition()` or
    [within the alert()
    function](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Alerts.html#alert-function-events)
    to align with your script logic.
-   Ensure alert logic is tailored to prevent repeated alerts,
    especially critical when alerts are tied to automated trading
    systems, where each alert could trigger a new trade.
-   For complex alert logic, state control within your script offers a
    nuanced approach to alert management.

By leveraging conditional logic or state control in your script, you can
effectively trigger an alert only once when a condition is true for the
first time. These methods ensure that your script only alerts on the
first event without unnecessary repetition.

## Data Structures 

-   [What are the primary data structures available in Pine Script™?](/pine-script-docs/faq#what-are-the-primary-data-structures-available-in-pine-script)
    -   [Tuples](/pine-script-docs/faq#tuples)
    -   [Arrays](/pine-script-docs/faq#arrays)
    -   [Matrices](/pine-script-docs/faq#matrices)
    -   [Objects](/pine-script-docs/faq#objects)
    -   [Maps](/pine-script-docs/faq#maps)
-   [What is a series, and how does it differ from an array in Pine Script™?](/pine-script-docs/faq#what-is-aseries-and-how-does-it-differ-from-an-array-in-pine-script)
    -   [What is a Series in Pine Script™?](/pine-script-docs/faq#what-is-aseries-in-pine-script)
    -   [What is an Array in Pine Script™?](/pine-script-docs/faq#what-is-an-array-in-pine-script)
-   [How do I create and use arrays in Pine Script™?](/pine-script-docs/faq#how-do-icreate-and-use-arrays-in-pine-script)
-   [What's the difference between an array declared with var or without var?](/pine-script-docs/faq#whats-the-difference-between-an-array-declared-with-var-or-without-var)
-   [What does queue/stack mean?](/pine-script-docs/faq#what-does-queue-stack-mean)
-   [Can I use matrices or multidimensional arrays in Pine Script™?](/pine-script-docs/faq#can-iuse-matrices-or-multidimentional-arrays-in-pine-script)
-   [How can I perform operations on all elements in an array?](/pine-script-docs/faq#how-can-iperform-operations-on-all-elements-in-an-array)
-   [How can I efficiently search for an element in an array?](/pine-script-docs/faq#how-can-iefficiently-search-for-an-element-in-an-array)
-   [How can I debug arrays?](/pine-script-docs/faq#how-can-idebug-arrays)
    -   [Plotting](/pine-script-docs/faq#plotting)
    -   [Using labels](/pine-script-docs/faq#using-labels)
    -   [Using tables](/pine-script-docs/faq#using-tables)
    -   [Pine Logs](/pine-script-docs/faq#pine-logs)
-   [How can I debug objects?](/pine-script-docs/faq#how-can-idebug-objects)

### What are the primary data structures available in Pine Script™? 

There are a number of data structures in Pine Script™ similar to other
programming languages. Here is a list and an explanation of each:

#### Tuples 

A [tuple](/pine-script-docs/language/type-system#tuples) in Pine
Script™ is defined as comma-separated expressions enclosed within
parentheses. These structures are primarily utilized for returning
multiple values from
[functions](/pine-script-docs/language/user-defined-functions),
[methods](/pine-script-docs/language/methods), or local blocks.
While tuples offer versatility in many programming languages, allowing
for single variable assignments or storage in arrays or dictionaries,
their application in Pine Script™ is more constrained. In Pine Script™,
tuples are used primarily to return multiple values simultaneously from
functions. This can be particularly beneficial in optimizing script
performance by minimizing the frequency of
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
calls when multiple data points are needed from the same data feed and
the symbol and timeframe are the same. For instance, instead of making
separate `request.security()` calls for the
[open](https://www.tradingview.com/pine-script-reference/v5/#var_open),
[high](https://www.tradingview.com/pine-script-reference/v5/#var_high),
[low](https://www.tradingview.com/pine-script-reference/v5/#var_low),
and
[close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
prices like this:

``` pine
float o = request.security(syminfo.tickerid, "D", open)
float h = request.security(syminfo.tickerid, "D", high)
float l = request.security(syminfo.tickerid, "D", low)
float c = request.security(syminfo.tickerid, "D", close)
```

One can leverage tuples to consolidate these calls into a single
`request.security()` function call, reducing overhead:

``` pine
[o, h, l, c] = request.security(syminfo.tickerid, "D", [open, high, low, close])
```

Here, the `o`, `h`, `l`, and `c` variables return the `open`, `high`,
`low`, and `close`, respectively. This approach simplifies the script
and enhances efficiency by fetching multiple values in one operation.

#### Arrays 

An array is a data structure that stores a collection of items at
contiguous memory locations, allowing for efficient access to elements
by their index. Arrays are used to store multiple values of the same
type in a single variable. Think of an array as a grocery list, where
each item on your list corresponds to an element in the array. The
position of each item on the list (first, second, third, etc.) is like
the index in an array, helping you identify and access your groceries
quickly as you shop. In Pine Script™,
[arrays](/pine-script-docs/language/arrays) can be created with
either the [array.new\<type\>()
\<https://www.tradingview.com/pine-script-reference/v5/#fun_array.new%3Ctype%3E\>]\_\_
or
[array.from()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.from)
function. In our simple example, we store the last 5 close prices in an
array and display it in a table:

``` pine
//@version=5
indicator("array example")
// Declare an array with 5 `na` values on the first bar.
var array<float> pricesArray = array.new<float>(5)
// on each bar store a new close value and remove the oldest.
array.push(pricesArray, close)
array.shift(pricesArray)
// Display the array and its contents in a table.
var table displayTable = table.new(position.middle_center, 1, 1)
if barstate.islast
    table.cell(displayTable, 0, 0, str.tostring(pricesArray), text_color = chart.fg_color)
```

See the [Arrays](/pine-script-docs/language/arrays) section in
the User Manual for detailed usage information.

#### Matrices 

[Matrices](/pine-script-docs/language/matrices) in Pine Script™
are structured collections that organize data in a rectangular grid,
similar to items in a spreadsheet laid out in rows and columns. They
function as two-dimensional arrays, enabling the storage of value
references where all elements within the matrix must share the same
[type](/pine-script-docs/language/type-system#types), whether
it\'s a [built-in](/pine-script-docs/language/type-system#qualifiers) or `user-defined
type <PageTypeSystem_UserDefinedTypes>`.
This structure allows for efficient organization, manipulation, and
analysis of data. Matrices come equipped with various functions and
methods designed for inspecting and modifying data, as well as
performing `specialized
calculations <PageMatrices_MatrixCalculations>`. These capabilities are particularly valuable for modeling
complex systems, solving mathematical problems, and improving algorithm
performance through the use of matrix operations, especially in
scenarios demanding intensive computational resources.

This script demonstrates a simple example of matrix addition in Pine. It
creates a 3x3 matrix, calculates its
[transpose](/pine-script-docs/language/matrices#transposing), then calculates the
[matrix.sum()](https://www.tradingview.com/pine-script-reference/v5/#fun_matrix.sum)
of the two matrices. This example displays the original matrix, its
[transpose](https://www.tradingview.com/pine-script-reference/v5/#fun_matrix.transpose),
and the resulting sum matrix in a table on the chart:

![image](@assets/images/Data-structures-What-are-the-primary-data-structues-available-in-the-pine-script-1.png)

``` pine
//@version=5
indicator("Matrix sum example")

//@variable A 3x3 matrix.
m = matrix.new<float>()

// Add rows to `m`.
m.add_row(0, array.from(1, 2, 3))
m.add_row(1, array.from(0, 4, 2))
m.add_row(2, array.from(3, 1, 2))

var table displayTable = table.new(position.middle_center, 5, 2)
if barstate.islast
    matrix<float> t = m.transpose()
    table.cell(displayTable, 0, 0, "A",                            text_color = chart.fg_color)
    table.cell(displayTable, 0, 1, str.tostring(m),                text_color = chart.fg_color)
    table.cell(displayTable, 1, 1, "+",                            text_color = chart.fg_color)
    table.cell(displayTable, 2, 0, "Aᵀ",                           text_color = chart.fg_color)
    table.cell(displayTable, 2, 1, str.tostring(t),                text_color = chart.fg_color)
    table.cell(displayTable, 3, 1, "=",                            text_color = chart.fg_color)
    table.cell(displayTable, 4, 0, "A + Aᵀ",                       text_color = color.green)
    table.cell(displayTable, 4, 1, str.tostring(matrix.sum(m, t)), text_color = color.green)
```

See the [Matrices](/pine-script-docs/language/matrices) section
in the User Manual for detailed usage information.

#### Objects 

[Objects](/pine-script-docs/language/objects) in Pine Script™
serve as containers for grouping together fields under a single
variable, where each field can hold a value of a specific type. These
[user-defined types](/pine-script-docs/language/type-system#user-defined-types) (UDTs) are similar to structs in traditional programming
languages, allowing for the creation of complex data structures that
encapsulate multiple pieces of data into a single logical unit. UDTs are
composite types; they contain an arbitrary number of fields that can be
of any type, including other UDTs. Think of objects like backpacks for a
hike: each backpack (object) can carry items (fields) like a water
bottle, map, and snacks, each with its own place and purpose, helping
you organize and access what you need for the journey.

To create objects in Pine, you first need to use the
[type](https://www.tradingview.com/pine-script-reference/v5/#kw_type)
keyword to define the UDT\'s fields, then use the UDT's `new()` built-in
method to create a new object. In our example script, we create a new
`pivot` object each time a new pivot is found and draw a label using
each of the object\'s fields:

``` pine
//@version=5
indicator("Object demo", overlay = true)

// Create the pivot type with 3 fields. One for the x coordinate, one for the y coordinate, and one for a formatted time string.
type pivot
    int x
    float y
    string pivotTime
// Check for new pivots.
float pivFound = ta.pivothigh(10, 10)
// When a pivot is found, create a new pivot object and generate a label using the values from its fields.
if not na(pivFound)
    pivot pivotObject = pivot.new(bar_index - 10, pivFound, str.format_time(time[10], "yyyy-MM-dd HH:mm"))
    label.new(pivotObject.x, pivotObject.y, pivotObject.pivotTime, textcolor = chart.fg_color)
```

Here, an object type named `pivot` is defined with three fields: `x` for
the x-coordinate (representing the
[bar_index](https://www.tradingview.com/pine-script-reference/v5/#var_bar_index)
where the pivot occurs), `y` for the y-coordinate (indicating the pivot
price), and `pivotTime` for storing the
[time](https://www.tradingview.com/pine-script-reference/v5/#var_time)
of the bar the pivot occurred as a [formatted time
string](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Time.html#formatting-dates-and-time).

See our User Manual's page on [Objects](/pine-script-docs/language/objects) to learn more about working with UDTs.

#### Maps 

[Maps](https://www.tradingview.com/pine-script-docs/en/v5/language/Maps.html#maps)
in Pine Script™ are similar to dictionaries found in other programming
languages, such as Python\'s dictionaries, JavaScript\'s objects, or
Java\'s HashMaps. These data structures allow for the storage of
elements as key-value pairs, where each unique key acts as an identifier
to its corresponding value. This enables efficient data retrieval,
modification, and storage by leveraging the key to directly access its
associated value.

Similar to dictionaries, maps in Pine Script™ offer a means of
organizing data in a way that is both accessible and efficient. They are
particularly useful in scenarios where relationships between distinct
pieces of data need to be established and quickly accessed without the
linear search required arrays. This makes maps ideal for associating
specific attributes with symbols, dates with events, or any other form
of data where direct access through a unique identifier significantly
enhances the script\'s performance and simplicity. Think of a map in
Pine Script™ like a well-organized file cabinet, where each file in a
drawer (key) is labeled for specific documents (values). Just as you can
quickly find a document by looking for the file name, a map allows you
to efficiently retrieve data using its unique key, simplifying data
management in your script.

Consider the following Pine Script™ example, which illustrates the
practical application of maps for managing earnings dates and values as
key-value pairs, with dates serving as the keys:

![image](@assets/images/Data-structures-What-are-the-primary-data-structues-available-in-the-pine-script-2.png)

``` pine
//@version=5
indicator("Earnings map", overlay = true)
// Get earnings value on each bar the data is provided, otherwise, return `na`. We use "gaps on" to return `na` unless earnings occurred.
float earnings = request.earnings(syminfo.tickerid, earnings.actual, barmerge.gaps_on)
// Declare a map object for storing earnings dates and values.
var map<string, float> earningsMap = map.new<string, float>()
// Check if `request.security()` returns data. If so, add an entry to the map with the date as the key and earnings as the value.
if not na(earnings)
    map.put(earningsMap, str.format_time(time, "yyyy-MM-dd"), earnings)
// On the last historical bar, loop the map in the insertion order, writing the key-value pairs to the logs.
if barstate.islastconfirmedhistory
    string tableText = "\n"
    for [key, value] in earningsMap
        tableText += str.format("{0}: {1}\n", key, value)
    log.info(tableText)
```

Here, we use
[request.earnings()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.earnings)
with the barmerge parameter set to
[barmerge.gaps_on](https://www.tradingview.com/pine-script-reference/v5/#const_barmerge.gaps_on)
to return the earnings value on bars where earnings data is available,
otherwise it returns
[na](https://www.tradingview.com/pine-script-reference/v5/#fun_na).
Non-na values are then added to the map, associating the dates earnings
occurred with earnings numbers. Finally, on the last historical bar, the
script [loops the map](/pine-script-docs/language/maps#looping-through-amap), logging each key-value pair to display the map\'s contents.

To learn more about working with maps, please refer to the
[Maps](/pine-script-docs/language/maps) section in the Pine
Script™ User Manual.

### What is a series, and how does it differ from an array in Pine Script™? 

In Pine Script™, the concepts of \"series\" and \"array\" represent two
distinct types of data structures designed to store multiple values, but
they serve different purposes and are utilized in unique ways. Unlike in
many programming languages where arrays are the primary method for
storing collections of values, Pine Script™ differentiates sharply
between *arrays* and a *series*. Newcomers to Pine often mistakenly
implement arrays when not needed, overlooking that its series-based
[execution model](/pine-script-docs/language/execution-model) is
frequently sufficient for most analytical tasks and far more efficient.
The concept of [time series](/pine-script-docs/language/time-series) is a fundamental aspect of Pine Script\'s design, deeply
integrated into its execution model to efficiently handle sequences of
temporal data. Understanding the nuanced roles of these data structures
is essential for leveraging Pine Script\'s full analytical capabilities.

#### What is a Series in Pine Script™? 

In Pine Script™, a series refers to a data structure that represents a
sequence of data points over time. It is the primary way of handling and
manipulating time-series data, such as prices, volumes, or indicator
values, within a script. Each element in a series is automatically
indexed by its corresponding bar on the chart. This allows for
historical referencing of values using the
[[] history-referencing operator](/pine-script-docs/language/operators#history-referencing-operator), enabling the script to access past values of a series by
specifying the number of bars back.

Characteristics of a time series in Pine Script™ include:

-   **Time-indexed:** Every data point in a series is linked to a
    specific time or bar on the chart.
-   Dynamic: Series values can change from bar to bar and throughout the
    formation of a realtime bar, reflecting the latest data points.
-   **Immutable:** Although series values are *dynamic*, historical
    values of a series cannot be changed. Once a bar has elapsed, the
    values of the series for that bar are set and cannot be altered.
    Just as you cannot change the past, you cannot change past values in
    a series. This immutability ensures the integrity of historical
    data, preventing retroactive changes.
-   **Mandatory implementation:** In contrast to arrays, which are
    optional and can be used at the discretion of the script writer,
    series data is a foundational element that is automatically
    implemented in all script variables. This means every element in a
    series is indexed by its corresponding bar on the chart, allowing
    access to historical values.

#### What is an Array in Pine Script™? 

Introduced in later versions of Pine Script™ (starting from version 4),
an [array](/pine-script-docs/language/arrays) represents a more
traditional data structure similar to arrays in other programming
languages. Arrays in Pine Script™ are containers that can store a
collection of values of the same type. Unlike series, arrays are not
automatically indexed by time. They offer more flexibility in terms of
manual indexing and manipulation of stored values.

Characteristics of an array in Pine Script include:

-   **Manually indexed:** The programmer can access and modify elements
    in an array using manual indices, without the automatic time-based
    indexing present in series.
-   **Mutable:** Arrays can have their size changed dynamically by
    implementing functions that
    [insert or remove elements](/pine-script-docs/language/arrays#inserting-and-removing-array-elements). Any value in an array can also be altered using the
    [array.set()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.set)
    function.
-   **Versatility:** Arrays can be used for a variety of purposes, such
    as storing a fixed set of values, storing and manipulating objects
    for visual display, handling data that doesn\'t fit the time series
    model, or implementing complex data structures and algorithms. They
    can also mimic series through the creation of custom datasets, an
    approach exemplified by the
    [getSeries](https://www.tradingview.com/script/Bn7QkdZR-getSeries/)
    library.

**Key Differences**

-   Series are automatically indexed by the Pine runtime based on the
    chart\'s bars, making them inherently time-based. Arrays require
    manual indexing and manipulation by the programmer, offering a more
    hands-on approach to data organization and access.
-   Series in Pine Script™ expand dynamically with each successive bar
    in the dataset during script execution. Unlike series, arrays can be
    of constant or variable sizes and their contents or indexing
    structure remain unaffected by the runtime environment. Instead,
    changes to arrays are made through specific array manipulation
    functions and techniques.
-   The Pine Script™
    [execution model](/pine-script-docs/language/execution-model)
    outlines how scripts are processed bar by bar, essentially removing
    the need to manually iterate over a dataset. This built-in behavior
    mimics looping, allowing a series to track values, accumulate
    totals, or perform calculations across a sequence of data on each
    bar. In contrast, using arrays for similar tasks requires manually
    managing a dataset, including its size, and employing loops to
    process the array\'s contents, which can be far less efficient.

In Pine Script™, embracing its native approach to handling time-series
data is essential for effective scripting. Pine inherently treats all
variables as part of a time-indexed series, simplifying the analysis of
temporal data by processing scripts on a bar-by-bar basis. By adopting
this time-series-centric mindset, developers can maximize script
efficiency, reserving the use of arrays for specific scenarios where
manual data manipulation or non-time-indexed storage is necessary.
Understanding and utilizing Pine Script\'s unique design encourages
effective, purpose-built code for financial applications, distinguishing
it from general-purpose programming languages like Python.

### How do I create and use arrays in Pine Script™? 

Pine Script™ [Arrays](/pine-script-docs/language/arrays) are
one-dimensional collections that can hold multiple value references.
Imagine an array as a row of mailboxes in an apartment building. Each
mailbox is assigned a unique number, which helps residents and the mail
carrier know where to find or place each resident\'s mail. In this
analogy, the mailboxes represent the elements in the array, and the
unique numbers are akin to the indexes used to access these elements.
Just as each mailbox can hold letters or packages (data), each element
in an array can store a value. And just as you would go to a specific
mailbox number to retrieve your mail, you would access an element in an
array using its index to get the value stored there.

**Declaring arrays**

When declaring an array, use one of the following functions:
[array.new\<type\>(size, initial_value)
\<https://www.tradingview.com/pine-script-reference/v5/#fun_array.new%3Ctype%3E\>]\_\_,
[array.from()](https://www.tradingview.com/pine-script-reference/v5/#fun_array%7Bdot%7Dfrom),
or
[array.copy()](https://www.tradingview.com/pine-script-reference/v5/#fun_array%7Bdot%7Dcopy).
Arrays can be declared with or without the
[var](/pine-script-docs/language/variable-declarations#var)
keyword to either have their values persist from bar to bar, or
initialize fresh on each bar:

``` pine
prices1     = array.new<float>() // Declares a new empty array on each bar
var prices2 = array.new<float>() // Declares an empty array on the first bar only. Its attributes are retained from bar to bar.
```

-   **Persistent arrays:** Declaring an array with `var` retains its
    values across bars, allowing for cumulative data tracking. For
    instance, storing a running list of trade entry prices for analysis.
-   **Non-persistent arrays:** Arrays declared without `var` are reset
    every bar, useful for calculations specific only to the current
    bar\'s data.

See more on the differences between declaring arrays with or without var
[here](/pine-script-docs/faq#whats-the-difference-between-an-array-declared-with-var-or-without-var).

**Manipulating the size of an array**

Pine Script™ provides several functions for dynamically adjusting the
size and contents of arrays, including adding or removing elements. This
flexibility supports various data management strategies, such as FIFO
[queues](/pine-script-docs/language/arrays#using-an-array-as-aqueue) or LIFO
[stacks](/pine-script-docs/language/arrays#using-an-array-as-astack), useful for custom datasets or sliding window calculations.

-   **Adding elements:**
    -   [array.unshift()](https://www.tradingview.com/pine-script-reference/v5/#fun_array%7Bdot%7Dunshift)
        inserts a new element at the beginning of an array (index 0) and
        increases the index values of any existing elements by one.
    -   [array.insert()](https://www.tradingview.com/pine-script-reference/v5/#fun_array%7Bdot%7Dinsert)
        inserts a new element at the specified `index` and increases the
        index of existing elements at or after the `index` by one.
    -   [array.push()](https://www.tradingview.com/pine-script-reference/v5/#fun_array%7Bdot%7Dpush)
        adds a new element at the end of an array.
-   **Removing elements:**
    -   [array.remove()](https://www.tradingview.com/pine-script-reference/v5/#fun_array%7Bdot%7Dremove)
        removes the element at the specified `index` and returns that
        element's value.
    -   [array.shift()](https://www.tradingview.com/pine-script-reference/v5/#fun_array%7Bdot%7Dshift)
        removes the first element from an array and returns its value.
    -   [array.pop()](https://www.tradingview.com/pine-script-reference/v5/#fun_array%7Bdot%7Dpop)
        removes the last element of an array and returns its value.
    -   [array.clear()](https://www.tradingview.com/pine-script-reference/v5/#fun_array%7Bdot%7Dclear)
        removes all elements from an array. Note that clearing an array
        won't delete any objects its elements referenced.

Read more about implementing a stack or queue in
[this FAQ entry](/pine-script-docs/faq#what-does-queue-stack-mean).

**Calculations on arrays**

Due to arrays being non-[time series](/pine-script-docs/language/time-series) data structures, performing operations across an array\'s
elements requires special functions designed for arrays. These functions
enable computations like finding the maximum, minimum, or average values
within an array, crucial for analytical tasks. See the
[Calculation on arrays](/pine-script-docs/language/arrays#calculations-on-arrays) section for more information.

**Script example**

In the provided script example, we demonstrate a practical application
of arrays by tracking the last five session open prices. We plot the
highest, lowest, and average open prices to the chart:

![image](@assets/images/Data-structures-How-do-i-create-and-use-arrays-in-pine-script-1.png)

``` pine
//@version=5
indicator("Array demo", overlay = true)
// Create an input to determine the number of session opens to track, with a default value of 5.
int numOpensInput = input.int(5, "Number of opens to track")
// Initialize an array to store open prices. Using `var` ensures the array retains its values from bar to bar.
// Initially, the array is filled with placeholder values (`na`), which will be updated with actual open prices.
var array<float> opensArray = array.new<float>(numOpensInput)
// On the first bar of each session, update the array: add the current open price and remove the oldest entry.
if session.isfirstbar_regular
    array.push(opensArray, open)
    array.shift(opensArray)
// Plot the highest, lowest, and average open prices from the tracked sessions
plot(array.max(opensArray), "Highest open in n sessions",       color.lime)
plot(array.min(opensArray), "Lowest open in n sessions",        color.fuchsia)
plot(array.avg(opensArray), "Avg. open of the last n sessions", color.gray)
// Change the background color on the first bar of each session to visually indicate session starts.
bgcolor(session.isfirstbar_regular ? color.new(color.gray, 80) : na)
```

**In our script we:**

-   Declare a float array using the
    [var](/pine-script-docs/language/variable-declarations#var)
    keyword, allowing it retain its values from bar to bar.
-   Provide a user input to determine the array\'s size, which controls
    how many of the latest session opens we track.
-   At the start of each session, we update the array by adding the new
    open price and removing the oldest one. This process, resembling a
    [queue](/pine-script-docs/language/arrays#using-an-array-as-aqueue), keeps the array\'s size constant while maintaining a
    moving window of the session opens for the last 5 days.
-   Utilize special-purpose array functions to perform
    [calculations on the array](/pine-script-docs/language/arrays#calculations-on-arrays), which yield three key values: the highest open, the
    lowest open, and the average open price over the last 5 sessions.
    These values are then plotted.
-   Visually distinguish the start of each session by highlighting the
    background, signaling the bars where the array is manipulated.

**Additional information**

-   For those looking to delve deeper into arrays and their applications
    within Pine Script™, the Pine Script `User
    Manual <PageArrays>` offers
    comprehensive guidance and examples.
-   For answers to commonly asked questions about arrays, refer to the
    Data Structures section in the Pine Script FAQ.
-   For a practical example of managing lines within an array, refer to
    the support and resistance script example found in
    [this FAQ entry](/pine-script-docs/faq#how-do-iplot-asupport-or-atrend-line).

### What\'s the difference between an array declared with var or without var? 

In Pine Script™, the
[var](https://www.tradingview.com/pine-script-reference/v5/#op_var)
keyword allows users to declare an
[array](/pine-script-docs/language/arrays) variable in a script
that is initialized only once, during the first iteration on the first
chart bar. When an array is declared with `var`, it points to the same
array instance across different bars, ensuring that the array and its
elements retain their values from one bar to the next. This persistence
allows the array\'s state to be maintained throughout the script\'s
execution. In contrast, if an array is declared without `var`, it is
reinitialized on every bar, meaning its state and values do not persist
from one bar to the next.

Persistent vs. non-persistent arrays

-   **Persistent arrays (Declared with var):** When an array is declared
    with `var`, it is initialized only once, at the first execution of
    the script. This allows the array to retain its contents and grow in
    size across bars, making it ideal for cumulative data collection or
    tracking values over time.
-   **Non-persistent arrays (Declared without var):** Arrays declared
    without `var` are reinitialized on every new bar, effectively
    resetting their content. This behavior suits scenarios where
    calculations are specific to the current bar, and historical data
    retention is unnecessary.

In our script example, we initialize two arrays, named `a` and `b`.
Array `a` is declared without using the `var` keyword, while array `b`
is declared with `var`, allowing us to observe and compare their
behaviors. Throughout the runtime, we incrementally add an element to
each array on each bar. We use a [table](/pine-script-docs/concepts/tables) to present and compare both the sizes of these arrays and
the number of chart bars, effectively illustrating the impact of
different declaration methods on array behavior:

``` pine
//@version=5
indicator("Using `var` with arrays")
//@variable An array that initializes on every bar.
a = array.new<float>()
array.push(a, close)
//@variable An array that expands its size by 1 on each bar.
var b = array.new<float>(0)
array.push(b, close)
// Populate a table on the chart's last bar to display the sizes of the arrays and compare it to the number of chart bars.
if barstate.islast
    var table displayTable = table.new(position.middle_right, 2, 3)
    table.cell(displayTable, 0, 0, "Array A size:",             text_color = chart.fg_color, text_halign = text.align_right)
    table.cell(displayTable, 1, 0, str.tostring(a.size()),      text_color = chart.fg_color, text_halign = text.align_left)
    table.cell(displayTable, 0, 1, "Array B size:",             text_color = chart.fg_color, text_halign = text.align_right)
    table.cell(displayTable, 1, 1, str.tostring(b.size()),      text_color = chart.fg_color, text_halign = text.align_left)
    table.cell(displayTable, 0, 2, "Number of chart bars:",     text_color = chart.fg_color, text_halign = text.align_right)
    table.cell(displayTable, 1, 2, str.tostring(bar_index + 1), text_color = chart.fg_color, text_halign = text.align_left)
```

The example provided demonstrates the behavioral differences between
persistent and non-persistent arrays through a simple comparison:

-   **Array A (Non-Persistent):** Declared without `var`, this array is
    reset at the beginning of each new bar. As a result, despite adding
    elements on each bar, its size remains constant, reflecting the most
    recent addition.
-   **Array B (Persistent):** Declared with `var`, this array retains
    its elements and accumulates new entries across bars, mirroring the
    growing count of chart bars. This persistent nature of the array
    showcases its ability to track or aggregate data over the script\'s
    runtime.

For further details, consult the sections concerning variable
[declaration modes](/pine-script-docs/language/variable-declarations#declaration-modes) and their use in
[array declarations](/pine-script-docs/language/arrays#using-var-and-varip-keywords) in the Pine Script™ User Manual.

### What does queue/stack mean? 

In Pine Script™, as in many programming languages,
[arrays](/pine-script-docs/language/arrays) can be used to
implement data structures such as
[queues](/pine-script-docs/language/arrays#using-an-array-as-aqueue) and
[stacks](/pine-script-docs/language/arrays#using-an-array-as-astack). These concepts are useful for managing collections of data
in a structured manner. Here\'s a breakdown of each term with analogies
to help clarify:

-   **Stack:** Consider a stack of plates as an analogy for
    understanding the \"last-in, first-out\" (LIFO) principle, where you
    can only place a new plate on top or remove the top plate. This
    principle dictates that the most recently added item is the first to
    be taken away. Similarly, in Pine Script™, an array can function as
    a stack. This is achieved by adding elements to and removing them
    from the same end of the array, ensuring that the newest elements
    are accessed first and the oldest last. To implement this, you can
    use the combination of
    [array.push()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.push)
    and
    [array.pop()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.pop)
    for adding to and removing from the end of the array, respectively,
    or
    [array.unshift()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.unshift)
    and
    [array.shift()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.shift)
    for operations at the beginning of the array.
-   **Queue:** Visualize a queue at a coffee shop, where the arrangement
    of people waiting to order embodies the \"first-in, first-out\"
    (FIFO) principle. This principle ensures that the first person to
    join the line is the first to be served and leave. Similarly, in
    Pine Script™, you can use an array to represent a queue by
    manipulating elements in a way that they are added and removed
    sequentially, maintaining the FIFO order. This is done by adding
    elements to one end of the array and removing them from the opposite
    end. To implement this sequential flow, you can use the combination
    of
    [array.push()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.push)
    and
    [array.shift()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.shift)
    for adding elements to the end and removing from the beginning,
    respectively, or
    [array.unshift()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.unshift)
    and
    [array.pop()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.pop)
    to add elements to the beginning and remove from the end. The
    underlying concept here is that elements are processed in the order
    they are added, moving through the array from one side to the other.

Both *stacks* and *queues* offer unique advantages in managing data.
Stacks are particularly useful for scenarios requiring immediate access
to the most recent data, such as tracking price levels, while queues are
essential for sequential data processing tasks, like event handling or
executing operations in the order they were received. Below, we provide
two script examples to showcase either method.

**Script 1: Stack Implementation with Arrays**

In our first script example, we demonstrate an array-based stack
implementation to manage pivot points in a line tracking scenario. The
objective is to draw [lines](/pine-script-docs/concepts/lines-and-boxes#lines) from pivot points and extend these lines with each new bar
until the price action intersects them. Upon detecting a pivot point, a
new line is added (pushed) to the stack. As new bars appear, the script
extends the endpoint of each line in the stack. It then checks, starting
from the most recently added line, whether price action has intersected
any of the lines. If an intersection is found, the script removes (pops)
the intersected line from the stack, meaning it will no longer be
extended with new bars:

![image](@assets/images/Data-structures-What-does-queue-stack-mean-1.png)

``` pine
//@version=5
indicator("Array as a stack", overlay = true)

int PIVOT_LEGS = 20

// @function                Adds a new horizontal line to an array of lines at a specified pivot level.
// @param id                (array<line>) The array to which the new line will be added.
// @param pivot             (float) The price level at which the horizontal line should be drawn.
// @param lineColor         (color) The color of the line to be drawn.
// @returns                 (void) The function has no explicit return.
stackLine(array<line> id, float pivot, color lineColor) =>
    if not na(pivot)
        array.push(id, line.new(bar_index - PIVOT_LEGS, pivot, bar_index, pivot, color = lineColor))

// @function                Extends the endpoint (`x2`) of each line in an array to the current `bar_index`.
// @param id                (array<line>) The array containing the line objects to be updated.
// @returns                 (void) The function has no explicit return.
extendLines(array<line> id) =>
    for eachLine in id
        eachLine.set_x2(bar_index)

// @function                Removes line objects from an array if they are above or below the high or low price of the current bar.
// @param id                (array<line>) The array from which line objects will be removed.
// @param isBull            (bool) The condition to determine removal: if true, lines below the high price are removed (bullish scenario);
//                          if false, lines above the low price are removed (bearish scenario).
// @returns                 (void) The function has no explicit return.
removeLines(array<line> id, bool isBull) =>
    if array.size(id) > 0
        for i = array.size(id) - 1 to 0
            float linePrice = line.get_price(array.get(id, i), bar_index)
            if isBull ? high > linePrice : low < linePrice
                array.pop(id)
            else
                break
                line(na)

// Find the pivot high and pivot low price.
float pivotLo = ta.pivotlow(PIVOT_LEGS,  PIVOT_LEGS)
float pivotHi = ta.pivothigh(PIVOT_LEGS, PIVOT_LEGS)

// Init 2 arrays on the first bar to stack our lines in.
var array<line> pivotHiArray = array.new<line>()
var array<line> pivotLoArray = array.new<line>()

// Search for pivots and draw a line from the pivot to the current bar when found and add it to the stack.
stackLine(pivotHiArray, pivotHi, color.orange)
stackLine(pivotLoArray, pivotLo, color.aqua)

// Extend all lines in each array to the current bar on each bar.
extendLines(pivotHiArray)
extendLines(pivotLoArray)

// Cycle backward through the array checking if the high breached the pivot high lines, or the low breached the pivot low lines.
// Pop lines off the stack if they have been breached.
removeLines(pivotHiArray, true)
removeLines(pivotLoArray, false)
```

**Script 2: Queue implementation with arrays**

This script showcases a queue-based array implementation to track pivot
points for monitoring recent support and resistance levels. The aim is
to dynamically update
[lines](/pine-script-docs/concepts/lines-and-boxes#lines)
extending from the four most recent pivot highs and lows to the current
bar with each new bar, providing a visual representation of current
market dynamics. When a new pivot high or low is identified, a line
representing this pivot is added to the respective queue. To maintain
the queue\'s size at a constant four items, the oldest line in the queue
is removed whenever a new line is added. This process ensures that the
system continuously tracks only the four latest pivot points, offering
an up-to-date perspective on support and resistance levels:

![image](@assets/images/Data-structures-What-does-queue-stack-mean-2.png)

``` pine
//@version=5
indicator("Array as a stack", overlay = true)

int PIVOT_LEGS = 20

int numLinesInput = input.int(4, "Number of lines to track")

// @function            Queues a new `arrayElement` at the end of the `id` array and de-queues
//                      the first element if the array size exceeds the specified `maxSize`.
// @param id            (<any array type>) The array in which the element is to be queued.
// @param maxSize       (int) The maximum allowed number of elements in the array.
//                      If the array size exceeds this, the first element is de-queued.
// @param arrayElement  (<type of the array's elements>) The new element to be added to the array.
// @returns             (<type of the array's elements>) The de-queued element.
arrayQueue(id, int maxSize, value) =>
    id.push(value)
    if id.size() > maxSize
        id.shift()

// @function                Adds a new horizontal line to an array of lines at a specified pivot level and removes the oldest line.
// @param id                (array<line>) The array to which the new line will be added.
// @param pivot             (float) The price level at which the horizontal line should be drawn.
// @param numLines          (int) The number of lines to keep in the queue.
// @param lineColor         (color) The color of the line to be drawn.
// @returns                 (void) The function has no explicit return.
queueLine(array<line> id, float pivot, int numLines, color lineColor) =>
    if not na(pivot)
        arrayQueue(id, numLines, line.new(bar_index - PIVOT_LEGS, pivot, bar_index, pivot, color = lineColor))

// @function                Extends the endpoint (`x2`) of each line in an array to the current `bar_index`.
// @param id                (array<line>) The array containing the line objects to be updated.
// @returns                 (void) The function has no explicit return.
extendLines(array<line> id) =>
    for eachLine in id
        eachLine.set_x2(bar_index)

// Find the pivot high and pivot low price.
float pivotLo = ta.pivotlow(PIVOT_LEGS,  PIVOT_LEGS)
float pivotHi = ta.pivothigh(PIVOT_LEGS, PIVOT_LEGS)

// Init 2 arrays on the first bar to queue our lines in.
var array<line> pivotHiArray = array.new<line>()
var array<line> pivotLoArray = array.new<line>()

// Search for pivots and add a line to the queue drawn from the pivot to the current bar when found and remove the oldest line.
queueLine(pivotHiArray, pivotHi, numLinesInput, color.orange)
queueLine(pivotLoArray, pivotLo, numLinesInput, color.aqua)

// Extend all lines in each array to the current bar on each bar.
extendLines(pivotHiArray)
extendLines(pivotLoArray)
```

For more information on manipulating arrays, see the
[Arrays](/pine-script-docs/language/arrays) section in the Pine
Script™ User Manual.

### Can I use matrices or multidimensional arrays in Pine Script™? 

Pine Script™ does not directly support multidimensional arrays; however,
it provides [matrices](/pine-script-docs/language/matrices) and
`user-defined
types <PageTypeSystem_UserDefinedTypes>`
(UDTs) as alternative mechanisms to structure and manipulate complex
datasets. By leveraging these constructs, developers can implement
advanced data structures akin to those found in more traditional
programming languages, thus enabling more sophisticated modeling and
analysis of financial scenarios within Pine Script™.

Matrices in Pine Script™

-   **Introduction of matrices:** Pine Script™ now supports
    [matrices](/pine-script-docs/language/matrices), which are
    akin to two-dimensional arrays. This addition allows for a more
    sophisticated data organization and manipulation comparative to one
    dimensional arrays, catering to complex mathematical and statistical
    computation.
-   **Structure and usage:** Matrices organize data in a rectangular
    grid, facilitating operations like matrix arithmetic,
    transformations, and other complex calculations. They are
    particularly useful for quantitative modeling, such as portfolio
    optimization, correlation matrix analysis, and more.
-   **Type uniformity:** Similar to
    [arrays](/pine-script-docs/language/arrays), all elements
    within a matrix must be of the same
    [type](/pine-script-docs/language/type-system#types), which
    can be a [built-in](/pine-script-docs/language/type-system#qualifiers) or a
    [user-defined type](/pine-script-docs/language/type-system#user-defined-types). This constraint ensures data consistency and
    reliability during matrix operations.
-   **Functions and methods:** Pine Script™ provides a range of
    functions and methods specifically designed for matrix
    [manipulation](/pine-script-docs/language/matrices#manipulating-amatrix) and
    [calculations](/pine-script-docs/language/matrices#matrix-calculations), including matrix addition, subtraction, multiplication,
    and more. These tools are useful for performing linear algebra
    operations within your scripts.

Workarounds for multidimensional arrays

-   **Using UDTs for multidimensional structures:** While Pine Script™
    does not support multidimensional arrays directly, you can achieve
    similar functionality through
    [user-defined types](/pine-script-docs/language/type-system#user-defined-types) (UDTs). UDTs allow for the creation of complex data
    structures by defining custom types with multiple fields, which can
    include arrays.
-   **Array of arrays via UDTs:** For scenarios requiring
    multidimensional array capabilities, one can define a UDT that
    includes an array as one of its fields. This approach enables you to
    create an array of UDTs, effectively mimicking the behavior of a
    multidimensional array.

For detailed guidance on implementing data structures in Pine Script™,
refer to the sections on [Matrices](/pine-script-docs/language/matrices),
[Maps](/pine-script-docs/language/maps), and
[Objects](/pine-script-docs/language/objects) in the Pine
Script™ User Manual.

### How can I perform operations on all elements in an array? 

One of the primary purposes for aggregating elements into an
[array](/pine-script-docs/language/arrays) is to enable their
collective management, analysis, or manipulation as a group. However, in
Pine Script™, there are no built-in functions to apply operations across
the entire array at once. Therefore, to manipulate all elements, it is
necessary to iterate through the array, performing the operation on each
element one at a time. While this allows elements to be managed
collectively, operations must be carried out individually on each
element.

**Iterating Over Arrays**

The primary method to operate on each element in an array is by using a
[for\...in](https://www.tradingview.com/pine-script-reference/v5/#kw_for...in)
structure, which allows for sequential access to each element without
the need for specifying the number of iterations. Pine Script™ provides
two forms of the `for...in` structure:

-   **Single argument form:** Utilizes the format
    `for element in array`, where `element` represents the current array
    element being accessed. This form is suited for operations that do
    not require knowledge of the element\'s index within the array.
-   **Two-argument form:** Utilizes the format
    `for [index, element] in array`, providing both the current element
    and its index in a [tuple](/pine-script-docs/language/type-system#tuples). This variant is useful for operations where the
    position of the element within the array is significant, such as
    when working with tandem arrays or when the index itself influences
    the operation.

In our first script example, we implement an array as a
[queue](/pine-script-docs/language/arrays#using-an-array-as-aqueue) to monitor the four latest pivot highs and lows, using
[lines](/pine-script-docs/concepts/lines-and-boxes#lines) to
represent these pivot levels. The script showcases the `for...in`
structure in a single argument context to perform two main tasks:

-   **Update line coordinates:** we create a custom function,
    `extendLines()`, to adjust the `x2` endpoint of each line to the
    current
    [bar_index](https://www.tradingview.com/pine-script-reference/v5/#var_bar_index),
    ensuring all lines are extended to the latest bar. This function
    iterates through the line arrays to update the endpoint of each line
    on each bar.
-   **Set line colors:** Utilize another custom function,
    `colorLines()`, to visually differentiate lines as either support
    (blue) or resistance (orange) based on their position relative to
    the
    [close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
    price. Lines below the close price are set to
    [aqua](https://www.tradingview.com/pine-script-reference/v5/#const_color.aqua)
    to indicate support, and those above are set to
    [orange](https://www.tradingview.com/pine-script-reference/v5/#const_color.orange)
    to indicate resistance.

Both operations rely on the `for...in` structure to access and modify
each line\'s coordinates and color, updating line attributes as the
script runs on each bar:

![image](@assets/images/Data-structures-How-can-i-perform-operations-on-all-elements-in-an-array-1.png)

``` pine
//@version=5
indicator("Manipulate all objects in an array", overlay = true)

int PIVOT_LEGS = 20

int numLinesInput = input.int(4, "Number of lines to track")

// @function            Queues a new `arrayElement` at the end of the `id` array and de-queues
//                      the first element if the array size exceeds the specified `maxSize`.
// @param id            (<any array type>) The array in which the element is to be queued.
// @param maxSize       (int) The maximum allowed number of elements in the array.
//                      If the array size exceeds this, the first element is de-queued.
// @param arrayElement  (<type of the array's elements>) The new element to be added to the array.
// @returns             (<type of the array's elements>) The de-queued element.
arrayQueue(id, int maxSize, value) =>
    id.push(value)
    if id.size() > maxSize
        id.shift()

// @function                Adds a new horizontal line to an array of lines at a specified pivot level and removes the oldest line.
// @param id                (array<line>) The array to which the new line will be added.
// @param pivot             (float) The price level at which the horizontal line should be drawn.
// @param numLines          (int) The number of lines to keep in the queue.
// @param lineColor         (color) The color of the line to be drawn.
// @returns                 (void) The function has no explicit return.
queueLine(array<line> id, float pivot, int numLines, color lineColor) =>
    if not na(pivot)
        arrayQueue(id, numLines, line.new(bar_index - PIVOT_LEGS, pivot, bar_index, pivot, color = lineColor))

// @function                Extends the endpoint (`x2`) of each line in an array to the current `bar_index`.
// @param id                (array<line>) The array containing the line objects to be updated.
// @returns                 (void) The function has no explicit return.
extendLines(array<line> id) =>
    for eachLine in id
        eachLine.set_x2(bar_index)

// @function                Adjusts the color of each line in an array based on the closing price's position relative to
//                          the line's price. If `close` is above the line, the line is set to `bullColor` (support),
//                          else, `bearColor` (resistance).
// @param id                (array<line>) The array containing the line objects.
// @param bullColor         (color) The color to apply to the line if `close` is equal to or higher than the line's price.
// @param bearColor         (color) The color to apply to the line if `close` is below the line's price.
// @returns                 (void) The function has no explicit return.
colorLines(array<line> id, color bullColor, color bearColor) =>
    for eachLine in id
        if close >= eachLine.get_price(bar_index)
            eachLine.set_color(bullColor)
        else
            eachLine.set_color(bearColor)

// Find the pivot high and pivot low price.
float pivotLo = ta.pivotlow(PIVOT_LEGS,  PIVOT_LEGS)
float pivotHi = ta.pivothigh(PIVOT_LEGS, PIVOT_LEGS)

// Init 2 arrays on the first bar to queue our lines in.
var array<line> pivotHiArray = array.new<line>()
var array<line> pivotLoArray = array.new<line>()

// Search for pivots and draw a line from the pivot to the current bar when found and remove the oldest line.
queueLine(pivotHiArray, pivotHi, numLinesInput, color.orange)
queueLine(pivotLoArray, pivotLo, numLinesInput, color.aqua)

// Extend all lines in each array to the current bar on each bar.
extendLines(pivotHiArray)
extendLines(pivotLoArray)

// Set the color of lines as support or resistance by checking if the closing price is above or below the lines.
colorLines(pivotHiArray, color.aqua, color.orange)
colorLines(pivotLoArray, color.aqua, color.orange)
```

In our second script, we leverage the two-argument variant of the
`for...in` loop to simultaneously access elements and their indices in
an array. This method facilitates operations that depend on element
indices, such as managing parallel arrays or incorporating index values
into calculations. The script features an array of random integers, both
positive and negative, and pairs it with a boolean array. This boolean
array flags whether each corresponding integer in the primary array is
positive. Through the `for...in` loop, we assess each integer\'s sign,
updating the boolean array to reflect whether each integer is above
(true) or below (false) zero. This showcases simultaneous operations on
corresponding elements across two arrays:

``` pine
//@version=5
indicator("for...in")
// Create an array with random integers above and below 0.
var valuesArray = array.from(4, -8, 11, 78, -16, 34, 7, 99, 0, 55)
// Create an array that will track the positive state of each integer.
var isPos = array.new_bool(10, false)

// Iterate over the valuesArray using a for...in loop and update each corresponding element in the bool array to true if
// the value is above 0, or false if it is below 0.
for [i, eachValue] in valuesArray
    if eachValue > 0
        array.set(isPos, i, true)

// Print the bool array in a label on the last historical bar to display its contents.
if barstate.islastconfirmedhistory
    label.new(bar_index, high, str.tostring(isPos))
```

### How can I efficiently search for an element in an array? 

Searching within [arrays](/pine-script-docs/language/arrays) for
specific contents is a common requirement. While iterating through an
array using [loops](/pine-script-docs/language/loops) to check
for the presence of a value or to find its position is feasible, it is
by far not the most efficient approach. Pine Script™ provides several
[built-in](/pine-script-docs/built-in-functions)
functions that significantly enhance the efficiency of `searching
for elements within an array <PageArrays_SearchingArrays>`, aligning with more conventional search algorithms found in
other programming languages. Here are some recommendations for efficient
search techniques in Pine Script™:

1.  **Using \`array.includes()\`:** The
    [array.includes()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.includes)
    function checks whether an array contains a specific element. If the
    element is found, the function returns
    [true](https://www.tradingview.com/pine-script-reference/v5/#const_true);
    otherwise, it returns
    [false](https://www.tradingview.com/pine-script-reference/v5/#const_false).
    This method is ideal for simply verifying the existence of an
    element in the array without needing its precise index:

    ``` pine
    //@version=5
    indicator("Element Presence Check")
    array<int> values = array.from(1, 3, 5)
    int searchValue = input(3)
    bool valuePresent = array.includes(values, searchValue)
    if barstate.islast
        label.new(bar_index, low, valuePresent ? "Search value found" : "Search value not found", textcolor = color.white)
    ```

    This example checks if 3 is present in the `values` array,
    displaying either \"found\" or \"not found\" in a
    [label](/pine-script-docs/concepts/text-and-shapes#labels).

2.  **Using \`array.indexof()\`:** This function is designed to find the
    position of the first occurrence of a specific value within an
    array. If the value is found,
    [array.indexof()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.indexof)
    returns its index; otherwise, it returns -1, indicating the value is
    not present. This function is particularly useful when you need to
    determine the position of a unique value within your dataset:

    ``` pine
    //@version=5
    indicator("Find Index of Element")
    array<float> prices = array.from(100.5, 101.2, 102.8, 100.5)
    float searchValue = input(101.2)
    int indexFound = array.indexof(prices, searchValue)
    if barstate.islast
        string lblString = switch
            indexFound < 0 => "Search value: not found"
            =>                "Search value: found\n       Index: " + str.tostring(indexFound)
        label.new(bar_index, high, lblString,
             textcolor        = color.white,
             textalign        = text.align_left,
             text_font_family = font.family_monospace
         )
    ```

    This script searches for the first occurrence of `101.2` in the
    `prices` array and displays \"found\" and the value\'s index in a
    label, or \"not found\" otherwise. Note that in cases where there
    are multiple instances of the same value within the array, the
    function returns the index of its first occurrence.

3.  **Using \`array.binary_search()\`:** For arrays sorted in ascending
    order,
    [array.binary_search()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.binary_search)
    can efficiently locate the index of a specified value. If the
    element is found, the function returns its index; if not, it returns
    -1. This method is significantly faster for large,
    [sorted](/pine-script-docs/language/arrays#sorting) arrays compared to
    [array.indexof()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.indexof).

    ``` pine
    //@version=5
    indicator("Binary Search in Sorted Array")
    array<float> sortedPrices = array.from(100.5, 102.3, 98.7, 99.2)
    string orignialArrayString = str.tostring(sortedPrices)
    float searchValue = input(100.5)
    // Ensure the array is sorted; this step is crucial for binary search.
    array.sort(sortedPrices)
    string sortedArrayString = str.tostring(sortedPrices)
    int searchValueIndex = array.binary_search(sortedPrices, searchValue)
    bool valueFound = searchValueIndex >= 0
    if barstate.islast
        string lblTxt =
         str.format("Original array: {0}\n  Sorted Array: {1}\n  Search value: {2}\n   Value found: {3}\n      Position: {4}",
             orignialArrayString,
             sortedArrayString,
             searchValue,
             valueFound,
             searchValueIndex
         )
        label.new(bar_index, high, lblTxt,
             textcolor        = color.white,
             textalign        = text.align_left,
             text_font_family = font.family_monospace
         )
    ```

    This script implements a binary search to find the value `100.5`
    within an array of prices. It is important to note that the array
    must be sorted in ascending order before performing the binary
    search. The script will display the original array, the sorted
    array, the target value (100.5), and the result of the search. If
    the value is found, it will display \"found\" along with the index
    of the value. If the value is not found, it will display \"not
    found\".

:::warning[Notice!]
In situations where precision isn\'t critical, and a close approximation
is acceptable, the methods
[array.binary_search_leftmost()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.binary_search_leftmost)
and
[array.binary_search_rightmost()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.binary_search_rightmost)
provide an effective way to locate the nearest index to a given value in
sorted arrays. These methods specifically find the closest index on the
left or right side of the specified value.
:::

### How can I debug arrays? 

To optimize your understanding and troubleshooting of
[arrays](/pine-script-docs/language/arrays) within Pine Script™,
it\'s helpful to have a structured and strategic approach to debugging.
Arrays, as pivotal structures for data management, often introduce a
level of complexity that necessitates a nuanced understanding and
methodical debugging techniques. The objective of this guide is to
provide you with the necessary tools and strategies to effectively
navigate the intricacies of array debugging in Pine Script™. Below, we
touch on a suite of methods including plotting, labels, tables, and Pine
Logs, each offering unique advantages to illuminate the behavior and
contents of arrays.

#### Plotting 

To effectively inspect the contents of an array, employing `plot*()`
functions offers a straightforward approach. These functions facilitate
the graphical display of results on the chart, while also presenting
formatted numerical values within the script\'s status line, the price
scale, and the Data Window. It\'s important to note, however, that this
approach is applicable exclusively to numerical arrays composed of
[float](/pine-script-docs/language/type-system#float) or
[int](/pine-script-docs/language/type-system#int)
variables.

Here we simply populate an array with the
[open](https://www.tradingview.com/pine-script-reference/v5/#var_open),
[high](https://www.tradingview.com/pine-script-reference/v5/#var_high),
[low](https://www.tradingview.com/pine-script-reference/v5/#var_low) or
[close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
(OHLC) prices on each bar. The elements of the array are then retrieved
and supplied to the
[plot()](https://www.tradingview.com/pine-script-reference/v5/#fun_plot)
function for visualization on the chart:

``` pine
//@version=5
indicator("Plot array elements")
array<float> ohlc = array.from(open, high, low, close)
plot(ohlc.get(0), "Open",  color.red)
plot(ohlc.get(1), "High",  color.yellow)
plot(ohlc.get(2), "Low",   color.blue)
plot(ohlc.get(3), "Close", color.green)
```

This method of plotting not only simplifies the inspection of array
values from the price scale and Data Window but also enables the easy
historical review of values by scrolling through the chart. Despite its
simplicity and effectiveness for numerical arrays, this technique has
its limitations. Note that the utility of this method is constrained by
the [maximum number of plot
calls](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Plots.html#plot-count-limit)
that can be used. Additionally, the method requires a predetermined
number of plot calls to accommodate the anticipated elements within the
array. Consequently, if the size of the array being inspected varies
across bars, employing this technique can become impractical.

#### Using labels 

Instead of visually examining a script\'s historical numeric values
through plots, you can use Pine\'s
[labels](/pine-script-docs/concepts/text-and-shapes#labels) to
directly display array values on certain bars. This method is
particularly useful for presenting non-continuous data points or when
you wish to view all elements of an array simultaneously.

Although Pine labels are restricted to the chart pane, scripts can
create them within any local scope, including
[functions](/pine-script-docs/language/user-defined-functions) and
[methods](/pine-script-docs/language/methods#user-defined-methods)
(refer to the
[Debugging function](/pine-script-docs/writing/debugging#debugging-functions) section for details). Scripts can also position drawings at
any available chart location, irrespective of the current
[bar_index](https://www.tradingview.com/pine-script-reference/v5/#var_bar_index).
Additionally, labels offer the advantage of being able to display a
variety of array types, including boolean and string arrays, offering a
debugging capability that plotting cannot.

Consider the following example, where we monitor the close price at the
last four moving average (MA) crosses in a queued array and use a label
to display this array from a local scope whenever a cross occurs:

``` pine
//@version=5
indicator("array elements in a label", overlay = true)

var array<float> crossPrices = array.new<float>(4)

float fastMa = ta.ema(close, 9)
float slowMa = ta.ema(close, 21)

if ta.cross(fastMa, slowMa)
    crossPrices.push(close)
    crossPrices.shift()
    label.new(bar_index, high, str.tostring(crossPrices), textcolor = color.white)

plot(fastMa, "Fast MA", color.aqua)
plot(slowMa, "Slow MA", color.orange)
```

It\'s important to note that although
[debugging with labels](/pine-script-docs/writing/debugging#using-labels) enables the complete visualization of all elements in an
array, there is a limitation on the maximum number of labels that a
script can display, as determined by a
[set limit on labels per script](/pine-script-docs/writing/limitations#line-box-polyline-and-label-limits).

#### Using tables 

In Pine Script™, [tables](/pine-script-docs/concepts/tables) are
utilized for organizing and displaying strings in a structured format
within cells arranged in rows and columns. This method is particularly
beneficial for chart-based debugging, offering a more organized and
scalable alternative to labels. Tables allow for the display of multiple
["series"](/pine-script-docs/language/type-system#series) strings in a clear format that remains unaffected by the
chart\'s scale or the index of the bars.

In the provided example, we create 2 arrays. The first array captures
the times of the last six bars where a Golden Cross occurred, while the
second records the last eight bar indices where the Relative Strength
Index (RSI) reached new all-time highs within the chart\'s history. We
use the `whenSince()` function from the PineCoders
[getSeries](https://www.tradingview.com/script/Bn7QkdZR-getSeries/)
library to implement queued-arrays. By treating these arrays as
[queues](/pine-script-docs/language/arrays#using-an-array-as-aqueue), their size is kept manageable for display purposes, while
showcasing a useful technique to manage collections of data in a
structured manner:

``` pine
//@version=5
indicator("Debugging arrays with tables", overlay = true)

// Import the `getSeries` PineCoders lib to aid in building fixed-size arrays populated on specific conditions.
//      https://www.tradingview.com/v/Bn7QkdZR/
import PineCoders/getSeries/1 as PCgs

// Calculate MA's and create cross condition.
float ma50        = ta.sma(close,  50)
float ma200       = ta.sma(close,  200)
bool  goldenCross = ta.cross(ma50, ma200)

// Calculate the RSI and determine if it's hitting a new all time high.
float myRsi       = ta.rsi(close,  20)
bool newRsiAth    = myRsi == ta.max(myRsi)

// Create 2 arrays using the PC `whenSince()` function:
//  1 - Holds the times of the 6 bars where a golden cross occurred.
//  2 - Holds the bar indices of the last 8 bars where the RSI made a new all time high within the chart's history.
array<float> goldenCrossesTimes = PCgs.whenSince(time_close, goldenCross, length = 6)
array<float> barIndicesOfHiRSIs = PCgs.whenSince(bar_index,  newRsiAth,   length = 8)

// Plot the MAs for cross reference.
plot(ma50,  "50 MA",  color.aqua)
plot(ma200, "200 MA", color.orange)

// Display the date and time of the last crosses (executes only once on the last historical bar).
if barstate.islast
    // Declare our MA table to display the Golden Cross times. 
    var table maTable  = table.new(position.top_right, 2, 8, color.new(color.black, 100), color.gray, 1, color.gray, 1)
    // Create a title cell for the MA table and merge cells to form a banner 2 cells wide.
    table.cell(maTable , 0, 0, "Golden Cross Times", text_color = color.black, bgcolor = #FFD700)
    table.merge_cells(maTable , 0, 0, 1, 0)
    // Loop array writing cells to the MA table containing the cross time for each element of the array. Number each element in the left row.
    // Format the UNIX time value to a formatted time string using `str.format_time()`.
    for [i, timeValue] in goldenCrossesTimes
        table.cell(maTable, 0, i + 1, str.tostring(i + 1), text_color = #FFD700)
        table.cell(maTable, 1, i + 1, str.format_time(int(timeValue), "yyyy.MM.dd 'at' HH:mm:ss z"), text_color = chart.fg_color)
    // Create a second table to display the indices of the last 8 RSI all time highs.
    var table rsiTable = table.new(position.bottom_right, 1, 1, color.new(color.black, 100), color.gray, 1, color.gray, 1)
    table.cell(rsiTable, 0, 0, "Bar indices of RSI ATHs\n" + str.tostring(barIndicesOfHiRSIs), text_color = chart.fg_color)
```

Using tables for debugging, especially when dealing with multiple series
or generating on-chart logs, can be beneficial. However, they are
computationally more expensive than other debugging methods and often
require additional code. Additionally, unlike labels, the state of a
table can only be viewed from the most recent script execution.
Therefore, it\'s advisable to use tables judiciously and sparingly
during the debugging process, favoring simpler methods whenever
feasible.

#### Pine Logs 

[Pine Logs](/pine-script-docs/writing/debugging#pine-logs) are
commands designed to display messages in a console at specific points
during the execution of a script. These logs enable programmers to
examine the script\'s data, conditions, and the flow of execution by
displaying messages, complete with timestamps, in a dedicated Pine Logs
pane. The Pine Logs are much like debug consoles in traditional
programming languages, enabling debugging and inspection with minimal
code.

In our example code, we adapt our previously discussed method of
implementing stacks with arrays from
[this FAQ entry](/pine-script-docs/faq#what-does-queue-stack-mean), enhancing it by integrating Pine Logs for logging. This
enhancement significantly surpasses the other debugging techniques
discussed so far in terms of providing detailed insights into the
script\'s operational flow, especially regarding array manipulation.
Through Pine Logs, we
[create console messages](/pine-script-docs/writing/debugging#creating-logs) that are time stamped and offer precise information about
the arrays, including the elements being added or removed during various
operations. We incorporate logging statements that detail when elements
are added or removed, the current size of the arrays, and the specific
prices at which elements were added.

The script below showcases a
[stack-based approach](/pine-script-docs/language/arrays#using-an-array-as-astack) for tracking lines drawn from pivot points. When a pivot
point is detected, the script adds a new line to the stack and continues
to extend the lines on each bar until an intersection with price action
occurs. If an intersection is found, the script removes (pops) the
intersected line from the stack, meaning it will no longer be extended
with new bars. Each time the arrays are manipulated, detailed logging
messages are printed to the console:

![image](@assets/images/Data-structures-How-do-i-debug-arrays-1.png)

``` pine
//@version=5
indicator("Array as a stack with logs", overlay = true)

int PIVOT_LEGS = 20

// @function                Adds a new horizontal line to an array of lines at a specified pivot level.
// @param id                (array<line>) The array to which the new line will be added.
// @param pivot             (float) The price level at which the horizontal line should be drawn.
// @param lineColor         (color) The color of the line to be drawn.
// @returns                 (void) The function has no explicit return.
stackLine(array<line> id, float pivot, color lineColor) =>
    if not na(pivot)
        array.push(id, line.new(bar_index - PIVOT_LEGS, pivot, bar_index, pivot, color = lineColor))
        if barstate.isconfirmed
            log.info("\nNew line added at {0}\nArray size: {1}", pivot, id.size())

// @function                Extends the endpoint (`x2`) of each line in an array to the current `bar_index`.
// @param id                (array<line>) The array containing the line objects to be updated.
// @returns                 (void) The function has no explicit return.
extendLines(array<line> id) =>
    for eachLine in id
        eachLine.set_x2(bar_index)

// @function                Removes line objects from an array if they are above or below the high or low price of the current bar.
// @param id                (array<line>) The array from which line objects will be removed.
// @param isBull            (bool) The condition to determine removal: if true, lines below the high price are removed (bullish scenario);
//                          if false, lines above the low price are removed (bearish scenario).
// @returns                 (void) The function has no explicit return.
removeLines(array<line> id, bool isBull) =>
    if array.size(id) > 0
        for i = array.size(id) - 1 to 0
            float linePrice = line.get_price(array.get(id, i), bar_index)
            if isBull ? high > linePrice : low < linePrice
                array.pop(id)
                if barstate.isconfirmed
                    log.warning(
                         "\nLine removed from {0} array.\nPrice breached {1}\nArray size: {2}",
                         isBull ? "Highs" : "Lows", linePrice, id.size()
                     )
            else
                break


// Find the pivot high and pivot low price.
float pivotLo = ta.pivotlow(PIVOT_LEGS,  PIVOT_LEGS)
float pivotHi = ta.pivothigh(PIVOT_LEGS, PIVOT_LEGS)

// Init 2 arrays on the first bar to stack our lines in.
var array<line> pivotHiArray = array.new<line>()
var array<line> pivotLoArray = array.new<line>()

// Search for pivots and draw a line from the pivot to the current bar when found and add it to the stack.
stackLine(pivotHiArray, pivotHi, color.orange)
stackLine(pivotLoArray, pivotLo, color.aqua)

// Extend all lines in each array to the current bar on each bar.
extendLines(pivotHiArray)
extendLines(pivotLoArray)

// Cycle backward through the array checking if the high breached the pivot high lines, or the low breached the pivot low lines.
// Pop lines off the stack if they have been breached.
removeLines(pivotHiArray, true)
removeLines(pivotLoArray, false)
```

Utilizing Pine Logs for debugging arrays stands out as the most
comprehensive and straightforward approach. The advantage of Pine Logs
lies in their flexibility; they can display selected script values or
variables at any part of your code, including
[local scopes](/pine-script-docs/writing/debugging#local-drawings-and-logs),
[functions](/pine-script-docs/writing/debugging#debugging-functions), [loops](/pine-script-docs/writing/debugging#debugging-loops), or other logical constructs. By logging messages to the
console whenever there\'s a modification in the array, you gain the
ability to track the detailed logical flow of array operations. This
enhances your debugging process by providing a higher level of detail
and insight into how your code behaves.

:::warning[Notice!]
To address and troubleshoot commonly encountered array-related errors,
refer to the
[Error Handling](/pine-script-docs/language/arrays#error-handling) section specifically dedicated to arrays in the Pine Script™
User Manual.
:::

### How can I debug objects? 

In programming, debugging is essential for identifying and fixing issues
or unexpected behavior in your code. In Pine Script™, although there\'s
no direct built-in feature for converting
[objects](/pine-script-docs/language/objects) into strings for
examination, you can still effectively debug objects. This can be done
by creating custom functions that break down an object into its
constituent fields and convert these fields into strings for detailed
inspection. This method provides insights into the data structures being
utilized, detailing both the timing and processes involved in object
creation and the values assigned to their fields.

After converting an object\'s fields into strings, these strings can be
displayed using various methods (see the
[Debugging](/pine-script-docs/writing/debugging) section for
more info). A particularly effective debugging method involves the use
of [Pine Logs](/pine-script-docs/writing/debugging#pine-logs).
Pine Logs are commands that output messages to a console at designated
points in the script\'s execution, functioning similarly to debug
consoles in traditional programming languages. They offer a window into
the script\'s data, conditions, and execution flow by displaying
messages with timestamps in a dedicated Pine Logs pane, thus
facilitating debugging and inspection with minimal additional code.

In our example script, we create a
[user-defined type](/pine-script-docs/language/type-system#user-defined-types) (UDT) named `openLine`, which includes fields such as
`price`, `openTime`, and a line object called `level`. On the first bar
of each session, the script initializes a new `openLine` instance. This
object is used to track the session\'s opening price and time, and it
draws a line at the open price, extending from the session\'s start to
its close. The object is then stored in an array. The script illustrates
a process of debugging objects by introducing a custom function,
`debugOpenLine()`, that breaks our `openLine` object into its individual
fields, converts the fields to strings, and then logs a message that
displays these strings in the console for debugging purposes:

![image](@assets/images/Data-structures-How-can-i-debug-objects-1.png)

``` pine
//@version=5
indicator("Debugging Objects", overlay = true)

type openLine
    float price
    int   openTime
    line  level

// @function            Queues a new `arrayElement` at the end of the `id` array and de-queues
//                      the first element if the array size exceeds the specified `maxSize`.
// @param id            (<any array type>) The array in which the element is to be queued.
// @param maxSize       (int) The maximum allowed number of elements in the array.
//                      If the array size exceeds this, the first element is de-queued.
// @param arrayElement  (<type of the array's elements>) The new element to be added to the array.
// @returns             (<type of the array's elements>) The de-queued element.
arrayQueue(id, int maxSize, value) =>
    id.push(value)
    if id.size() > maxSize
        id.shift()

// @function            Logs detailed information about an open line object for debugging purposes.
// @param ol            (openLine) The open line object to be logged.
// @returns             (void) Function has no explicit return.
debugOpenLine(openLine ol) =>
    if barstate.isconfirmed
        log.info("\nprice: {0}\nopenTime: {1}\nlevel line coords:\nx1: {2}\ny1: {3}\nx2: {4}\ny2: {5}",
             ol.price, ol.openTime, str.format_time(ol.level.get_x1()), ol.level.get_y1(), str.format_time(ol.level.get_x2()), ol.level.get_y2()
         )

// Create an empty `openLine` array.
var openLineArray = array.new<openLine>()

// On session start, create a new `openLine` object and add it to the array.
// Use the custom debug function to print the object's fields to the Logs window.
if session.isfirstbar_regular
    openLine ol = openLine.new(open, time)
    ol.level := line.new(time, open, time_close("D"), open, xloc.bar_time, color = color.aqua)
    arrayQueue(openLineArray, 4, ol)
    debugOpenLine(ol)
```

Here, the `debugOpenLine()` function breaks down the openLine object\'s
fields into a string format, logging the open price, open time, and the
coordinates of the line object to the Pine Logs pane. This provides a
clear view of the object\'s current state for debugging purposes.

## Functions 

-   [Can I use a variable length in functions?](/pine-script-docs/faq#can-iuse-avariable-length-in-functions)
-   [How can I calculate values depending on variable lengths that reset on a condition?](/pine-script-docs/faq#how-can-icalculate-values-depending-on-variable-lengths-that-reset-on-acondition)
-   [How can I round a number to x increments?](/pine-script-docs/faq#how-can-iround-anumber-to-xincrements)
-   [How can I control the number of decimals used in displaying my script's values?](/pine-script-docs/faq#how-can-icontrol-the-number-of-decimals-used-in-displaying-my-scripts-values)
-   [How can I control the precision of values used in my calculations?](/pine-script-docs/faq#how-can-icontrol-the-precision-of-values-used-in-my-calculations)
-   [How can I round to ticks?](/pine-script-docs/faq#how-can-iround-to-ticks)
-   [How can I abbreviate large values?](/pine-script-docs/faq#how-can-iabbreviate-large-values)
-   [How can I calculate using pips?](/pine-script-docs/faq#how-can-icalculate-using-pips)
-   [How do I calculate averages?](/pine-script-docs/faq#how-do-icalculate-averages)
-   [How can I calculate an average only when a certain condition is true?](/pine-script-docs/faq#how-can-icalculate-an-average-only-when-acertain-condition-is-true)
-   [How can I generate a random number?](/pine-script-docs/faq#how-can-igenerate-arandom-number)
-   [How can I evaluate a filter I am planning to use?](/pine-script-docs/faq#how-can-ievaluate-afilter-iam-planning-to-use)
-   [What does nz() do?](/pine-script-docs/faq#what-does-nz-do)

### Can I use a variable length in functions? 

In Pine Script™, there have been significant improvements in how
technical analysis (TA) functions handle the `length` parameter.
Initially, most [built-in](/pine-script-docs/built-in-functions) functions in the `ta.*()` namespace were limited to
accepting only
\"[simple](/pine-script-docs/language/type-system#simple)\" integer values for their `length` arguments. However,
there\'s been a shift towards supporting
\"[series](/pine-script-docs/language/type-system#series)\" lengths, enabling dynamic adjustment of this parameter
during the runtime of a script. Take note of the following:

-   **Series length acceptance:** Now, a majority of the built-in TA
    functions can process \"series\" lengths. This enhancement broadens
    the flexibility in applying technical analysis functions, as the
    `length` parameter can dynamically change from bar to bar.
-   **Exceptions:** Despite recent advancements, certain functions like
    [ta.ema()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.ema)
    and
    [ta.atr()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.atr)
    still only accept \"simple\" integer lengths. They have yet to be
    updated to accept variable `length` parameters.
-   **Additional resources:** For more advanced versions of functions
    like EMA or ATR that support \"series\" lengths, or for other
    technical analysis tools not yet integrated into Pine Script\'s
    native built-ins, users can explore the [ta
    library](https://www.tradingview.com/script/BICzyhq0-ta/) on the
    TradingView profile. This library offers a range of extended
    TA-related capabilities and custom implementations.
-   **User-defined functions:** For cases where built-in functions do
    not accept \"series\" lengths and the functionality is not available
    in the [ta](https://www.tradingview.com/script/BICzyhq0-ta/)
    library, creating a
    [user-defined function](/pine-script-docs/language/user-defined-functions) with custom logic is necessary.

:::warning[Notice!]
It's important to stay updated with the capabilities of Pine Script™, as
TradingView continually enhances the language with new features and
updates to existing functions. To stay up to date on new Pine Script™
features, keep an eye on the User Manual's
[Release notes](/pine-script-docs/release-notes). The
[PineCoders](https://www.tradingview.com/u/PineCoders/) account also
broadcasts updates from its [Squawk
Box](https://t.me/PineCodersSquawkBox) on Telegram, its [Twitter
account](https://twitter.com/PineCoders), and from the [Pine Script®
Q&A](https://www.tradingview.com/chat/#BfmVowG1TZkKO235) public chat on
TradingView.
:::

### How can I calculate values depending on variable lengths that reset on a condition? 

In situations where you need to calculate certain values that are
dependent on varying lengths, which also reset under specific
conditions, the
[ta.barssince()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.barssince)
function is quite useful. This function is designed to count the number
of bars since the last occurrence of a specified condition,
automatically resetting the count each time this condition is met.

There are, however, some considerations to take into account when using
this function for this purpose. Firstly, before the condition has been
met for the first time in a chart\'s history,
[ta.barssince()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.barssince)
returns
[na](https://www.tradingview.com/pine-script-reference/v5/#var_na). This
value is not compatible as a length for functions and may lead to errors
in your script, especially during execution on a chart\'s early bars. To
counter this, you can use
[nz()](https://www.tradingview.com/pine-script-reference/v5/#fun_nz) to
replace the
[na](https://www.tradingview.com/pine-script-reference/v5/#var_na)
return of
[ta.barssince()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.barssince)
with zero for early bars. Secondly, when the condition is met,
[ta.barssince()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.barssince)
returns zero for that bar. Since lengths cannot be zero, it is necessary
to add one to the returned value, ensuring that the length is always at
least one.

Here\'s an example of how to use these principles in a practical
context, such as calculating the highest and lowest points since the
start of a new day. We employ
[timeframe.change()](https://www.tradingview.com/pine-script-reference/v5/#fun_timeframe.change)
to detect the start of a new day, which serves as our condition. The
[ta.barssince()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.barssince)
function then calculates the number of bars elapsed since this condition
was last met. This number, or \"lookback\", is subsequently passed to
the
[ta.lowest()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.lowest)
and
[ta.highest()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.highest)
functions, which determine the highest and lowest points since the start
of the new day:

![image](@assets/images/Functions-How-can-i-calculate-values-depending-on-variable-lengths-that-reset-on-a-condition-1.png)

``` pine
//@version=5
indicator("High/low since new day", "", true)

// Identify the start of a new day and calculate the number of bars that have occurred since then.
bool newDay  = timeframe.change("D")
int lookback = nz(ta.barssince(newDay)) + 1

// Calculate the highest and lowest point since the new day began.
float lowestSinceNewDay  = ta.lowest(lookback)
float highestSinceNewDay = ta.highest(lookback)

// Plot the high/low level since the start of a new day.
plot(lowestSinceNewDay, "High today", color.orange)
plot(highestSinceNewDay, "Low today", color.aqua)
// Change the background color to indicate the start of a new day.
bgcolor(newDay ? color.new(color.gray, 80) : na)
// Display varying lookback period in Data Window.
plot(lookback, "lookback", display = display.data_window)
```

:::warning[Notice!]
When built-in functions are used with variable lengths, an error may
occur if the specified number of bars back is excessively large, often
when exceeding 300 bars. The error message \"*Pine cannot determine the
referencing length of a series. Try using max_bars_back*\" indicates
this issue. For more information, please refer to our [Help
Center](https://www.tradingview.com/support/solutions/43000587849-i-see-pine-cannot-determine-the-referencing-length-of-a-series-try-using-max-bars-back-error/)
article and [User
Manual](https://www.tradingview.com/pine-script-docs/en/v5/Error_messages.html#pine-script-cannot-determine-the-referencing-length-of-a-series-try-using-max-bars-back-in-the-indicator-or-strategy-function)
entries on the topic.
:::

### How can I round a number to x increments? 

Rounding numbers to specific increments is a common requirement in Pine
Script™. It can be useful in scenarios like calculating levels for grid
trading, dealing with fractional shares, or aligning trading parameters
to specific pip values. Rounding in this manner could be useful in a
variety of scenarios where you need precise control over the granularity
of your data, or when you\'re dealing with non-uniform increment sizes.

In this example the `roundToIncrement()` function accepts a value and an
increment as parameters. It divides the value by the increment, rounds
the result, then multiplies it by the increment to give the rounded
value. To demonstrate the function, the closing price is rounded to the
nearest increment defined in the user menu:

``` pine
//@version=5
indicator("Round to x increment demo", overlay = true)

float incrementInput = input.float(0.75, "Increment", step = 0.25)

// @function                Rounds a value to the nearest multiple of a specified increment.
// @param value             The value to be rounded.
// @param increment         The increment to which the value should be rounded.
// @returns                 The rounded value.
roundToIncrement(value, increment) =>
    math.round(value / increment) * increment

plot(roundToIncrement(close, incrementInput))
```

### How can I control the number of decimals used in displaying my script\'s values? 

If you need to manipulate the number of decimals in the values displayed
by your script, it can be achieved by using the `precision` and `format`
arguments within the
[indicator()](https://www.tradingview.com/pine-script-reference/v5/#fun_indicator)
or
[strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
declaration statement of your script.

These arguments control how the values are rounded for display purposes.
To get a thorough understanding of how to use these parameters, you can
consult the respective entries in the Pine Script™ Reference Manual,
accessible via the provided links.

By default, the precision of the price scale is utilized. To display
more decimal places, specify a `precision` argument that exceeds the
value of the current price scale.

### How can I control the precision of values used in my calculations? 

You can use the `math.round(number, precision)` variation of the
[math.round()](https://www.tradingview.com/pine-script-reference/v5/#fun_math.round)
function to round values according to a specified precision.
Additionally, the
[math.round_to_mintick()](https://www.tradingview.com/pine-script-reference/v5/#fun_math.round_to_mintick)
function allows you to round values to the nearest tick precision of the
chart\'s symbol.

### How can I round to ticks? 

To round values to the tick precision of a chart\'s symbol in your
script, utilize the function
[math.round_to_mintick()](https://www.tradingview.com/pine-script-reference/v5/#fun_math.round_to_mintick).
When you need to round a string representation of a number to the tick
precision, use `str.tostring(myValue, format.mintick)`, where `myValue`
is the variable representing the number in string format.

### How can I abbreviate large values? 

Large numerical values, like volume, can be abbreviated in a few ways.
For instance, the number 1 222 333.0 can be simplified to 1.222M. Here
are several methods to accomplish this:

1.  **Apply a global setting:** Use the argument
    `format = format.volume` within either the
    [indicator()](https://www.tradingview.com/pine-script-reference/v5/#fun_indicator)
    or
    [strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
    functions. This way, all displayed values will be represented in
    their abbreviated forms.
2.  **Abbreviate specific values:** If you only want to abbreviate
    certain values for string display, use the
    `str.tostring(value, format.volume)` function.
3.  **Use a custom function:** If you want more granular control over
    the abbreviation process, such as specifying a custom precision or
    abbreviating values up to trillions, you can use the
    [user-defined function](/pine-script-docs/language/user-defined-functions) in the following code example called
    `abbreviateValue()`. Here\'s an example of how to use that function:

``` pine
//@version=5
indicator("Value abbreviation example")

// @function            Converts a numeric value into a readable string representation featuring the appropriate order of
//              magnitude abbreviation (K, M, B, T).
// @param value         (float) The value to be formatted.
// @param precision         (string) Defines the numerical precision of the result. ("" for none, ".00" for two digits, etc.)
// @returns                 (string) The formatted value as a string with the appropriate abbreviation suffix.
abbreviateValue(float value, string precision) =>
    float digitsAmt = math.log10(math.abs(value))
    string formatPrecision = "#" + precision
    string result = switch
        digitsAmt > 12 => str.tostring(value / 1e12, formatPrecision + "  T")
        digitsAmt > 9  => str.tostring(value / 1e9,  formatPrecision + "  B")
        digitsAmt > 6  => str.tostring(value / 1e6,  formatPrecision + "  M")
        digitsAmt > 3  => str.tostring(value / 1e3,  formatPrecision + "  K")
        =>                str.tostring(value, "#" +  formatPrecision)

print(formattedString) =>
    var table t = table.new(position.middle_right, 1, 1)
    table.cell(t, 0, 0, formattedString, bgcolor = color.yellow)

print(abbreviateValue(volume, ".00"))
```

In the above function, the `value` is divided by a power of ten based on
its magnitude, and an abbreviation letter (K, M, B, or T) is added to
represent the magnitude of the original value. The function also adds a
subtle space between the value and the magnitude letter. The `print()`
function displays the value on the chart for visualization.

### How can I calculate using pips? 

Use this function to return the correct pip value for Forex symbols, or
the base unit of change for non-forex symbols:

``` pine
// @function            Calculates the chart symbol's base unit of change in asset prices.
// @returns             (float) A ticks or pips value of base units of change.
calcBaseUnit() =>
    bool isForexSymbol = syminfo.type         == "forex"
    bool isYenQuote    = syminfo.currency     == "JPY"
    bool isYenBase     = syminfo.basecurrency == "JPY"
    float result = isForexSymbol ? isYenQuote ? 0.01 : isYenBase ? 0.00001 : 0.0001 : syminfo.mintick
```

Please remember, this function might not address all potential
scenarios, so it\'s advisable to confirm the results with your broker to
ensure the function\'s output matches the broker\'s values.

### How do I calculate averages? 

To calculate averages, the method depends on the type of values you
have:

1.  **Distinct variables:** If you are dealing with distinct variables,
    the function [math.avg(val1,
    val2)](https://www.tradingview.com/pine-script-reference/v5/#fun_math.avg)
    can be used to calculate the average. Simply pass each of the
    variables as an argument to this function.
2.  **Bar prices:** If you are attempting to find the average price of a
    single bar, refer to
    [built-in](/pine-script-docs/built-in-functions)
    variables such as
    [hl2](https://www.tradingview.com/pine-script-reference/v5/#var_hl2),
    [hlc3](https://www.tradingview.com/pine-script-reference/v5/#var_hlc3)
    and
    [ohlc4](https://www.tradingview.com/pine-script-reference/v5/#var_ohlc4).
3.  **Series values:** To compute the average of the last *n* values in
    a series, the function [ta.sma(series,
    n)](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.sma)
    can be utilized.
4.  **Custom datasets:** If you need to average a custom set of values,
    these can be organized into an array, with
    [array.avg()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.avg)
    then used to find the average. For more information on this, the
    [Pine User Manual](/pine-script-docs/language/arrays) on
    arrays is a helpful resource. If dealing with matrices, you can
    utilize the
    [matrix.avg()](https://www.tradingview.com/pine-script-reference/v5/#fun_matrix.avg)
    function to average their contents. Additionally, for a deeper
    understanding of averaging custom datasets, refer to
    [this](https://www.tradingview.com/script/9l0ZpuQU-ConditionalAverages/)
    publication.

### How can I calculate an average only when a certain condition is true? 

Averaging is a useful tool for smoothing out fluctuations, identifying
trends, and establishing a general expectation of values within a
dataset. However, traditional averaging techniques often apply across
all data points within a fixed window, which might not always be
suitable, especially when you\'re interested in calculating averages
under specific conditions. *Conditional averaging* allows for more
targeted analysis, focusing on data points that meet predetermined
criteria to draw more nuanced insights.

In our example script, we import the
[ConditionalAverages](https://www.tradingview.com/script/9l0ZpuQU-ConditionalAverages/)
library to show 2 simple techniques for averaging values only under
specific conditions:

![image](@assets/images/Functions-How-can-i-calculate-an-average-only-when-a-certain-condition-is-true-1.png)

``` pine
//@version=5
indicator("Average session opening volume")

import PineCoders/ConditionalAverages/1 as PCca

// Create an input for the number of opening session volumes to average.
int numOccurrencesInput = input.int(5, "Number of occurrences to average")

// Color aqua for the session's opening bar, otherwise distinct colors for up/down volume columns.
color volumeColor = switch
    session.isfirstbar_regular => color.aqua
    close > open               => color.new(#D1D4DC, 65)
    =>                            color.new(#787B86, 65)

// Plot the volume columns.
plot(volume, "volume", volumeColor, 4, plot.style_histogram)
// Average volume over all occurrences of the condition (average volume on all session opening bars) in the dataset.
plot(PCca.avgWhen(volume, session.isfirstbar_regular), "avg. When", #FF00FF)
// Average volume over the last number of occurrences when the condition was true (average opening bar volume in the last `numOccurrencesInput` sessions).
plot(PCca.avgWhenLast(volume, session.isfirstbar_regular, numOccurrencesInput), "avgWhenInLast()", #00FF00)
```

**In our script we:**

-   Import the
    [ConditionalAverages](https://www.tradingview.com/script/9l0ZpuQU-ConditionalAverages/)
    library. Pine Script™ libraries are publications that contain
    reusable code for importing into Pine Script™ indicators,
    strategies, and other libraries. For more information on libraries
    and incorporating them into your scripts, see the
    [Libraries](/pine-script-docs/concepts/libraries) section of
    the Pine Script™ `User Manual <IndexUserManual>`.
-   Utilize the
    [session.isfirstbar_regular](https://www.tradingview.com/pine-script-reference/v5/#var_session.isfirstbar_regular)
    built-in to detect the first bar of the session to average opening
    volumes on each day.
-   Apply two simple methods to demonstrate conditional averaging with
    the imported functions:
    -   **avgWhen():** We use this function to calculate the average
        volume of opening bars across the entire dataset, offering a
        general insight into opening volumes.
    -   **avgWhenLast():** Offers a more current perspective by
        averaging the opening volumes for a specified number of the most
        recent sessions where the condition was met.
-   Visually differentiate the session\'s opening volume by coloring the
    first volume column of the session in
    [aqua](https://www.tradingview.com/pine-script-reference/v5/#const_color.aqua).
    For further distinction, slightly vary the colors of the subsequent
    volume columns to indicate up and down volumes.
-   Provide an input to choose how many of the last sessions are
    averaged using `avgWhenLast()` (green line).

To enhance your analytical toolkit, consider exploring the
[ConditionalAverages](https://www.tradingview.com/script/9l0ZpuQU-ConditionalAverages/)
and [getSeries](https://www.tradingview.com/script/Bn7QkdZR-getSeries/)
libraries by PineCoders. These libraries offer additional functions for
conditional averaging and the creation of custom datasets. They also
provide example code to showcase the capabilities of their functions.

### How can I generate a random number? 

Use the
[math.random()](https://www.tradingview.com/pine-script-reference/v5/#fun_math.random)
function to generate random numbers. This example illustrates the
function by creating a circle plot with random RGB color values and a
random y-value between 0 and 1:

``` pine
//@version=5
indicator("Random demo")
color plotColor = color.rgb(math.random(0, 255), math.random(0, 255), math.random(0, 255))
plot(math.random(), "Random number", plotColor, 2, plot.style_circles)
```

This results in a plot with randomly colored and positioned circles.

### How can I evaluate a filter I am planning to use? 

To evaluate a filter, insert your filter code into the [Information
Box - PineCoders FAQ
script](https://www.tradingview.com/script/oTEP9DJF-Filter-Information-Box-PineCoders-FAQ/).
This script will conduct an impulse response analysis and exhibit the
filter\'s traits in a label on the chart. For further details and a
guide on integrating your filter into the code, refer to the
publication\'s description.

### What does nz() do? 

The [nz()](https://www.tradingview.com/pine-script-reference/v5/#fun_nz)
function is utilized to replace any
[na](https://www.tradingview.com/pine-script-reference/v5/#var_na) value
with zero, or with a user-defined value if the `replacement` argument is
specified. This function is important in preventing
[na](https://www.tradingview.com/pine-script-reference/v5/#var_na)
values from interfering with calculations. Consider an example where
we\'re employing a historical operator in an equation and the history
reference surpasses the available data on the chart, as might occur on
the first bars of a chart.

Here is a sample code that computes the change in close values from one
bar to another. Without the
[nz()](https://www.tradingview.com/pine-script-reference/v5/#fun_nz)
function, the script returns
[na](https://www.tradingview.com/pine-script-reference/v5/#var_na) on
the first bar because the historical reference exceeds the available
data. However, when we use the
[nz()](https://www.tradingview.com/pine-script-reference/v5/#fun_nz)
function, a value is returned on the first historical bar, thus
preventing the
[na](https://www.tradingview.com/pine-script-reference/v5/#var_na)
value. To visualize the contrast between the two versions of the
`barRange` calculations, you can toggle between them by commenting and
uncommenting each line, respectively.

``` pine
//@version=5
indicator("na on first bar demo")
float barRange = close - close[1]
// float barRange = close - nz(close[1], open)
plot(barRange)
```

In the scenario where the script is run on the first bar of the chart,
`close[1]` in the initial example would return
[na](https://www.tradingview.com/pine-script-reference/v5/#var_na).
However, in the second example where the alternate line is uncommented,
the [nz()](https://www.tradingview.com/pine-script-reference/v5/#fun_nz)
function substitutes `close[1]` with the `open` value. As a result, even
the first bar of the chart yields a valid value.

Additionally, the
[nz()](https://www.tradingview.com/pine-script-reference/v5/#fun_nz)
function is useful to protect against any potential divide-by-zero
errors. It guarantees a return value even when an equation
unintentionally features a zero in the denominator. Consider the
following code snippet that intentionally creates a divide-by-zero
scenario by setting the denominator to zero. Without the
[nz()](https://www.tradingview.com/pine-script-reference/v5/#fun_nz)
function, this expression would return
[na](https://www.tradingview.com/pine-script-reference/v5/#var_na),
instead of zero:

``` pine
float dbzTest = nz(close / (close - close))
```

## Indicators 

-   [Can I create an indicator that plots like the built-in Volume or Volume Profile indicators?](/pine-script-docs/faq#can-icreate-an-indicator-thatplots-like-the-built-in-volume-or-volume-profile-indicators)
-   [Can I use a Pine script with the TradingView screener?](/pine-script-docs/faq#can-iuse-apine-script-with-the-tradingview-screener)
-   [How can I use one script's output as an input into another?](/pine-script-docs/faq#how-can-iuse-one-scripts-output-as-an-input-into-another)
-   [Can my script place something on the chart when it is running from a pane?](/pine-script-docs/faq#can-my-script-place-something-on-the-chart-when-it-is-running-from-apane)
-   [Is it possible to export indicator data to a file?](/pine-script-docs/faq#is-it-possible-to-export-indicator-data-to-afile)

### Can I create an indicator that plots like the built-in Volume or Volume Profile indicators? 

Not all built-in indicators published by TradingView can be replicated
using Pine Script™ due to its limitations. Some, like the Volume, Volume
Profile, TPO, and chart pattern indicators, are instead written in Java.
For those specifically looking to solve the issue with volume scaling,
an imperfect workaround can be found in
[this](https://stackoverflow.com/questions/60346464/tradingview-pine-script-how-can-i-make-custom-volume-indicator-behave-like-a-b)
Stack Overflow response.

### Can I use a Pine script with the TradingView screener? 

At the moment, the TradingView
[screener](https://www.tradingview.com/screener/) can only be used with
its built-in filters, and not with a Pine Script™. If you look up
\"[screener](https://www.tradingview.com/scripts/search/screener/)\" in
the Community Collection, you will find a few script examples that
utilize the
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
function to perform screenings from pre-set, limited lists of symbols.

Please be aware of the following limitations:

1.  `request.security()` can only handle 40 symbols at a time, and users
    must manually input these symbols.
2.  Due to the loading time necessary for `request.security()` calls,
    scripts may compile more slowly than expected.

To effectively run a custom script that generates alerts on multiple
symbols, refer to
[this FAQ entry](/pine-script-docs/faq#ihave-acustom-script-that-generates-alerts-how-do-irun-it-on-many-symbols), which uses the `request.security()` function to call data
from a pre-set limited list of up to a maximum of 40 symbols.

### How can I use one script\'s output as an input into another? 

You can utilize the output from one script as an input into another by
employing the
[input.source()](https://www.tradingview.com/pine-script-reference/v5/#fun_input.source)
function. When an input is defined with
[input.source()](https://www.tradingview.com/pine-script-reference/v5/#fun_input.source),
the function equips the script with the capability to select the output
of other scripts as its input. This configuration can be set up within
the script settings.

However, there are some limitations to keep in mind:

-   Only plots can be used as an input for other scripts.
-   Each time an indicator is loaded on a chart, inputs have to be
    manually selected.
-   The sources used as external inputs must originate from indicators;
    they cannot originate from strategies. However, plots originating
    from indicators can be used in strategies.
-   External input sources can originate from at most ten different
    indicators.

For further information, refer to
[this](https://www.tradingview.com/blog/en/more-external-inputs-for-scripts-38014/)
blog post and the relevant entry in the
[User Manual](/pine-script-docs/concepts/inputs#source-input).

### Can my script place something on the chart when it is running from a pane? 

When executed from a separate indicator pane, your script can influence
the main chart using two specific methods:

-   **Changing bar colors:** Utilize the
    [barcolor()](https://www.tradingview.com/pine-script-reference/v5/#fun_barcolor)
    function to alter the color of the chart bars. This function allows
    the script to modify the main chart\'s bar colors, despite running
    in a separate indicator pane.
-   **Forcing plots to overlay:** Employ the `force_overlay` parameter
    available in various plotting functions such as
    [plot()](https://www.tradingview.com/pine-script-reference/v5/#fun_plot),
    [plotshape()](https://www.tradingview.com/pine-script-reference/v5/#fun_plotshape),
    [plotchar()](https://www.tradingview.com/pine-script-reference/v5/#fun_plotchar),
    [plotarrow()](https://www.tradingview.com/pine-script-reference/v5/#fun_plotarrow),
    [plotbar()](https://www.tradingview.com/pine-script-reference/v5/#fun_plotbar),
    and
    [plotcandle()](https://www.tradingview.com/pine-script-reference/v5/#fun_plotcandle).
    Setting this parameter to true causes these plotting functions to
    display their outputs on the main chart, overriding their default
    location in the separate indicator pane.

These are the only ways a script can modify the main chart from a pane.
Other visual elements are constrained to their assigned areas, as
determined by the `overlay` parameter in the
[indicator()](https://www.tradingview.com/pine-script-reference/v5/#fun_indicator)
or
[strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
functions. This parameter dictates whether script outputs appear on the
main chart or within a pane.

### Is it possible to export indicator data to a file? 

You can export chart data by selecting the \"Export chart data\...\"
option located in the dropdown menu at the top right corner of your
chart. The exported CSV file will include time, OHLC data, and any plots
generated by your script.

To include specific information in the CSV file, you must ensure that it
is plotted in your script. In cases where the values to be plotted are
beyond the scope of your indicator or if you prefer not to display
certain plots, consider using the `display` parameter in the
[plot()](https://www.tradingview.com/pine-script-reference/v5/#fun_plot)
function. This will prevent disruption of your script\'s scale.
Alternatively, you can maintain the script\'s scale by choosing \"Scale
price chart only\" in your chart settings. These settings can be
accessed by right-clicking on the chart\'s price scale.

For example, to include data in the CSV export without displaying it on
the chart, use the following command:

``` pine
plot(close * 0.5, "No chart display", display = display.data_window)
```

The title given to the plot, in this case \"No chart display\", will
serve as the column header in the CSV file.

If your requirement is solely to determine if a condition was true or
false, you can use the
[plotshape()](https://www.tradingview.com/pine-script-reference/v5/#fun_plotshape)
function. This will record a 1 or 0 in your CSV file for true or false,
respectively.

It\'s also worth noting that strategy data can be exported following the
same process.

## Other Data and Timeframes 

-   `` How to avoid repainting when using the \`request.security()\` function? <PageFaq_OtherDataAndTimeframes_HowToAvoidRepaintingWhenUsingTheRequestSecurityFunction> ``
    -   [Higher timeframes](/pine-script-docs/faq#higher-timeframes)
    -   [Lower timeframes](/pine-script-docs/faq#lower-timeframes)
    -   [Timeframes equal to the chart's timeframe](/pine-script-docs/faq#timeframes-equal-to-the-charts-timeframe)
-   [How can I convert the chart's timeframe into a numeric format?](/pine-script-docs/faq#how-can-iconvert-the-charts-timeframe-into-anumeric-format)
-   `` How can I convert a timeframe in float minutes into a string usable with \`request.security()\`? <PageFaq_OtherDataAndTimeframes_HowCanIConvertATimeframeInFloatMinutesIntoAStringUsableWithRequestSecurity> ``
-   [How do I define a higher interval that is a multiple of the current one?](/pine-script-docs/faq#how-do-idefine-ahigher-interval-that-is-amultiple-of-the-current-one)
-   `` Is it possible to use \`request.security()\` on lower timeframes than the chart’s current timeframe? <PageFaq_OtherDataAndTimeframes_IsItPossibleToUseRequestSecurityOnLowerTimeframesThanTheChartsCurrentTimeframe> ``
-   `` Why do intraday OHLCV values not correspond to values retrieved with \`request.security()\` at daily timeframes and higher? <PageFaq_OtherDataAndTimeframes_WhyDoIntradayOhlcvValuesNotCorrespondToValuesRetrievedWithRequestSecurityAtDailyAndHigher> ``
-   [How can I fetch the ATR value from a higher timeframe?](/pine-script-docs/faq#how-can-ifetch-the-atr-value-from-ahigher-timeframe)
-   [How can I plot a moving average only when the chart’s timeframe is 1D or higher?](/pine-script-docs/faq#how-can-iplot-amoving-average-only-when-the-charts-timeframe-is1d-or-higher)
-   [How can I plot a moving average calculated using the 1H timeframe on any chart?](/pine-script-docs/faq#how-can-iplot-amoving-average-calculated-using-the1h-timeframe-on-any-chart)

### How to avoid repainting when using the \`request.security()\` function? 

Most use cases of
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
involve requesting data from a timeframe higher than or the same as the
chart timeframe. It is possible, though not recommended to request data
from a lower timeframe. Below are considerations to avoid
[repainting](/pine-script-docs/concepts/repainting) for each of
the 3 scenarios.

#### Higher timeframes 

When requesting values from a *higher timeframe* (HTF), they are subject
to repainting because [realtime
bars](https://www.tradingview.com/pine-script-docs/en/v5/language/Execution_model.html#calculation-based-on-realtime-bars)
might include provisional data from developing HTF bars, leading to
adjustments in the timing of new values on [historical
bars](https://www.tradingview.com/pine-script-docs/en/v5/language/Execution_model.html#calculation-based-on-historical-bars).
Each HTF bar consists of a single set of
[open](https://www.tradingview.com/pine-script-reference/v5/#var_open),
[high](https://www.tradingview.com/pine-script-reference/v5/#var_high),
[low](https://www.tradingview.com/pine-script-reference/v5/#var_low) or
[close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
(OHLC) data. For historical bars, this data is not available to a lower
timeframe until the HTF bar has closed. In a realtime context, values
will vary with each price update, leading to repainting as the chart is
refreshed to synchronize with the closing times of HTF bars. This
concept is outlined in the
[Historical and realtime behavior](/pine-script-docs/concepts/other-timeframes-and-data#historical-and-realtime-behavior) section of the User Manual.

To mitigate repainting, it is essential to use confirmed values that
maintain consistent timing across all bars, whether in a developing
state or not. The preferred approach to ensure non-repainting results is
to reference only past bars in expressions (e.g., using `close[1]`) and
enable the
[lookahead](/pine-script-docs/concepts/other-timeframes-and-data#lookahead) parameter by setting it to
[barmerge.lookahead_on](https://www.tradingview.com/pine-script-reference/v5/#const_barmerge.lookahead_on).
This method ensures that the function relies on stable, historical data,
thereby avoiding the pitfalls of repainting associated with realtime
data updates:

``` pine
//@version=5
indicator("HTF close" , overlay = true)
float dailyClose = request.security(syminfo.tickerid, "D", close[1], lookahead = barmerge.lookahead_on)
plot(dailyClose)
if timeframe.in_seconds() >= timeframe.in_seconds("D")
    runtime.error("Chart timeframe must be less than Daily")
```

Note that:

    -   We've included a single bar offset to the `expression` argument
        and used
        [barmerge.lookahead_on](https://www.tradingview.com/pine-script-reference/v5/#const_barmerge.lookahead_on)
        in
        [request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
        to ensure the series returned behaves the same on historical and
        realtime bars. See the
        [Avoiding repainting](/pine-script-docs/concepts/other-timeframes-and-data#avoiding-repainting) section for more information.
    -   The script is designed to trigger a runtime error via the
        [runtime.error()](https://www.tradingview.com/pine-script-reference/v5/#fun_runtime.error)
        function if the chart\'s timeframe exceeds or matches the
        specified timeframe (Daily). This safety measure prevents the
        return of inaccurate values, as the method is exclusively
        designed for retrieving higher timeframe data.

:::warning[Notice!]
Failing to offset the `expression` argument will result in lookahead
bias, a phenomenon that unrealistically allows historical values to be
retrieved before they would have occurred in realtime. See the
`` \`lookahead\` <PageOtherTimeframesAndData_CommonCharacteristics_Lookahead> `` and `` Future leak
with \`request.security()\` <PageRepainting_HistoricalVsRealtimeCalculations_FutureLeakWithRequestSecurity> `` sections for more information.
:::

#### Lower timeframes 

Although the
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
function is intended to operate on timeframes greater than or equal to
the chart timeframe, it can request data from
[lower timeframes](/pine-script-docs/concepts/other-timeframes-and-data#lower-timeframes) as well, with limitations. When accessing data from a lower
timeframe (LTF), it evaluates the given expression in the LTF context
and returns the result from a single LTF bar per chart bar. The specific
LTF bar returned depends on the
[lookahead](/pine-script-docs/concepts/other-timeframes-and-data#lookahead) parameter:
[barmerge.lookahead_on](https://www.tradingview.com/pine-script-reference/v5/#const_barmerge.lookahead_on)
yields the first intrabar of the period historically, but the last
intrabar in realtime. Conversely,
[barmerge.lookahead_off](https://www.tradingview.com/pine-script-reference/v5/#const_barmerge.lookahead_off)
always returns the last intrabar for historical and realtime data. To
prevent [repainting](/pine-script-docs/concepts/repainting)---a
discrepancy caused by different behaviors in historical versus realtime
data---it\'s recommended to avoid using `barmerge.lookahead_on` for
lower timeframe data requests.

:::warning[Notice!]
While scripts can use
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
to retrieve the values from a single intrabar on each chart bar, which
might provide utility in some unique cases, we recommend using the
[request.security_lower_tf()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security_lower_tf)
function for intrabar analysis when possible, as it returns an
[array](/pine-script-docs/language/arrays) containing data from
all available intrabars within a chart bar. See
[this section](/pine-script-docs/concepts/other-timeframes-and-data#request-security-lower-tf) to learn more.
:::

#### Timeframes equal to the chart\'s timeframe 

Requesting data for timeframes *that match* the chart\'s own timeframe
and symbol is essentially redundant and introduces unnecessary
computational overhead. In such cases, directly utilizing the script\'s
values within the chart\'s context is more efficient and eliminates the
repainting concern associated with HTF and LTF requests.

However, when you need data from a different symbol but within the same
timeframe as the chart, you can use the
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
function. In this case, unlike the scenarios requiring adjustments for
HTF and LTF requests, equal timeframe requests do not benefit from
offsetting the data or manipulating the `lookahead` parameter. For
accessing data at the chart\'s timeframe for different assets, simply
employing the default `request.security()` function settings suffices to
avoid repainting (i.e., no offset to the data and
[barmerge.lookahead_off](https://www.tradingview.com/pine-script-reference/v5/#const_barmerge.lookahead_off)).

### How can I convert the chart\'s timeframe into a numeric format? 

The
[timeframe.in_seconds()](https://www.tradingview.com/pine-script-reference/v5/#fun_timeframe.in_seconds)
function allows for the conversion of a timeframe, specified in
[timeframe.period](https://www.tradingview.com/pine-script-reference/v5/#var_timeframe.period)
format, into an equivalent number of seconds. This conversion enables
various manipulations, such as calculating the number of time units
within a specific timeframe or performing operations that adjust the
timeframe used in higher timeframe calls in relation to the chart\'s
timeframe, as outlined in
[this FAQ entry](/pine-script-docs/faq#how-do-idefine-ahigher-interval-that-is-amultiple-of-the-current-one).

In this script example, we use the `timeframe.in_seconds()` function to
determine the chart\'s timeframe, measured in seconds. Since no specific
`timeframe` argument is specified, the function defaults to using
`timeframe.period`, which returns the chart\'s current timeframe. The
script then converts the timeframe obtained in seconds into various
other units of time, including milliseconds, minutes, hours, and days.
Finally, the converted values are displayed in a
[table](/pine-script-docs/concepts/tables):

``` pine
//@version=5
indicator("Timeframe to value")

int tfInSec  = timeframe.in_seconds()
int tfInMs   = tfInSec * 1000
int tfInMin  = tfInSec / 60
int tfInHrs  = tfInMin / 60
int tfInDays = tfInHrs / 24

if barstate.islastconfirmedhistory
    var table displayTable = table.new(position.top_right, 2, 5, na, color.gray, 1, color.gray, 1)
    table.cell(displayTable, 0, 0, "Timeframe in ms",      text_color = chart.fg_color)
    table.cell(displayTable, 1, 0, str.tostring(tfInMs),   text_color = chart.fg_color)
    table.cell(displayTable, 0, 1, "Timeframe in seconds", text_color = chart.fg_color)
    table.cell(displayTable, 1, 1, str.tostring(tfInSec),  text_color = chart.fg_color)
    table.cell(displayTable, 0, 2, "Timeframe in minutes", text_color = chart.fg_color)
    table.cell(displayTable, 1, 2, str.tostring(tfInMin),  text_color = chart.fg_color)
    table.cell(displayTable, 0, 3, "Timeframe in hours",   text_color = chart.fg_color)
    table.cell(displayTable, 1, 3, str.tostring(tfInHrs),  text_color = chart.fg_color)
    table.cell(displayTable, 0, 4, "Timeframe in days",    text_color = chart.fg_color)
    table.cell(displayTable, 1, 4, str.tostring(tfInDays), text_color = chart.fg_color)
```

### How can I convert a timeframe in float minutes into a string usable with \`request.security()\`? 

Previously, converting numerical values representing time into constant
strings for use in
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
was somewhat cumbersome. Developers had to rely on a series of
conditional blocks to deduce the chart\'s timeframe in string format, a
method outlined in [this dated FAQ
entry](https://www.pinecoders.com/faq_and_code/#how-can-i-convert-a-resolution-in-float-minutes-into-a-string-usable-with-security).
This process was not only clunky but also limited in flexibility and
efficiency.

Manipulating timeframes dynamically in Pine Script™ has become
significantly more efficient with the introduction of
[timeframe.in_seconds()](https://www.tradingview.com/pine-script-reference/v5/#fun_timeframe.in_seconds)
and
[timeframe.from_seconds()](https://www.tradingview.com/pine-script-reference/v5/#fun_timeframe.from_seconds)
functions. These built-in functions simplify quantifying timeframes and
the conversion of numerical time values into timeframe strings
compatible with `request.security()`, effectively superseding the
earlier, rudimentary solution proposed by PineCoders.

In the script example below, we demonstrate how to convert a
user-defined number of minutes into a timeframe string using the
`timeframe.from_seconds()` function. The script takes an input of
minutes, converts it into seconds, and then into a timeframe string
suitable for use with `request.security()`. The obtained timeframe
string is then used to fetch and plot the close price from the specified
timeframe. Additionally, we display the resulting timeframe string in a
[table](/pine-script-docs/concepts/tables) on the chart\'s top
right corner for easy reference:

``` pine
//@version=5
indicator("Target TF in string from float minutes", "", true)
float tfInMinInput = input.float(1440., "Minutes in target timeframe (<= 0.0167 [1 sec.])", minval = 0.0167)
// ————— Convert target TF in minutes from input into string.
string targetTfString = timeframe.from_seconds(int(tfInMinInput * 60))
// ————— Fetch target timeframe's close.
float targetTfClose = request.security(syminfo.tickerid, targetTfString, close)
// ————— Plot target timeframe close.
plot(targetTfClose, "Target TF close")
// Display the target timeframe string in a table cell at the chart's top right.
if barstate.islastconfirmedhistory
    var table displayTable = table.new(position.top_right, 1, 1, color.new(color.yellow, 70), color.gray, 1, color.gray, 1)
    table.cell(displayTable, 0, 0, str.format("Target TF (string): {0}", targetTfString), text_color = chart.fg_color)
```

### How do I define a higher interval that is a multiple of the current one? 

In Pine Script™, it\'s common to analyze data from a higher timeframe in
relation to the current chart\'s timeframe. Users often express a need
for a mechanism that would automatically adjust the higher timeframe
data relative to the chart\'s timeframe. This concept is particularly
useful for ensuring that indicators adjust dynamically to the user\'s
chart settings, maintaining a consistent ratio between the chart\'s
timeframe and the higher timeframe used in
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
calls, regardless of the timeframe changes initiated by the user.

In the provided script example, we demonstrate how to use the
[timeframe.in_seconds()](https://www.tradingview.com/pine-script-reference/v5/#fun_timeframe.in_seconds)
and
[timeframe.from_seconds()](https://www.tradingview.com/pine-script-reference/v5/#fun_timeframe.from_seconds)
functions to calculate a higher timeframe that is a fixed multiple of
the chart\'s current timeframe. By offering an input for the multiplier,
the script allows users to define the ratio between the chart\'s
timeframe and the higher timeframe dynamically. The script then
calculates the [Relative Strength
Index](https://www.tradingview.com/support/solutions/43000502338-relative-strength-index-rsi/)
(RSI) for both the chart\'s timeframe and the dynamically calculated
higher timeframe, plotting both on the chart for comparison. For clarity
on the timeframe used for the higher timeframe data, the calculated
higher timeframe string is displayed in a
[table](/pine-script-docs/concepts/tables) at the top right of
the indicator pane for reference:

``` pine
//@version=5
indicator("Multiple of current TF")

// Provide an input to specify the multiple to apply to the chart's timeframe.
float tfMult = input.float(4, minval = 1)

// Get multiple of current timeframe.
string targetTfString = timeframe.from_seconds(int(timeframe.in_seconds() * tfMult))
// Create local rsi.
float myRsi = ta.rsi(close, 14)
plot(myRsi, "Current TF RSI", color = color.new(color.silver, 0))
// No repainting HTF rsi.
float myRsiHtf1 = request.security(syminfo.tickerid, targetTfString, myRsi[1], lookahead = barmerge.lookahead_on)
plot(myRsiHtf1, "Non-repainting HTF RSI", color = color.new(color.green, 0))
// Repainting HTF rsi
float myRsiHtf2 = request.security(syminfo.tickerid, targetTfString, myRsi)
plot(myRsiHtf2, "Repainting HTF RSI", color = color.new(color.red, 0))

// Display the calculated timeframe at the pane's top right.
if barstate.islastconfirmedhistory
    var table displayTable = table.new(position.top_right, 1, 1, color.new(color.yellow, 70), color.gray, 1, color.gray, 1)
    table.cell(displayTable, 0, 0, str.format("Target TF (string): {0}", targetTfString), text_color = chart.fg_color)
```

Note that:

    -   The script dynamically adapts to the user\'s chart settings by
        multiplying the chart\'s timeframe setting (in seconds) by a
        default input value of 4. It then selects a timeframe closest to
        this calculated value. This approach ensures that the timeframe
        used in the higher timeframe call dynamically adapts to the
        user\'s chart settings, providing insights that are consistently
        scaled to the chart\'s timeframe.

### Is it possible to use \`request.security()\` on lower timeframes than the chart's current timeframe? 

The
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
function is primarily designed for accessing data at timeframes that are
equal to or higher than the chart\'s current timeframe. However, it is
technically possible to fetch data from `lower
timeframes <PageOtherTimeframesAndData_RequestSecurity_Timeframes_LowerTimeframes>`, albeit with certain limitations and considerations:

-   **Unsupported by TradingView:** Officially, TradingView does not
    support using `request.security()` to fetch data from lower
    timeframes. This usage goes beyond the intended design of the
    function.
-   **Data usefulness:** If `request.security()` is used without a
    custom function to specifically handle intrabars, it will only
    return the value from the last intrabar within the chart\'s current
    bar. This limitation severely restricts the practical utility of the
    data retrieved in this manner. This is demonstrated with the
    `lastClose` variable in the first script example below.
-   **Passing a function as the expression argument:** If you use a
    function as the `expression` argument, then that function will be
    executed on each intrabar, starting from the earliest one and ending
    at the most recent, even if the number of intrabars is sometimes
    irregular. Such an approach allows for the creation of functions
    specifically designed to analyze and extract information from each
    intrabar as the function processes them.
-   **Requirement for manual input of chart timeframe:** When using
    `request.security()` to access lower timeframe data, the script
    cannot automatically adjust to the current chart\'s timeframe, like
    it can with
    [request.security_lower_tf()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security_lower_tf).
    This is because variables designed to detect the chart\'s timeframe
    work within the requested timeframe\'s context, not the original
    chart\'s. Consequently, users must manually specify the current
    chart timeframe, as we do using the `curTfInput` variable in the
    following script example.

The following code uses two functions to demonstrate the application of
[timeframe.change(tf)](https://www.tradingview.com/pine-script-reference/v5/#fun_timeframe.change),
where `tf` represents the chart\'s current timeframe string, to aid in
detecting the specific intrabar each function operates on. The script
utilizes `request.security()` to analyze intrabars, allowing for the
counting and retrieval of specific intrabar values through custom
functions, a method that, although potentially beneficial in certain
situations, is not officially supported:

``` pine
//@version=5
indicator("Intrabar inspection using `request.security()`")

// An input to determine the intrabar number to find the value of.
int intraBarNoInput = input.int(4, minval = 1)
// Current chart timeframe. This needs to reflect the chart timeframe you want the code working from.
string curTfInput = input.timeframe("D", "Current timeframe")
// Lower timeframe we are inspecting. Must be lower than chart's timeframe.
string intraTfInput = input.timeframe("60", "Lower timeframe")

// @function                Calculates the quantity of intrabars within the current chart bar for a specified timeframe
//                          when passed to a lower timeframe via `request.security()`.
// @param tf                (string) The timeframe to count intrabars for, specified in `timeframe.period` format.
// @returns                 (int) The number of intrabars that have occurred within the current chart bar up to the current moment.
qtyIntrabars(string tf) =>
    var int count = 0
    count := timeframe.change(tf) ? 1 : count + 1

// @function                Retrieves the value of a series at a specified intrabar position within the current chart bar
//                          when passed to a lower timeframe via `request.security()`.
// @param src               (<any type>) The data series from which to retrieve the value.
// @param bar               (int) The intrabar position to retrieve the value from, where 1 is the earliest intrabar.
// @param tf                (string) The timeframe of the intrabars, specified in `timeframe.period` format.
// @returns                 (float) The value of the `src` series at the specified intrabar position, or `na` if the
//                          position is outside the range of available intrabars.
valueAtIntrabar(src, int bar, string tf) =>
    var int   barNo = 0
    var float value = na
    barNo := timeframe.change(tf) ? 1 : barNo + 1
    value := barNo == bar ? src : value

// Returns close to the last intrabar in "curTfInput" chart bar.
float lastClose = request.security(syminfo.tickerid, intraTfInput, close)
// Returns volume at "intraBarNoInput" intrabar.
float valueAtIntrabar = request.security(syminfo.tickerid, intraTfInput, valueAtIntrabar(volume, intraBarNoInput, curTfInput))
// Returns qty of "intraTfInput" intrabars in "curTfInput" chart bar.
int qtyIntrabars = request.security(syminfo.tickerid, intraTfInput, qtyIntrabars(curTfInput))

// Plot the last intrabar close, the volume of the 4th intrabar, and the quantity of intrabars per chart bar to the data window and chart pane.
plot(lastClose,       "lastClose",       display = display.data_window)
plot(valueAtIntrabar, "valueAtIntrabar", display = display.data_window)
plot(qtyIntrabars,    "qtyIntrabars")
```

:::warning[Notice!]
While scripts can use
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
to retrieve the values from a single intrabar on each chart bar, which
might provide utility in some unique cases, we recommend using the
[request.security_lower_tf()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security_lower_tf)
function for intrabar analysis when possible, as it returns an
[array](https://www.tradingview.com/pine-script-reference/v5/#type_array)
containing data from all available intrabars within a chart bar. See
[this section](/pine-script-docs/concepts/other-timeframes-and-data#request-security-lower-tf) to learn more.
:::

In this next example script, we achieve the same output as the first
script but without using its unsupported methods. Instead, we employ
`request.security_lower_tf()` to obtain arrays that hold data from all
available intrabars within each chart bar. By using array functions, we
can examine specific intrabars to retrieve values, count the total
number of intrabars, and identify the last intrabar value for each chart
bar. This approach allows us to bypass the need for the custom functions
utilized in the first script:

``` pine
//@version=5
indicator("Intrabar inspection using `request.security_lower_tf()`")

// An input to determine the intrabar number to find the value of.
int intraBarNoInput = input.int(4, minval = 1)
// Lower timeframe we are inspecting. Must be lower than the chart's timeframe.
string intraTfInput = input.timeframe("60", "Lower timeframe")

// Retrieve arrays containing the close prices and volume values for each lower timeframe intrabar within the current
// chart's bar, where each array element corresponds to a single intrabar.
array<float> ltfCloses = request.security_lower_tf(syminfo.tickerid, intraTfInput, close)
array<float> ltfVolume = request.security_lower_tf(syminfo.tickerid, intraTfInput, volume)
// Returns close to the last intrabar in "curTfInput" chart bar.
float lastClose = ltfCloses.last()
// Returns volume at "intraBarNoInput" intrabar.
float valueAtIntrabar = ltfVolume.size() > intraBarNoInput ? ltfVolume.get(intraBarNoInput - 1) : na
// Returns qty of "intraTfInput" intrabars in "curTfInput" chart bar.
int qtyIntrabars = ltfCloses.size()

// Plot the last intrabar close, the volume of the 4th intrabar, and the quantity of intrabars per chart bar to the data window and chart pane.
plot(lastClose,       "lastClose",       display = display.data_window)
plot(valueAtIntrabar, "valueAtIntrabar", display = display.data_window)
plot(qtyIntrabars,    "qtyIntrabars")
```

Note that:

    -   The current chart\'s timeframe does not need to be explicitly
        specified as an input when using
        [request.security_lower_tf()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security_lower_tf).
        Unlike the first example, where specifying the chart\'s
        timeframe was necessary, `request.security_lower_tf()`
        automatically identifies the chart\'s timeframe. This
        simplification eliminates the need for manual timeframe input.
    -   Since we receive each chart bar\'s data as an array of
        intrabars, we no longer need the specific functions that were
        designed for intrabar processing. This array enables us to
        conduct calculations directly on the entire dataset. For
        instance, rather than employing the `qtyIntrabars()` function
        from the first script to calculate the number of intrabars, we
        can determine this by simply evaluating the size of the array.

### Why do intraday OHLCV values not correspond to values retrieved with \`request.security()\` at daily timeframes and higher? 

The discrepancies between intraday OHLCV
([open](https://www.tradingview.com/pine-script-reference/v5/#var_open),
[high](https://www.tradingview.com/pine-script-reference/v5/#var_high),
[low](https://www.tradingview.com/pine-script-reference/v5/#var_low),
[close](https://www.tradingview.com/pine-script-reference/v5/#var_close),
[volume](https://www.tradingview.com/pine-script-reference/v5/#var_volume))
values and those retrieved with
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
at daily timeframes and higher can be attributed to a number of factors.
Here are a few of the most common:

-   **Different data feeds:** The volume data for some instruments might
    differ between intraday and EOD historical feeds. This discrepancy
    is due to certain trades (like block trades and OTC trades) only
    being recorded at the end of the trading day, affecting the EOD feed
    but not the intraday feed. While this issue is minimal for
    instruments like cryptocurrencies, it is more prevalent in stocks.
-   **Price discrepancies:** There may be slight differences in prices
    between EOD and intraday data. For example, an EOD high might not
    match any intraday highs due to variations in data feeds.
-   **Extended hours data:** EOD data feeds do not include information
    from trading outside regular hours, unlike some intraday feeds. For
    instance, the bars of an hourly chart might straddle the open of a
    session, blending data from pre-market and regular trading.

These factors explain why there can be variations in the values
retrieved, particularly when comparing intraday data with data retrieved
at daily or higher timeframes using `request.security()`. For an
extended list of factors with detailed explanations, refer to the
[Data feeds](/pine-script-docs/concepts/other-timeframes-and-data#data-feeds) section in the User Manual.

### How can I fetch the ATR value from a higher timeframe? 

To fetch the [Average True
Range](https://www.tradingview.com/support/solutions/43000501823-average-true-range-atr/)
(ATR) value from a higher timeframe, you can use the
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
function in Pine Script™. This function allows you to request data from
another context, such as a different symbol or timeframe.

Here is an example of how you can fetch the ATR value from a higher
timeframe:

``` pine
//@version=5
indicator("HTF ATR")
float higherTfAtr = request.security(syminfo.tickerid, "D", ta.atr(14))
plot(higherTfAtr)
```

In this example, `request.security()` is used to fetch the ATR value
from the daily (\"D\") timeframe. The
[ta.atr()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.atr)
function is used to calculate the Average True Range over 14 bars, which
is then passed to the `expression` argument of the `request.security()`
function, allowing the function to execute within the higher timeframe
context. The result is then plotted on the chart.

:::warning[Notice!]
The behavior of `request.security()` on historical and realtime bars is
not the same. On historical bars, new values come in at the close of the
last chart bar in the higher timeframe bar. In realtime, however,
`request.security()` will return the current value of the incomplete
higher timeframe bar, which causes it to vary on each chart bar,
resulting in [repainting](/pine-script-docs/concepts/repainting)
values.
:::

For methods to retrieve non-repainting higher timeframe values, see this
relevant
[FAQ entry](/pine-script-docs/faq#how-to-avoid-repainting-when-using-the-request-security-function), the
[Avoiding Repainting](/pine-script-docs/concepts/other-timeframes-and-data#avoiding-repainting) section, and the section on
`` Repainting \`request.security()\` calls <PageRepainting_HistoricalVsRealtimeCalculations_RepaintingRequestSecurityCalls> ``.

### How can I plot a moving average only when the chart's timeframe is 1D or higher? 

To conditionally plot a moving average on a chart with a timeframe of
daily (\"1D\") or higher, you can utilize the
[timeframe.in_seconds()](https://www.tradingview.com/pine-script-reference/v5/#fun_timeframe.in_seconds)
function. This function determines the chart\'s current timeframe by
converting it into seconds. Since a day consists of 86400 seconds, any
timeframe equal to or exceeding this value corresponds to a daily or
longer duration. Based on this, you can decide to plot the moving
average only if the chart\'s timeframe meets this criterion.

The example below demonstrates how to calculate and plot a [Simple
Moving
Average](https://www.tradingview.com/support/solutions/43000696841-simple-moving-average/)
(SMA) of the closing prices over the last 200 bars, but only on charts
that have a daily timeframe or longer:

``` pine
//@version=5
indicator("timeframe dependant MA", overlay = true)
bool tfIsDailyOrGreater = timeframe.in_seconds() >= 86400
float ma = ta.sma(close, 200)
plot(tfIsDailyOrGreater ? ma : na, "MA", color.aqua)
```

In this script, the `timeframe.in_seconds()` function checks the
chart\'s timeframe. If the timeframe is at least one day (86400 seconds
or more), the script calculates the simple moving average using the
[ta.sma()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.sma)
function. It then plots this moving average using the
[plot()](https://www.tradingview.com/pine-script-reference/v5/#fun_plot)
function. However, if the timeframe is shorter than one day, the script
uses a
[ternary operator](/pine-script-docs/language/operators#ternary-operator) to return
[na](https://www.tradingview.com/pine-script-reference/v5/#var_na),
effectively not plotting the moving average.

### How can I plot a moving average calculated using the 1H timeframe on any chart? 

Using the
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
function in Pine Script™, it\'s possible to access data from a different
context, such as a different symbol or timeframe. This capability is
particularly useful for incorporating data from other timeframes, such
as [Moving
Averages](https://www.tradingview.com/support/solutions/43000502589-moving-averages/)
(MA), into your scripts.

The following script is an illustration of how to implement this
functionality. It plots a 21-period [Exponential Moving
Average](https://www.tradingview.com/support/solutions/43000592270-exponential-moving-average/)
(EMA) derived from the 1-hour (1H) timeframe on any given chart,
irrespective of the original timeframe of that chart:

``` pine
//@version=5
indicator("1hr MA", overlay = true)
plot(request.security(syminfo.tickerid, "60", ta.ema(close, 21)), color = color.orange)
```

Although this example is simple and pulls data from other timeframes
regardless of the chart\'s timeframe, this method poses a number of
challenges. Particularly, there are a number of implications of calling
a timeframe lower than the chart\'s timeframe.

Key points to understand:

-   **Data granularity:** A chart\'s bars represent data aggregated over
    the chart\'s selected timeframe. For a Daily chart, each bar
    summarizes an entire day\'s worth of trading activity into single
    open, high, low, and close (OHLC) values.
-   **Plotting lower timeframe data:** When attempting to plot a 1H MA
    on a higher timeframe chart, you are constrained by the granularity
    of the chart\'s timeframe. This means that for each bar on a Daily
    timeframe, the chart can only plot a single value that represents
    the MA calculated from the 1H timeframe.
-   **Historical representation:** On historical bars, plotting a 1H MA
    on a Daily chart will only display the last MA value calculated for
    the final 1-hour bar of each day. This is because the data for each
    day is condensed into a single bar, and only one value can be
    represented. In realtime, the plot will display the most recently
    known value.
-   **Practical considerations:** While it\'s technically feasible to
    plot a 1H MA on a Daily chart, the utility of doing so is limited.
    The resulting plot will only provide the last 1H MA value for each
    day, missing out on the intraday fluctuations and trends that a 1H
    MA is typically used to identify.

:::warning[Notice!]
While scripts can use
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
to retrieve the values from a single intrabar on each chart bar, which
might provide utility in some unique cases, we recommend using the
[request.security_lower_tf()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security_lower_tf)
function for intrabar analysis when possible, as it returns an
[array](/pine-script-docs/language/arrays) containing data from
all available intrabars within a chart bar. See
[this section](/pine-script-docs/concepts/other-timeframes-and-data#request-security-lower-tf) to learn more.
:::

For an alternative, more logical approach, consider plotting MAs that
either align with the chart\'s timeframe or are calculated from a higher
timeframe onto a lower timeframe chart only. This strategy allows you to
visualize broader market trends within the context of shorter-term price
movements. For example, plotting a Daily MA on a 1H chart provides
insights into how intraday prices are trending relative to the
longer-term daily average.

Here, we plot the 21 MA calculated at the 1H timeframe, but only when
the chart's timeframe is equal to or lower than 1H. Due to the fact that
calculating the MA for a timeframe shorter than the chart\'s does not
yield meaningful results, we refrain from doing so in those instances:

``` pine
//@version=5
indicator("HTF MA", overlay = true)

// Provide inputs to specify the timeframe for `request.security() call and control over repainting of higher timeframe values.
string tfinput      = input.timeframe("60", "Timeframe for MA")
bool   repaintInput = input.bool(false,     "Repainting HTF values")

// @function            A wrapper for the `request.security()` function intended for calls to HTFs with repainting control.
// @param symbol        (simple string) Symbol.
// @param timeframe     (simple string) Timeframe of the requested data. To use the chart's timeframe, use an empty string
//                      or the `timeframe.period` variable.
// @param expression    (<any type>) An expression to be calculated and returned from the `request.security()` call's context.
// @param repaint       (simple bool) Condition to determine whether to use repainting data or not. Optional. Default is false.
// @returns             (any type) The result of `expression` calculated in the context of the `request.security()` call.
htfSecurity(simple string symbol, simple string timeframe, expression, repaint = false) =>
    int offset = repaint ? 0 : 1
    lookahead  = repaint ? barmerge.lookahead_off : barmerge.lookahead_on
    result     = request.security(symbol, timeframe, expression[offset], lookahead = lookahead)

// Calculate the MA and request the MA value from the specified `tfInput` timeframe.
float ma = ta.ema(close, 21)
float htfMA = htfSecurity(syminfo.tickerid, tfinput, ma, repaintInput)

// Create conditions to check if the requested timeframe is greater or less than the chart's timeframe.
bool tfIsGreater = timeframe.in_seconds() < timeframe.in_seconds(tfinput)
bool tfIsLess    = timeframe.in_seconds() > timeframe.in_seconds(tfinput)

// Determine the MA value to plot depending on the relationship of the requested timeframe to the chart's timeframe.
float maPlot = tfIsGreater ? htfMA : tfIsLess ? na : ma

// Plot the MA value.
plot(maPlot, "Requested MA", color.orange)

// Display a message in a table indicating that the requested timeframe is lower than the chart's timeframe, if applicable.
if barstate.islastconfirmedhistory and tfIsLess
    var table displayTable = table.new(position.bottom_right, 1, 1, color.new(color.yellow, 70))
    table.cell(displayTable, 0, 0, "Requested TF is lower than chart's TF\nNo MA displayed", text_color = color.red)
```

Note that:

    -   Due to the lack of granularity needed to display lower timeframe
        values in the detail needed to draw useful conclusions from it,
        we ensure to align the MA timeframe with the chart\'s timeframe
        or opt for higher timeframe MAs on lower timeframe charts.
    -   We use
        [timeframe.in_seconds()](https://www.tradingview.com/pine-script-reference/v5/#fun_timeframe.in_seconds)
        to determine the chart\'s timeframe and the timeframe of
        `tfInput` and create conditions that compare the two:
        -   When the chart\'s timeframe is shorter than the timeframe
            selected by the user, the plot is not displayed and is set
            to
            [na](https://www.tradingview.com/pine-script-reference/v5/#var_na).
            In this scenario, a message indicating this condition
            appears in a [table](/pine-script-docs/concepts/tables) located at the bottom right of the chart.
        -   If the chart\'s timeframe is equal to the timeframe selected
            by the user, we simply display the MA that is calculated
            within the chart\'s context, without using the value
            returned by `request.security()`.
        -   If the chart\'s timeframe is less than the requested
            timeframe, the script uses `request.security()` to pull the
            MA value from the higher timeframe.
    -   To manage calls to higher timeframes, the script uses a custom
        function, `htfSecurity()`, which is a wrapper for the
        `request.security()` function. This function introduces a
        repaint parameter, allowing users to control
        [repainting](/pine-script-docs/concepts/repainting) of
        higher timeframe (HTF) values:
        -   When `repaint` is set to false, the function sets the
            `lookahead` parameter to
            [barmerge.lookahead_on](https://www.tradingview.com/pine-script-reference/v5/#const_barmerge.lookahead_on)
            and adjusts the data offset by one bar to prevent
            repainting. This approach adheres to non-repainting methods
            outlined in the
            [Avoiding Repainting](/pine-script-docs/concepts/other-timeframes-and-data#avoiding-repainting) section of the User Manual.
        -   Conversely, setting `repaint` to true allows the function to
            utilize the default behavior of the `request.security()`
            function, which returns repainting results.

For detailed guidance on data requests from different contexts, please
consult the User Manual\'s following sections:

-   [Other Timeframes and Data](/pine-script-docs/concepts/other-timeframes-and-data)
-   `` \`request.security()\` <PageOtherTimeframesAndData_RequestSecurity> ``
-   [Avoiding Repainting](/pine-script-docs/concepts/other-timeframes-and-data#avoiding-repainting)
-   `` Repainting \`request.security()\` calls <PageRepainting_HistoricalVsRealtimeCalculations_RepaintingRequestSecurityCalls> ``

## Programming 

-   [What does scope mean?](/pine-script-docs/faq#what-does-scope-mean)
-   [How can I convert a script from one version to another?](/pine-script-docs/faq#how-can-iconvert-ascript-from-one-version-to-another)
-   [Can I access the source code of 'Invite-Only' or 'closed source' scripts?](/pine-script-docs/faq#can-iaccess-the-source-code-of-invite-only-or-closed-sorce-scripts)
-   [Is Pine Script™ an object-oriented language?](/pine-script-docs/faq#is-pine-script-an-object-oriented-language)
-   [How can I access the built-in indicators' source code?](/pine-script-docs/faq#how-can-iaccess-the-built-in-indicators-source-code)
-   [How can I examine the value of a string in my script?](/pine-script-docs/faq#how-can-iexamine-the-value-of-astring-in-my-script)
-   [How can I visualize my script's conditions on the chart?](/pine-script-docs/faq#how-can-ivisualize-my-scripts-conditions-on-the-chart)
-   [How can I make the console appear in the editor?](/pine-script-docs/faq#how-can-imake-the-console-appear-in-the-editor)
-   [How can I plot numeric values so that they do not disrupt the indicator's scale?](/pine-script-docs/faq#how-can-iplot-numeric-values-so-that-they-do-not-disrupt-the-indicators-scale)

### What does scope mean? 

Scope refers to the area within the code where a variable is defined and
can be accessed or referenced. It is categorized into two main types:
*global* and *local*.

-   **Global Scope:** Variables declared in a global scope can be
    accessed from any part of the code. They are defined outside all
    local scopes and function blocks.
-   **Local Scope:** On the contrary, variables defined in a local scope
    are only accessible within the specific local block or function
    where they are declared.

Some people might use the term \"local blocks\" interchangeably with
\"local scopes,\" but they convey the same concept. In Pine Script™, a
simple way to distinguish between global and local scope is by noticing
the indentation using a tab or four spaces, indicative of a local block.

Let\'s consider an example that demonstrates an error when trying to
access a locally scoped variable from a global context:

``` pine
//@version=5
indicator("Scope Demo")

// global scope
int globalValue = close > open ? 1 : -1

// local scope
if barstate.isconfirmed
    int localValue = close > open ? 1 : -1

plot(globalValue)
plot(localValue)
```

In this script, an \"Undeclared identifier\" error arises due to the
attempt to reference `localValue`, a locally scoped variable, from a
global perspective. This error occurs because `localValue` is only
acknowledged and accessible within the confines of its own local scope
where it is defined and remains unrecognizable in the global scope when
an attempt is made to plot its value.

To correct this, we can declare the variable in the global scope, thus
making it universally accessible in the script, and then conditionally
modify it within a local block:

``` pine
//@version=5
indicator("Scope demo")

// global scope
int globalValue = close > open ? 1 : -1
int localValue  = na

// local scope
if barstate.isconfirmed
    localValue := close > open ? 1 : -1

plot(globalValue, "Global", color.fuchsia, 6)
plot(localValue,  "Local",  chart.bg_color,  2)
```

For further reading and a more comprehensive understanding of scopes, we
recommend reading
[this](https://www.tradingview.com/pine-script-docs/en/v5/language/Script_structure.html#code)
relevant section in the Pine Script™ User Manual.

### How can I convert a script from one version to another? 

-   **Upgrading from version 1 to version 2 -** Version 1 of Pine
    Script™ served primarily as a beta release, and it is not used
    widely today due to its limited functionality. Given its lack of
    compatibility with subsequent versions, maintaining any v1 code in
    your script is not recommended. Instead, you should remove all v1
    code and start afresh with the more advanced versions.
-   **Upgrading from version 2 to version 3 -** The transition from v2
    to v3 is not as straightforward as in later versions due to the
    substantial changes in the script\'s structure. To successfully
    convert your code, it\'s recommended to consult a detailed
    conversion guide. Here\'s a
    [link to the conversion article](/pine-script-docs/to-pine-version3) that would provide you with helpful guidance.
-   **Upgrading from version 3 to version 4 or version 4 to version 5
    -** Click on the three dots to the right of the *Publish script*
    button, and you will see an option that says Convert to v4 or v5,
    depending on the current version of the script. Starting from
    version 3, this feature facilitates the automatic transition of your
    script to the next available version.

If you encounter challenges during script conversion, consider adopting
a brute force approach. This involves updating your script to the latest
version and addressing each error one by one, using the error messages
and `User Manual <IndexUserManual>` as
guidance. If issues persist, seek help on public forums, ensuring you
provide detailed information and relevant code related to your problem
for assistance from experienced programmers.

### Can I access the source code of \'Invite-Only\' or \'closed source\' scripts? 

Unfortunately, no. The term \"closed source\" is used to describe
scripts where the source code is permanently inaccessible to everyone
except the author. These scripts are created with the specific intention
of restricting public access to the source code.

\"Invite-Only\" scripts fall under the umbrella of \"closed source\"\',
but they include an additional restriction. While the source code
remains hidden, the application of these scripts to charts is possible,
but only for users who are on the creator\'s invite list. In essence,
\"Invite-Only\" scripts offer a level of exclusivity, allowing only
certain users to leverage the script on their charts while still keeping
the source code hidden.

Refer to the section on
[publishing scripts](/pine-script-docs/writing/publishing) in
the User Manual for further detail.

### Is Pine Script™ an object-oriented language? 

Although Pine Script™ doesn\'t officially qualify as an object-oriented
programming language, it has incorporated some object-oriented features.
One of these is the introduction of the
[type](https://www.tradingview.com/pine-script-reference/v5/#op_type)
keyword, which allows the creation of
[user-defined types](/pine-script-docs/language/type-system#user-defined-types) (UDTs). In Pine Script™, UDTs enable the creation of
[objects](/pine-script-docs/language/objects). These objects are
instances of the UDTs and act like variables comprising different
fields. Each of these fields can store individual values of various data
types.

It is worth noting that dealing with user-defined types is considered an
advanced topic within Pine Script™. Due to the complexity involved,
those new to programming or the language might find it challenging to
navigate.

Here is a straightforward example of how you can use the type keyword to
create an object in your script:

``` pine
//@version=5
indicator("My script")

// Define a new type named `point`.
type point
    int   x
    float y
    bool  isHigh

// Create a new `point` with specific values.
point newPoint = point.new(bar_index, close, true)

// Plot the `y` component of `newPoint`.
plot(newPoint.y)
```

In this example, we create an object `newPoint` which is an instance of
the user-defined type `point`. The script then plots the `y` field of
`newPoint`.

### How can I access the built-in indicators\' source code? 

To access the source code of the built-in indicators, you have two
options:

**Option 1:**

1.  Open the Pine Script™ Editor.
2.  Click on the \"*Open*\" menu.
3.  Choose the \"*New built-in script*\" option.
4.  Select the specific built-in indicator you want to work with.

**Option 2:**

1.  Add the desired built-in indicator to the chart view.
2.  While the indicator is displayed on the chart, click on the curly
    braces `{}` next to its name.
3.  This action will pull the code into the Pine Script™ Editor for
    further examination or modification.

When accessing the code of a built-in indicator, it\'s important to note
that you will encounter a read-only message. However, you can still
create a working copy of the code to make desired changes or
modifications by saving a copy of the code.

Please be aware that certain built-ins, such as the Volume Profile or
chart pattern indicators, are not written in Pine Script™. Consequently,
accessing the code for these indicators is not possible. As a result,
you won\'t find them available in the \"*New built-in script*\" menu,
nor will you see curly braces next to their names on the chart view.

### How can I examine the value of a string in my script? 

See this section of the Pine Script™ User Manual on
[debugging strings](/pine-script-docs/writing/debugging#strings).

The following code example demonstrates the use of a function to create
a chart label that will only appear on the last bar of your chart. This
is achieved through the `print()` function, which is defined to create
and update a label on the chart:

``` pine
//@version=5
indicator("print()", "", true)

print(string txt) =>
    // Create label on the first bar.
    var label lbl = label.new(bar_index, na, txt, xloc.bar_index, yloc.price, color(na), label.style_none, color.gray, size.large, text.align_left)
    // On next bars, update the label's x and y position, and the text it displays.
    label.set_xy(lbl, bar_index, ta.highest(10)[1])
    label.set_text(lbl, txt)

print("Multiplier = " + str.tostring(timeframe.multiplier) + "\nPeriod = " + timeframe.period + "\nHigh = " + str.tostring(high))
print("Hello world!\n\n\n\n")
```

![image](@assets/images/Programming-How-can-i-examine-the-value-of-a-string-in-my-script-1.png)

It\'s also worth noting that logging is now available in Pine Script™.
Pine Script™ `log.*()` functions display text in the new Pine Logs pane
as the script executes. The three new logging functions are:

-   [log.error()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.error)
    creates messages of type "Error" displayed in red.
-   [log.info()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.info)
    creates messages of type "Info" displayed in gray.
-   [log.warning()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.warning)
    creates messages of type "Warning" displayed in orange.

You can view Pine Logs by selecting "Pine Logs..." from the Editor's
"More" menu, or from the "More" menu of a script loaded on your chart if
it uses `log.*()` functions. See [this blog
post](https://www.tradingview.com/blog/en/pine-logs-in-pine-script-40490/)
for further detail.

### How can I visualize my script\'s conditions on the chart? 

See
[this](/pine-script-docs/writing/debugging#compound-and-nested-conditions) section of the Pine Script™ User Manual on debugging
compound conditions.

### How can I make the console appear in the editor? 

To display the console in the editor, you can use one of two methods:
press the keyboard shortcut CTRL + \` (grave accent), or right-click
within the editor and choose the \"Toggle Console\" option.

### How can I plot numeric values so that they do not disrupt the indicator\'s scale? 

See
[this](/pine-script-docs/writing/debugging#without-affecting-the-scale) section of the Pine Script™ User Manual on displaying
numeric values when the script's scale must be preserved.

Another strategy involves controlling the location where plot values are
displayed, which can be accomplished using the `display` parameter in
[plot()](https://www.tradingview.com/pine-script-reference/v5/#fun_plot)
function calls. You have the option to plot values in the data window
for purposes such as debugging or analyzing variable values, achieved
through using the
[display.data_window](https://www.tradingview.com/pine-script-reference/v5/#var_display.data_window)
constant.

As an illustration, let\'s look at a script that plots the RSI within
the indicator pane, while simultaneously plotting the
[bar_index](https://www.tradingview.com/pine-script-reference/v5/#var_bar_index)
in the data window. This approach ensures the scale of the RSI is not
disrupted:

``` pine
//@version=5
indicator("Data window demo")
plot(ta.rsi(close, 14), "RSI")
plot(bar_index, "Bar index", display = display.data_window)
```

## Strategies 

-   [Strategy basics](/pine-script-docs/faq#strategy-basics)
    -   [How can I turn my indicator into a strategy?](/pine-script-docs/faq#how-can-iturn-my-indicator-into-astrategy)
    -   [How do I set a stop loss?](/pine-script-docs/faq#how-do-iset-astop-loss)
    -   [How can I save the entry price in a strategy?](/pine-script-docs/faq#how-can-isave-the-entry-price-in-astrategy)
    -   [How do I implement date/time range filtering in strategies?](/pine-script-docs/faq#how-do-iimplement-date-time-range-filtering-in-strategies)
-   [Order execution and management](/pine-script-docs/faq#order-execution-and-management)
    -   [Why are my orders executed on the bar following my triggers?](/pine-script-docs/faq#why-are-my-orders-executed-on-the-bar-following-my-triggers)
    -   [How can I set up multiple take profit levels to gradually close out a position?](/pine-script-docs/faq#how-can-iset-up-multiple-take-profit-levels-to-gradually-close-out-aposition)
    -   [How can I execute a trade midway through a bar before it fully closes?](/pine-script-docs/faq#how-can-iexecute-atrade-midway-through-abar-before-it-fully-closes)
    -   [How can I set up a trade to exit during the same bar in which the entry occurred?](/pine-script-docs/faq#how-can-iset-up-atrade-to-exit-during-the-same-bar-in-which-the-entry-occured)
-   [Advanced order types and conditions](/pine-script-docs/faq#advanced-order-types-and-conditions)
    -   [How can I set a stop loss and take profit level as a percentage from my entry point?](/pine-script-docs/faq#how-can-iset-astop-loss-and-take-profit-level-as-apercentage-from-my-entry-point)
    -   [How do I move my stop loss to breakeven?](/pine-script-docs/faq#how-do-imove-my-stop-loss-to-breakeven)
    -   [How do I implement a trailing stop loss?](/pine-script-docs/faq#how-do-iimplement-atrailing-stop-loss)
    -   [How can I set a time-based condition to close out a position?](/pine-script-docs/faq#how-can-iset-atime-based-condition-to-close-out-aposition)
    -   [How can I configure a bracket order with a specific risk-to-reward (R:R) ratio?](/pine-script-docs/faq#how-can-iconfigure-abracekt-order-with-aspecific-risk-to-reward-rrratio)
    -   [How can I adjust my position size to ensure that I risk a fixed percentage of my equity?](/pine-script-docs/faq#how-can-iadjust-my-position-size-to-ensure-that-irisk-afixed-percentage-of-my-equity)
-   [Strategy optimization and testing](/pine-script-docs/faq#strategy-optimization-and-testing)
    -   [Why did my trade results change dramatically overnight?](/pine-script-docs/faq#why-did-my-trade-results-change-dramatically-overnight)
    -   [Why is backtesting on Heikin Ashi and other non-standard charts not recommended?](/pine-script-docs/faq#why-is-backtesting-on-heiken-ashi-and-other-non-standard-charts-not-recommended)
    -   [How can I backtest deeper into history?](/pine-script-docs/faq#how-can-ibacktest-deeper-into-history)
    -   [How do I backtest multiple symbols at once?](/pine-script-docs/faq#how-do-ibacktest-multiple-symbols-at-once)
    -   [What does Bar Magnifier do?](/pine-script-docs/faq#what-does-bar-magnifier-do)
-   [Advanced features and integration](/pine-script-docs/faq#advanced-features-and-integration)
    -   [Can my strategy script place orders with TradingView brokers?](/pine-script-docs/faq#can-my-strategy-script-place-orders-with-tradingview-brokers)
    -   [How can I implement a time delay between orders?](/pine-script-docs/faq#how-can-iimplement-atime-delay-between-orders)
    -   [How can I calculate custom statistics in a strategy?](/pine-script-docs/faq#how-can-icalculate-custom-statistics-in-astrategy)
    -   [How do I incorporate leverage into my strategy?](/pine-script-docs/faq#how-do-iincorporate-leverage-into-my-strategy)
    -   [Can you hedge in a Pine Script strategy?](/pine-script-docs/faq#can-you-hedge-in-apine-script-strategy)
    -   [Can I connect my strategies to my paper trading account?](/pine-script-docs/faq#can-iconnect-my-strategies-to-my-paper-trading-account)
-   [Troubleshooting and specific issues](/pine-script-docs/faq#troubleshooting-and-specific-issues)
    -   [Why are no trades executed after I added the strategy to the chart?](/pine-script-docs/faq#why-are-no-trades-executed-after-iadded-the-strategy-to-the-chart)
    -   [Why is my strategy repainting?](/pine-script-docs/faq#why-is-my-strategy-repainting)
    -   [How do I turn off alerts specifically for my stop loss and take profit orders?](/pine-script-docs/faq#how-do-iturn-off-alerts-specifically-for-my-stop-loss-and-take-profit-orders)

### Strategy basics 

#### How can I turn my indicator into a strategy? 

Pine Script™ strategies enable trades to be forward tested on realtime
data and simulated on historical data for backtesting of trading
systems. They are similar to Pine Script™ indicators but with added
capabilities such as placing, modifying, and canceling hypothetical
orders and analyzing their results. The key to transforming an indicator
into a strategy is to understand the fundamental concepts and
requirements of strategy scripts. This guide aims to lay down the
foundational elements of Pine Script™ strategies and outline some basic
steps to transform a script from an indicator into a strategy:

**Understanding Pine Script™ strategies:**

-   When a script uses the
    [strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
    function as its [declaration
    statement](https://www.tradingview.com/pine-script-docs/en/v5/language/Script_structure.html#declaration-statement),
    it gains access to the `strategy.*` namespace. This namespace
    provides functions and variables necessary for execution of virtual
    orders and accessing key strategy information.
-   Pine Script™ strategies support
    [various types](/pine-script-docs/concepts/strategies#order-types) of orders including market, limit, stop, and stop-limit
    orders, allowing users to simulate different trading scenarios.
-   When a strategy using
    [order placement commands](/pine-script-docs/concepts/strategies#order-placement-commands) is applied to the chart, it uses the
    [broker emulator](/pine-script-docs/concepts/strategies#broker-emulator) to calculate hypothetical trades and displays the
    results in the
    [Strategy Tester](/pine-script-docs/concepts/strategies#strategy-tester) tab.
-   Strategy order commands have built-in alert functionality called
    [order fill
    events](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Alerts.html#order-fill-events).
    An *order fill event* is triggered by the broker emulator when it
    executes a simulated order in realtime, mirroring the process of a
    trade order being filled in a real-world broker or exchange
    scenario. For more details, see our FAQ entry on
    [Using order fills in strategy() scripts](/pine-script-docs/faq#using-order-fills-in-strategy-scripts).
-   For a thorough exploration of strategy features, capabilities, and
    usage, users are encouraged to refer to the
    [Strategies](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Strategies.html#strategies)
    section in the User Manual. This provides an in-depth breakdown of
    all aspects related to Pine Script™ strategies.

**Converting an Indicator to a Strategy:**

1.  **Change declaration:** Begin by replacing the
    [indicator()](https://www.tradingview.com/pine-script-reference/v5/#fun_indicator)
    function in your script with the
    [strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
    declaration. This designates the script as a strategy, allowing it
    to incorporate order commands and activate the broker emulator for
    trade simulation.
2.  **Incorporate strategy order placement commands:** Add strategy
    [order functions](/pine-script-docs/concepts/strategies#order-placement-commands) for executing orders, dictating the type of orders to
    use and when to execute them.
3.  **Leverage indicator conditions for orders:** Utilize the conditions
    set in your original indicator to dictate when to call these
    strategy order functions. Essentially, the logic that drove the
    indicator's signals can now be repurposed to initiate trading orders
    in the strategy.

**Code example:**

Our code example includes two scripts: an initial indicator script and a
strategy script converted from the indicator. We utilize a simple RSI
oscillator as a momentum indicator to gauge the direction of a market\'s
momentum, with values above 50 indicating an upward (bullish) trend and
values below 50 signaling a downward (bearish) trend:

![image](@assets/images/Strategies-Strategy-basics-How-can-i-turn-my-indicator-into-a-strategy-1.png)

**Initial Indicator:**

``` pine
//@version=5
indicator("My RSI indicator")
float rsi = ta.rsi(close, 14)
plot(rsi, "RSI", rsi >= 50 ? color.lime : color.fuchsia)
hline(50, "Middle line", linestyle = hline.style_solid)
plotshape(ta.crossover(rsi,  50), "Cross up",   shape.arrowup,   location.bottom, color.lime)
plotshape(ta.crossunder(rsi, 50), "Cross Down", shape.arrowdown, location.top,    color.fuchsia)
barcolor(rsi >= 50 ? color.lime : color.fuchsia)
```

The indicator colors the plot line and the bars on the chart lime when
the RSI is greater than 50 and fuchsia when less than 50. We use
[plotshape()](https://www.tradingview.com/pine-script-reference/v5/#fun_plotshape)
to plot triangles at the top and bottom of the oscillator on bars where
the RSI crosses over or under the 50 level.

**Converted strategy:**

``` pine
//@version=5
strategy("My RSI strategy")
float rsi = ta.rsi(close, 14)
plot(rsi, "RSI", rsi >= 50 ? color.lime : color.fuchsia)
hline(50, "Middle line", linestyle = hline.style_solid)
plotshape(ta.crossover(rsi,  50), "Cross up",   shape.triangleup,   location.bottom, color.lime)
plotshape(ta.crossunder(rsi, 50), "Cross Down", shape.triangledown, location.top,    color.fuchsia)
barcolor(rsi >= 50 ? color.lime : color.fuchsia)

if ta.crossover(rsi,  50)
    strategy.entry("Long", strategy.long, comment = "Long")

if ta.crossunder(rsi,  50)
    strategy.entry("Short", strategy.short, comment = "Short")
```

In the converted strategy version, we maintain the same RSI crossover
and crossunder conditions used in the indicator script. These
conditions, which previously only drew the
[plotshape()](https://www.tradingview.com/pine-script-reference/v5/#fun_plotshape)
triangles, now also trigger entry orders for long and short positions
using the
[strategy.entry()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.entry)
function. A long entry is called when the RSI crosses over 50, and a
short entry is initiated when it crosses under 50. This demonstrates how
the logic driving the indicator\'s signals is integrated into trade
order executions in the strategy.

To successfully convert your indicator into a strategy, follow the steps
and conceptual guidelines outlined above. Choose
[order placement commands](/pine-script-docs/concepts/strategies#order-placement-commands) that align with your trading objectives, and apply them
based on the logic already established in your indicator.

#### How do I set a stop loss? 

In Pine Script™, the
[strategy.exit()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.exit)
function is key for implementing stop losses, a risk management method
used by traders to cap potential losses. This function allows you to set
an order to exit a trade once it hits a specified price, thus preventing
the loss from exceeding a predetermined level.

**Basic Usage:**

To implement a basic stop loss in Pine Script, use the `strategy.exit()`
function with either the `stop` or the `loss` parameter. The `stop`
parameter takes a specific price at which the stop loss is triggered,
while the `loss` parameter sets the stop loss a certain number of ticks
away from the entry order\'s price. Similarly, for setting a take-profit
level, you can use either the `limit` parameter, specifying the exact
price for taking profit, or the `profit` parameter, defining the profit
size in ticks from the entry price. For a comprehensive understanding of
the `strategy.exit()` function\'s parameters and functionality, consult
its entry in the [Reference
Manual](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.exit)
and the dedicated section in the
[User Manual](/pine-script-docs/concepts/strategies#strategy-exit).

It\'s important to note that you should use either a price-based
approach (`stop` for stop loss and `limit` for take profit) or a
tick-based approach (`loss` for stop loss and `profit` for take profit),
but not both in the same `strategy.exit()` call. If both types are
included, the function will prioritize the `stop` and `limit` parameters
over the `loss` and `profit` parameters, respectively.

In the following example script, we demonstrate the practical
application of both methodologies for setting stop losses in long and
short positions in a trading scenario:

![image](@assets/images/Strategies-Strategy-basics-How-do-i-set-a-stop-loss-1.png)

``` pine
//@version=5
strategy("Stop using `loss` and `stop`", overlay = true)

// Define an input for setting the stop loss size in ticks for long positions.
int lossTicksInput = input.int(60, "Long loss in ticks")
// Set a multiplier input for the Average True Range (ATR), used to calculate the stop loss level for short positions.
float atrMultInput = input.float(1.0, "ATR multiplier", minval = 0)

// Calculate two simple moving averages to determine entry conditions for trades.
float ma1 = ta.sma(close,  14)
float ma2 = ta.sma(close,  28)

// Calculate the ATR value, adjusted by the multiplier, for setting dynamic stop loss levels on short positions.
float atr = ta.atr(14) * atrMultInput

// Initialize a variable for the stop loss level for short positions that will persist from bar to bar.
// This level is updated based on short entry signals.
var float shortStopLevel = na

// Define conditions for entering long and short positions based on the crossover and crossunder of the two SMAs.
bool longCondition  = ta.crossover(ma1,  ma2)
bool shortCondition = ta.crossunder(ma1, ma2)

// On detecting a long condition, place a long entry.
// For a short condition, place a short entry and set the stop loss level by adding the ATR value to the closing price.
if longCondition
    strategy.entry("Long", strategy.long)

if shortCondition
    strategy.entry("Short", strategy.short)
    shortStopLevel := close + atr

// Apply a fixed-size stop loss for long positions using the specified input tick size in the `loss` parameter.
strategy.exit(id = "Long Exit",  from_entry = "Long",  loss = lossTicksInput)
// For short positions, set the stop loss at the calculated price level using the `stop` parameter.
strategy.exit(id = "Short Exit", from_entry = "Short", stop = shortStopLevel)

// Calculate and plot the actual price level at which the stop loss for long positions will trigger.
// The stop level is derived by subtracting the loss size (in price value) from the average entry price.
// For both plots, set the value to `na` when the respective long or short position is not active.
float longStopPlot  = strategy.position_size > 0 ? strategy.position_avg_price - lossTicksInput * syminfo.mintick : na
float shortStopPlot = strategy.position_size < 0 ? shortStopLevel : na
// Plot the moving averages and stop loss levels for visual reference.
plot(ma1, "MA 1", color.new(color.lime,    50))
plot(ma2, "MA 2", color.new(color.fuchsia, 50))
plot(longStopPlot,  "Long Stop",  color.red, style = plot.style_steplinebr)
plot(shortStopPlot, "Short Stop", color.red, style = plot.style_steplinebr)
// Color the background to visually indicate when long or short conditions are met.
bgcolor(longCondition ? color.new(color.aqua, 80) : shortCondition ? color.new(color.orange, 90) : na)
```

The script uses the tick-based approach for long positions, utilizing
the number of ticks specified in the `loss` parameter to set the stop
loss. Conversely, for short positions, we adopt the price-based
approach. Here, the script calculates the stop loss level by adding the
[Average True Range
(ATR)](https://www.tradingview.com/support/solutions/43000501823-average-true-range-atr/)
value to the closing price of the condition bar, using this calculated
price in the `stop` parameter. Position entries are triggered by the
crossover or crossunder of two simple moving averages. We plot the stop
loss values on the chart to illustrate the level at which the stop will
trigger on each bar the trade progresses.

:::warning[Notice!]
In this example, we use the `from_entry` argument in the
`strategy.exit()` function to link each exit order to its corresponding
entry ID. This designation ensures that each exit order is executed only
when there is an open position associated with that specific entry name.
:::

**Advanced usage:**

For more advanced implementations, consider experimenting with the
following concepts, each linked to a corresponding FAQ entry:

1.  **Implementing bracket orders:** To create bracket orders, combine
    both stop-loss and take-profit orders within a single
    `strategy.exit()` function call. This method ensures simultaneous
    management of both orders. See the FAQ on `Bracket
    Orders <PageFaq_Strategies_AdvancedOrderTypesAndConditions_HowCanIConfigureABracektOrderWithASpecificRiskToRewardRRRatio>` for more details.
2.  **Setting up a trailing stop loss:** There are two methods to create
    a trailing stop loss. The first method involves manually adjusting
    the stop price higher with each new bar. The second method utilizes
    the built-in trailing stop parameters available in the
    `strategy.exit()` function. Refer to the FAQ on implementing a
    [trailing stop loss](/pine-script-docs/faq#how-do-iimplement-atrailing-stop-loss) for further guidance.
3.  **Creating scaled exits at different prices:** For executing exits
    at varied price levels, use multiple exit orders. This approach
    allows for tiered exit strategies that progressively scale out of a
    position. However, it\'s crucial to ensure that the cumulative
    quantity of all exit orders does not surpass the size of the initial
    entry position. Consult the FAQ on
    [multiple exits](/pine-script-docs/faq#how-can-iset-up-multiple-take-profit-levels-to-gradually-close-out-aposition) for more information.
4.  **Moving a stop loss to breakeven:** Adjust your stop loss to the
    breakeven point once a specific condition is met. This tactic helps
    in risk management. Details can be found in the FAQ on
    [moving stop losses to breakeven](/pine-script-docs/faq#how-do-imove-my-stop-loss-to-breakeven).
5.  **Adjusting position size based on stop loss:** Modify your position
    size relative to your stop loss to maintain a constant risk
    percentage of your total equity. This strategy is useful for
    managing a consistent level of risk for each trade. For more
    insights, see the FAQ on
    [position sizing](/pine-script-docs/faq#how-can-iadjust-my-position-size-to-ensure-that-irisk-afixed-percentage-of-my-equity).

#### How can I save the entry price in a strategy? 

To record the entry price in a Pine Script™ strategy, there are two main
approaches:

**Utilizing the strategy.position_avg_price variable:**

-   The
    [strategy.position_avg_price](https://www.tradingview.com/pine-script-reference/v5/#var_strategy.position_avg_price)
    variable automatically provides the average entry price of your
    current position.
-   It updates dynamically with each new entry, reflecting the combined
    average price of all entries.
-   When implementing strategies that involve multiple entries or
    pyramiding, it is important to consider the implications of
    [closing a market position](/pine-script-docs/concepts/strategies#closing-amarket-position), particularly when trades are exited individually. The
    `strategy.position_avg_price` variable returns the average of all
    remaining open trades. By default, trades are closed following the
    FIFO (First In, First Out) method, meaning they are closed in the
    order they were opened. This default behavior could result in an
    unexpected average entry price, which might lead to inaccuracies in
    subsequent entry price-related calculations.
-   You can specify the order trades are closed using the
    `close_entries_rule` parameter of the
    [strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
    declaration function.

**Creating a custom variable for entry price:**

-   Declare a user-defined variable with
    [var](/pine-script-docs/language/variable-declarations#var)
    to store the entry price. Variables declared with `var` retain their
    values from bar to bar.
-   Update this variable with the opening price of the bar that occurs
    when a new entry is made.
-   This approach ensures you have the precise entry price for each new
    trade. It can also be adapted to track only the first entry price in
    a series of trades opened in the same direction, which may be more
    useful for calculations related to the entry price.

Here\'s an example script illustrating both methods:

``` pine
//@version=5
strategy("Plot Entry Price", overlay = true)

// Calculate two simple moving averages to determine entry conditions for trades.
float ma1 = ta.sma(close,  14)
float ma2 = ta.sma(close,  28)

// Define conditions for entering long and short positions based on the crossover and crossunder of the two SMAs.
bool longCondition  = ta.crossover(ma1,  ma2)
bool shortCondition = ta.crossunder(ma1, ma2)

// On detecting entry conditions, place an order to enter a position.
if longCondition
    strategy.entry("Long", strategy.long)
if shortCondition
    strategy.entry("Short", strategy.short)

// ————— Method 1: wait until bar following order and use its `open`.
var float entryPrice = na
if longCondition[1] or shortCondition[1]
    entryPrice := open
plot(entryPrice, "Method 1", chart.fg_color, 3, plot.style_circles)

// ————— Method 2: use built-in variable.
plot(strategy.position_avg_price, "Method 2", chart.bg_color, 2, plot.style_circles)
```

This script visually compares both methods. Method 1 uses a custom
variable assigned to the open price of the entry bar, and Method 2 uses
the built-in `strategy.position_avg_price` variable. The plots are
displayed with different widths and colors for easy comparison.

For more information on using entry prices in calculations, such as
setting exit prices at a specific percentage from the entry price, refer
to
[this](/pine-script-docs/faq#how-can-iset-astop-loss-and-take-profit-level-as-apercentage-from-my-entry-point) FAQ question.

#### How do I implement date/time range filtering in strategies? 

In Pine Script™, incorporating date and time range filters into your
strategy can be used to focus your trades during specific periods. Such
an approach could be useful in various scenarios:

1.  **Backtesting:** Limit trades to a specified date range to focus on
    historical market behaviors in a given time window or sample only
    portions of available history at a time.
2.  **Session times:** Restrict trading activity to particular times of
    day to avoid high or low volatility hours. For instance, to address
    low volatility periods, you might choose to exclude early morning
    hours when market activity is typically low, thus focusing signals
    to times when trading is more consistent.
3.  **Broker Emulator synchronization:** When configuring alerts for
    [executing real trades](/pine-script-docs/faq#can-my-pine-strategy-or-indicator-place-automated-orders-in-markets), initiate the date filter\'s start date to today\'s
    date. This approach excludes historical trades from the broker
    emulator\'s calculations, and any impact they had on current
    positions, trade sizes, and available capital. By doing so, you
    ensure the broker emulator is in a neutral state at the time your
    alert begins to run on the server.

There are two primary types of time-based filtering commonly employed in
strategies:

-   **Date window filtering:** This involves restricting trades to a
    specific period by setting a *to* and *from* date. The strategy will
    only execute trades within this predefined date range.
-   **Intraday time filtering:** This type of filtering limits trades to
    certain times of the day, useful specifically for intraday trading.
    It allows traders to target periods of the day that align with their
    trading strategy, such as high-activity hours or times when market
    volatility suits their risk profile.

To implement these filters in Pine Script™, create conditions based on
time and integrate them with trading signals. For instance, a condition
could check if the current chart bar is within a certain *start* and
*end* date. This is then coupled with the strategy's trading conditions,
ensuring trades only occur when both time and trading criteria are met.

In our script example, we create a custom function
`timeWithinAllowedRange()` that validates if a bar falls within a
defined `startTime` and `endTime`, or outside of an optional intraday
session window. The function\'s return value is linked to the signal
conditions, thus restricting trading to the times permitted by the
function.

In the snapshot below we demonstrate filtering signals between a start
and end date, as well as ignoring trades during the first hour of
trading of each day.

![image](@assets/images/Strategies-Strategy-basics-How-do-i-implement-date-time-range-filtering-in-strategies-1.png)

``` pine
//@version=5
indicator("Date/time filtering demo", "", true)

// Time zone setting for date and time calculations. Adjust to your time zone to align times with your chart's time scale.
string TZ = "GMT+0"

// Create user inputs for defining a date window, an intraday time session to exclude, and the types of filtering to apply.
bool   useDateFilterInput = input.bool(true, "Allow trades only between dates (" + TZ + ")") 
int    startTimeInput     = input.time(timestamp("01 Jan 2000 00:00 " + TZ), "  Start date")     
int    endTimeInput       = input.time(timestamp("01 Jan 2099 00:00 " + TZ), "  End date")
bool   useTimeFilterInput = input.bool(false, "Use time session to ignore trades (" + TZ + ")") 
string sessionStringInput = input.session("0000-0300", "")          


// @function                Determines whether the current bar falls within a specified date and time range, based on optional filters.
// @param startTime         (int) A timestamp marking the start of the allowable time window.
// @param endTime           (int) A timestamp marking the end of the allowable time window.
// @param useDateFilter     (bool) Specifies whether to filter based on the date range between `startTime` and `endTime`.
//                          Optional. Default is `true`.
// @param useTimeFilter     (bool) Specifies whether to ignore the time session defined by `timeSession` and `timeZone`.
//                          Optional. Default is `false`.
// @param timeSession       (string) Session time range in 'HHMM-HHMM' format, used if `useTimeFilter` is true.
//                          Optional. Default is "0000-0000".
// @param timeZone          (string) Time zone for the session time, used if `useTimeFilter` is true.
//                          Optional. Default is "GMT-0".
// @returns                 (bool) `true` if the current bar is within the specified date and/or time range.
timeWithinAllowedRange(
     int    startTime, int endTime,
     bool   useDateFilter = true,
     bool   useTimeFilter = false,
     string timeSession   = "0000-0000",
     string timeZone      = "GMT-0"
     ) =>
    bool isOutsideTime = na(time(timeframe.period, timeSession, timeZone))
    bool timeIsAllowed = useTimeFilter and isOutsideTime or not useTimeFilter
    bool dateIsAllowed = time >= startTime and time <= endTime or not useDateFilter
    bool result        = timeIsAllowed and dateIsAllowed

// Determine if each bar falls within the date window or outside the ignored time session using `timeWithinAllowedRange()`.
bool isWithinTime = timeWithinAllowedRange(
 startTimeInput, endTimeInput, useDateFilterInput, useTimeFilterInput, sessionStringInput, TZ
 )

// Calculate RSI for simple trading signals.
float rsi = ta.rsi(close,  14)
// Generate trading signals based on RSI conditions, provided they occur within the permissible date/time range.
bool enterLong  = ta.crossover(rsi,  50) and isWithinTime
bool enterShort = ta.crossunder(rsi, 50) and isWithinTime
// Plot trading signals as arrows on the chart, their presence restricted by the date/time filtering criteria.
plotchar(enterLong,  "enterLong",  "▲", location.belowbar, color.lime)
plotchar(enterShort, "enterShort", "▼", location.abovebar, color.fuchsia)
// Color the background red for bars falling outside the specified date/time range.
bgcolor(isWithinTime ? na : color.new(color.red, 80), title = "Exempt times")
```

**In our script we:**

-   Create `timeWithinAllowedRange()`, a custom function that assesses
    if the current bar is within a specified date range and, optionally,
    outside a designated time session. It returns `true` when both
    conditions are met.
-   Define input options to provide arguments to the
    `timeWithinAllowedRange()` function. These inputs include a start
    and end time for defining the date range, an input for specifying
    the optional session window, and checkboxes for enabling or
    disabling the date and time filters.
-   Within the `timeWithinAllowedRange()` function, we employ the
    [time()](https://www.tradingview.com/pine-script-reference/v5/#fun_time)
    function to ascertain whether bars are outside the user-defined
    session times. For additional details on integrating session data in
    Pine Script™, refer to the
    [Sessions](/pine-script-docs/concepts/sessions) section in
    the User Manual.
-   Link the output of the `timeWithinAllowedRange()` function with our
    trading signals. Utilizing a basic RSI strategy that triggers
    signals when the RSI crosses over or under 50, we integrate the time
    condition from the function. Consequently, a trading signal is only
    activated when a bar meets the RSI criteria and simultaneously falls
    within the specified start and end time range and outside the
    optional session designated for ignoring trades.
-   Color the background
    [red](https://www.tradingview.com/pine-script-reference/v5/#var_color.red)
    for bars that fall outside the allowable time windows, visually
    distinguishing periods when trading is restricted.

:::warning[Notice!]
We use a constant variable `TZ` in our script for the timezone (set to
`"GMT+0"` by default). Adjust this to your local time zone or the
exchange\'s time zone to ensure the chart\'s times align with user
settings.
:::

### Order execution and management 

#### Why are my orders executed on the bar following my triggers? 

When using Pine Script™ [strategies](/pine-script-docs/concepts/strategies), it\'s common for traders to notice their orders being
executed on the bar following their trigger conditions. This behavior is
rooted in the default settings of the strategy execution model. To
understand this, here is a breakdown of the key concepts:

**Execution on the close of the bar:**

-   Each historical bar in a chart is composed of a single set of
    [open](https://www.tradingview.com/pine-script-reference/v5/#var_open),
    [high](https://www.tradingview.com/pine-script-reference/v5/#var_high),
    [low](https://www.tradingview.com/pine-script-reference/v5/#var_low)
    or
    [close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
    (OHLC) data. Consequently, Pine Script™ is designed to execute once
    per historical bar, based on this single set of data.
-   Each execution happens once at the close of the bar. Because there
    is only one set of data per bar, the script evaluates the conditions
    at the end of each bar.
-   To maintain consistent behavior between realtime and historical
    data, strategies continue to execute at the close of each bar in
    realtime by default. This approach aligns calculations made on
    historical data with those made on fluctuating price updates in
    realtime by waiting until the price is stable at the close of the
    bar, which minimizes [repainting](/pine-script-docs/concepts/repainting).
-   **Since strategies execute at the close of a bar, the next possible
    moment for an order to be filled is the beginning of the next bar.**
    Therefore, by default, the broker emulator simulates order fills at
    the opening price of the bar immediately after the bar where the
    entry condition was met.

**Modifying execution timing:**

Although the default strategy behavior simulates order fills at the open
of the bar following the signal, traders can change this behavior by
enabling the
[process_orders_on_close](/pine-script-docs/concepts/strategies#process-orders-on-close) setting. By setting this parameter to `true`, the broker
emulator uses the close value of the signal bar in order fill
calculations. However, it\'s important to recognize that **this setting
is for theoretical analysis only and may not reflect realtime trading
realities.** For instance, if an alert occurs at the close of the
session\'s last bar, the actual order would be executed only on the next
trading day, since the bar is already closed. In contrast, the emulator
would simulate the order being filled at the previous day\'s close. This
discrepancy can lead to repainting, where the behavior of the
strategy\'s simulation on historical bars differs from that seen in live
trading.

To enable the `process_orders_on_close` setting, you can select it at
the bottom of a strategies *Properties* tab in the settings UI, or you
can specify the argument in the
[strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
declaration statement:

``` pine
//@version=5
strategy("My Strategy", process_orders_on_close = true, ...)
```

In summary, the default strategy behavior simulates orders at the close
of each bar, meaning that the earliest opportunity to fill the orders
and execute strategy calculations and alerts is upon the opening of the
following bar. You can
[alter a strategy's calculation behavior](/pine-script-docs/concepts/strategies#altering-calculation-behavior) by enabling the `process_orders_on_close` setting, but be
aware that it may produce results not achievable in realtime, which
could give an unrealistic impression of the strategy\'s performance.

#### How can I set up multiple take profit levels to gradually close out a position? 

Setting up a strategy with multiple take profit levels enables a trader
to exit a position gradually at different price points. This approach is
effective for scaling out of trades in segments to secure profits
incrementally. There are two main methods for scaling out at varying
levels in Pine Script™:

1.  Using multiple
    `` \`strategy.exit()\` <PageStrategies_OrdersAndEntries_OrderPlacementCommands_StrategyExit> `` calls. This method is most suitable when you have
    distinct stop-loss levels for each exit.
2.  Utilizing an
    [OCA reduce group](/pine-script-docs/concepts/strategies#strategy-ocareduce). This method is ideal when you have a non-uniform number
    of take-profit and stops.

**Method 1:** Multiple `strategy.exit()` functions

The first method involves using multiple
[strategy.exit()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.exit)
calls. Each call sets up an individual bracket order for a specific take
profit and stop-loss level. This method is particularly useful when each
take profit level is paired with a distinct stop-loss level. For
example, you can implement two take profit levels and corresponding stop
loss levels by calling the `strategy.exit()` function twice, each with
different stop and limit prices. However, if you use multiple
`strategy.exit()` functions with the same stop level, each function call
will trigger a separate order. This can be an issue, especially if you
rely on alerts to manage
[third-party order executions](/pine-script-docs/faq#can-my-pine-strategy-or-indicator-place-automated-orders-in-markets), as each order at the stop level would generate a separate
alert. If your strategy requires multiple take profit levels but only
one stop level for each position, you should adopt a different method,
like method 2, which better accommodates this requirement.

![image](@assets/images/Strategies-Order-execution-and-management-How-can-i-set-up-multiple-take-profit-levels-to-gradually-close-out-a-position-1.png)

``` pine
//@version=5
strategy("Multiple exit demo", "test", overlay = true)

//@variable Is `true` on every 100th bar.
bool buyCondition = bar_index % 100 == 0

//@variable Stop-loss price for "exit1" commands.
var float stopLoss1 = na
//@variable Stop-loss price for "exit2" commands.
var float stopLoss2 = na
//@variable Take-profit price for "exit1" commands.
var float takeProfit1 = na
//@variable Take-profit price for "exit2" commands.
var float takeProfit2 = na

// Place orders upon `buyCondition`.
if buyCondition and strategy.position_size == 0.0
    stopLoss1   := close * 0.99
    stopLoss2   := close * 0.98
    takeProfit1 := close * 1.01
    takeProfit2 := close * 1.02
    strategy.entry("buy", strategy.long, qty = 2)
    strategy.exit("exit1", "buy", stop = stopLoss1, limit = takeProfit1, qty_percent = 50)
    strategy.exit("exit2", "buy", stop = stopLoss2, limit = takeProfit2)

// Set `stopLoss1` and `takeProfit1` to `na` when price touches either.
if low <= stopLoss1 or high >= takeProfit1
    stopLoss1   := na
    takeProfit1 := na
// Set `stopLoss2` and `takeProfit2` to `na` when price touches either.
if low <= stopLoss2 or high >= takeProfit2
    stopLoss2   := na
    takeProfit2 := na

plot(stopLoss1,   "SL1", color.red,   style = plot.style_circles)
plot(stopLoss2,   "SL2", color.red,   style = plot.style_circles)
plot(takeProfit1, "TP1", color.green, style = plot.style_circles)
plot(takeProfit2, "TP2", color.green, style = plot.style_circles)
```

In this example, two separate `strategy.exit()` functions are used. Each
function has its own stop-loss and take-profit levels. The quantity for
the first bracket order is set to 50% of the total position size,
allowing for a scaled exit with distinct stop levels.

**Method 2:** Using OCA Reduce Group

Here, an [OCA group](/pine-script-docs/concepts/strategies#ocagroups) ensures that only one stop order is used to close out the
remaining position. When one limit order from the group is filled, the
quantity of the remaining orders is reduced accordingly. This method is
ideal when you have an unequal number of take-profit levels to stops. In
this example, we use two take-profit levels but only one stop level:

![image](@assets/images/Strategies-Order-execution-and-management-How-can-i-set-up-multiple-take-profit-levels-to-gradually-close-out-a-position-2.png)

``` pine
//@version=5
strategy("Multiple TP, one stop demo", overlay = true)

var float stop   = na
var float limit1 = na
var float limit2 = na

//@variable Is `true` on every 100th bar.
bool buyCondition = bar_index % 100 == 0

// Place orders upon `buyCondition`.
// We place 3 sell orders in the "Bracket" OCA group; filling one reduces qty of remaining orders.
if buyCondition and strategy.position_size == 0
    stop   := close * 0.99
    limit1 := close * 1.01
    limit2 := close * 1.02
    strategy.entry("Long",    strategy.long, 6)
    strategy.order("Stop",    strategy.short, stop  = stop,   qty = 6, oca_name = "Bracket", oca_type = strategy.oca.reduce)
    strategy.order("Limit 1", strategy.short, limit = limit1, qty = 3, oca_name = "Bracket", oca_type = strategy.oca.reduce)
    strategy.order("Limit 2", strategy.short, limit = limit2, qty = 6, oca_name = "Bracket", oca_type = strategy.oca.reduce)

// Set `limit1` to `na` when price exceeds it.
if high >= limit1
    limit1 := na
// Set `stop`, `limit11`, and `limit2` to `na` when price surpasses either the last take-profit, or the stop.
if low <= stop or high >= limit2
    stop   := na
    limit1 := na
    limit2 := na

plot(stop,   "Stop",    color.red,   style = plot.style_linebr)
plot(limit1, "Limit 1", color.green, style = plot.style_linebr)
plot(limit2, "Limit 2", color.green, style = plot.style_linebr)
```

In this script, the `oca_name` and `oca_type = strategy.oca.reduce`
settings ensure that filling one of the limit orders reduces the
quantity of the remaining orders. The total quantity of the exit orders
matches the entry order quantity, preventing the strategy from trading
an excessive number of units and causing a reversal.

:::warning[Notice!]
When using an OCA reduce group, ensure the sum of the quantities for all
exit orders, after any reductions, matches the initial entry order\'s
quantity. This guarantees that the position is fully closed out without
leaving any part of the position open or inadvertently opening a new
position in the opposite direction.
:::

#### How can I execute a trade midway through a bar before it fully closes? 

Executing a trade midway through a bar in Pine Script™ presents unique
challenges, especially when distinguishing between historical and
realtime data. The answer is rooted in understanding the fundamental
differences between how Pine Script™ handles historical data versus
realtime data, and the Pine Script™
[execution model](/pine-script-docs/language/execution-model).

**Historical bars and realtime data:**

-   **Historical bars:**

    On [historical
    bars](https://www.tradingview.com/pine-script-docs/en/v5/language/Execution_model.html#calculation-based-on-historical-bars),
    Pine Script™ only has access to a single set of
    [open](https://www.tradingview.com/pine-script-reference/v5/#var_open),
    [high](https://www.tradingview.com/pine-script-reference/v5/#var_high),
    [low](https://www.tradingview.com/pine-script-reference/v5/#var_low)
    or
    [close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
    (OHLC) data per bar. Consequently, strategies are calculated once at
    the close of each bar. This limitation means it\'s not possible to
    identify and act on conditions, like a price cross, that occur
    mid-bar on historical data as the condition will be evaluated at the
    close of the bar. Ultimately, processing conditions mid-bar on
    historical data would require tick data, a granularity of data not
    available on TradingView.

-   **Realtime data:**

    In [realtime
    trading](https://www.tradingview.com/pine-script-docs/en/v5/language/Execution_model.html#calculation-based-on-realtime-bars),
    you can achieve mid-bar execution by setting the strategy to
    calculate on every tick
    ([calc_on_every_tick](/pine-script-docs/concepts/strategies#calc-on-every-tick)). This setting allows the strategy to process each
    incoming price update and execute trades on the next tick when
    conditions like a price cross occur.

**Note on repainting:**

When you set your strategy to calculate on every tick, it introduces
[repainting](/pine-script-docs/concepts/repainting). This is
because such behavior, while achievable in realtime and for alerts, will
not be reflected in historical calculations when you reload the chart.
It\'s important to be aware of this potential discrepancy, as it can
affect how your strategy appears to perform historically versus in live
trading conditions: Repainting ultimately invalidates the results the
backtest provides.

**Alternative method without calc_on_every_tick:**

To execute an exit mid-bar without relying on `calc_on_every_tick`, you
can use *stop* or *limit* orders at predefined prices. For instance,
using
[strategy.exit()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.exit)
with the `stop` and `limit` arguments allows you to specify exact prices
for taking profit or stopping a loss. This method is effective on both
historical and realtime data, providing a consistent approach to exiting
trades at specific price levels before a bar fully closes:

![image](@assets/images/Strategies-Order-execution-and-management-How-can-i-execute-a-trade-midway-through-a-bar-before-it-fully-closes-1.png)

``` pine
//@version=5
strategy("Exit demo", overlay = true)

//@variable Is `true` on every 100th bar.
bool buyCondition = bar_index % 100 == 0

//@variable Stop-loss price for exit commands.
var float stopLoss   = na
//@variable Take-profit price for exit commands.
var float takeProfit = na

// Place orders upon `buyCondition`.
if buyCondition and strategy.position_size == 0.0
    stopLoss   := close * 0.99
    takeProfit := close * 1.01
    strategy.entry("buy", strategy.long)
    strategy.exit("exit", "buy", stop = stopLoss, limit = takeProfit)

// Set `stopLoss` and `takeProfit` to `na` when price touches either, i.e., when the strategy simulates an exit.
if low <= stopLoss or high >= takeProfit
    stopLoss   := na
    takeProfit := na

plot(stopLoss,   "SL", color.red,   style = plot.style_linebr)
plot(takeProfit, "TP", color.green, style = plot.style_linebr)
```

In this script, we use *stop* and *limit* orders to exit a trade
mid-bar. The `strategy.exit()` function is set with `stop` and `limit`
parameters, determining the specific price levels at which the trade
will exit.

Executing trades midway through a bar in Pine Script™ requires
understanding the distinction between historical and realtime data
processing. While `calc_on_every_tick` enables realtime mid-bar
execution, it comes with the caveat of repainting results because any
condition can only be evaluated at the close of historical bars.
Alternatively, using *stop* or *limit* orders provides a consistent
method for both historical and realtime scenarios, but you must specify
the prices for the exit order ahead of time.

#### How can I set up a trade to exit during the same bar in which the entry occurred? 

In Pine Script™, traders sometimes seek to execute a trade exit within
the same bar as the entry, especially for strategies where trades are
intended to be short-lived. This can be accomplished through two main
methods:

**Method 1:** Specifying exit prices

One approach involves setting predetermined exit prices at the time of
trade entry. This method typically uses stop-loss or take-profit orders
to automatically trigger an exit when certain price levels are reached.
For example, in a script where a buy condition is met, the strategy
could simultaneously enter a position and define exit conditions based
on specific profit and loss levels:

``` pine
//@version=5
strategy("Exit on entry bar", overlay = true)

//@variable Is `true` on every 100th bar.
bool buyCondition = bar_index % 10 == 0

// Place orders upon `buyCondition`.
if buyCondition and strategy.position_size == 0.0
    strategy.entry("buy", strategy.long)
    strategy.exit("exit", "buy", profit = 10, loss = 10)
```

Here, the trade will exit within the same bar if the price hits either
of the defined profit or loss levels. It\'s worth pointing out there is
no guarantee the exits will occur within the entry bar. While setting
small profit and loss values aims to increase the likelihood of
triggering an exit within the entry bar, it\'s important to acknowledge
that there\'s no absolute guarantee of this occurring.

**Method 2:** Market order at bar close

Another method is to use a market order at the bar\'s close. This is
done by setting the `immediately` argument to `true` in the
[strategy.close()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.close)
function:

``` pine
//@version=5
strategy("Exit on entry bar", overlay = true)

//@variable Is `true` on every 100th bar.
bool buyCondition = bar_index % 10 == 0

// Place orders upon `buyCondition`.
if buyCondition and strategy.position_size == 0.0
    strategy.entry("buy", strategy.long)

strategy.close("buy", immediately = true)
```

In this scenario, if the buy order is opened, the strategy will close
the position at the end of the entry bar. This method is contingent on
Pine Script\'s strategy execution model, which processes scripts once
per bar by default. Consequently, the trade will exit at the end of the
bar in which the entry occurred, once the \"buy\" order is active. Note
that if needed, the `strategy.close()` function can be called
conditionally within a local block if necessary. However, for
illustrative reasons, we are applying it to every entry in this example.

:::warning[Notice!]
The `immediately` argument operates similarly to
[process_orders_on_close](/pine-script-docs/concepts/strategies#process-orders-on-close), but it is specific to the `strategy.close()` function.
While the emulator calculates the close order using the bar\'s closing
price, it\'s important to understand that these prices may not always be
attainable in realtime trading and can cause
[repainting](/pine-script-docs/concepts/repainting). To learn
more about why orders are typically simulated at the opening of the next
bar in Pine Script™, please refer to
[this FAQ entry](/pine-script-docs/faq#why-are-my-orders-executed-on-the-bar-following-my-triggers).
:::

### Advanced order types and conditions 

#### How can I set a stop loss and take profit level as a percentage from my entry point? 

In Pine Script™, setting stop loss and take-profit levels as a
percentage from the entry point of a trade has its limitations,
primarily due to the way Pine Script™ handles [historical
data](https://www.tradingview.com/pine-script-docs/en/v5/language/Execution_model.html#calculation-based-on-historical-bars).
Understanding these limitations and knowing the workarounds is key to
implementing such strategies effectively.

**Limitations with Historical Data:**

On historical bars, Pine Script™ only has access to a single set of
[open](https://www.tradingview.com/pine-script-reference/v5/#var_open),
[high](https://www.tradingview.com/pine-script-reference/v5/#var_high),
[low](https://www.tradingview.com/pine-script-reference/v5/#var_low) or
[close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
(OHLC) data per bar. Consequently, strategies are calculated at the
close of each bar, which means it's not typically possible to use
intrabar data like
[strategy.position_avg_price](https://www.tradingview.com/pine-script-reference/v5/#var_strategy.position_avg_price)
for calculations on the bar where the trade is entered. Under default
conditions, this variable returns
[na](https://www.tradingview.com/pine-script-reference/v5/#var_na) until
the close of the entry bar, leaving the trade without an exit strategy
for its duration.

**Method 1:** Altering Emulator Behavior

One workaround is to change the emulator\'s default calculation method
by setting the
[calc_on_order_fills](/pine-script-docs/concepts/strategies#calc-on-order-fills) argument of the
[strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
declaration function to `true`. This setting recalculates the strategy
immediately after simulating an order fill, providing access to data
like the current average price of a position on an unconfirmed bar.

``` pine
//@version=5
strategy("Exit demo", overlay = true)

float stopSizeInput   = input.float(1.0, "SL %", minval = 0.0) / 100.0
float profitSizeInput = input.float(1.0, "TP %", minval = 0.0) / 100.0

//@variable Is `true` on every 100th bar.
bool buyCondition = bar_index % 100 == 0

//@variable Stop-loss price for exit commands.
var float stopLoss   = na
//@variable Take-profit price for exit commands.
var float takeProfit = na

// Place orders upon `buyCondition`.
if buyCondition and strategy.position_size == 0.0
    stopLoss   := close * (1.0 - stopSizeInput)
    takeProfit := close * (1.0 + profitSizeInput)
    strategy.entry("buy", strategy.long)
    strategy.exit("exit", "buy", stop = stopLoss, limit = takeProfit)

// Set `stopLoss` and `takeProfit` to `na` when price touches either, i.e., when the strategy simulates an exit.
if low <= stopLoss or high >= takeProfit
    stopLoss   := na
    takeProfit := na

plot(stopLoss,   "SL", color.red,   style = plot.style_linebr)
plot(takeProfit, "TP", color.green, style = plot.style_linebr)
```

In this script, the `calc_on_order_fills` setting is used to access the
entry price as soon as the entry order is filled, allowing for setting
exit prices based on the entry price on the entry bar.

:::warning[Notice!]
Enabling `calc_on_order_fills` may lead to unrealistic results, as it
assumes order prices that might not be achievable in realtime.
Typically, strategies are calculated at the close of the bar, and orders
set to fill on the next tick, which is the open of the next bar. On
historical bars, each bar is considered to have four ticks (open, high,
low, close). The use of an additional script iteration with
`calc_on_order_fills` can lead to the assumption that one of these OHLC
prices represents the subsequent tick, leading to unrealistic scenarios
like orders filling at a bar\'s absolute high or low.
:::

**Method 2:** Using the close value of the signal bar

An alternative method is to avoid using the `calc_on_order_fills`
setting. While this setting yields expected and normal results in simple
scenarios like our example in Method 1, its usage becomes problematic as
the script\'s logic grows more complex. There\'s an elevated risk of
orders being calculated at unrealistic prices on historical bars in
scripts with more elaborate logic. This alternative method proposes
using the closing price of the signal bar as a basis for calculating
percentage-based take profit and stop loss values to avoid using the
setting:

``` pine
//@version=5
strategy("Exit demo", overlay = true)

//@variable Is `true` on every 100th bar.
bool buyCondition = bar_index % 100 == 0

//@variable Stop-loss price for exit commands.
var float stopLoss   = na
//@variable Take-profit price for exit commands.
var float takeProfit = na

// Place orders upon `buyCondition`.
if buyCondition and strategy.position_size == 0.0
    stopLoss   := close * 0.99
    takeProfit := close * 1.01
    strategy.entry("buy", strategy.long)
    strategy.exit("exit", "buy", stop = stopLoss, limit = takeProfit)

// Set `stopLoss` and `takeProfit` to `na` when price touches either, i.e., when the strategy simulates an exit.
if low <= stopLoss or high >= takeProfit
    stopLoss   := na
    takeProfit := na

plot(stopLoss,   "SL", color.red,   style = plot.style_linebr)
plot(takeProfit, "TP", color.green, style = plot.style_linebr)
```

Here, we calculate the stop and limit orders based on the closing price
of the signal bar. While there\'s a discrepancy due to the difference
between the close of the signal bar and the open of the next bar (where
the position\'s entry price is actually calculated), this method is
generally more reliable and doesn\'t introduce potential *lookahead
bias* like `calc_on_order_fills`.

Setting a stop-loss and take-profit level as a percentage from the entry
point in Pine Script™ requires careful consideration of the limitations
with historical data. While the `calc_on_order_fills` method provides
immediate access to certain values, it may lead to unrealistic results
in some scenarios. Calculating based on the close value of the signal
bar offers a more consistent and realistic approach, albeit with some
level of approximation.

#### How do I move my stop loss to breakeven? 

In trading strategies, moving a stop loss to breakeven after a certain
condition is met can be a useful technique to manage risk. In Pine
Script™, this involves dynamically adjusting the stop loss level to the
entry price once certain conditions are satisfied.

**Setting up a dynamic stop loss:**

To move a stop loss to breakeven, you\'ll need to use a persistent
variable declared with the
[var](/pine-script-docs/language/variable-declarations#var)
keyword to track the stop loss level from bar to bar. This stop loss is
initially set at entry and then adjusted to the entry price (breakeven
level) based on a specific condition:

![image](@assets/images/Strategies-Advanced-order-types-and-conditions-How-do-i-move-my-stop-loss-to-breakeven-1.png)

``` pine
//@version=5
strategy("Move stop to breakeven", overlay = true)

float stopSizeInput   = input.float(5.0, "SL %", minval = 0.0) / 100.0
float profitSizeInput = input.float(5.0, "TP %", minval = 0.0) / 100.0
float breakEvenInput  = input.float(50,  "BE %", minval = 0.0, maxval = 100) / 100.0

//@variable Is `true` on every 100th bar when the position is flat.
bool buyCondition = bar_index % 100 == 0 and strategy.position_size == 0.0

//@variable Stop-loss price for exit commands.
var float stopLoss   = na
//@variable Take-profit price for exit commands.
var float takeProfit = na
//@variable Price that, if breached, will set the stop to breakeven.
var float breakEvenThreshold = na

// Place orders upon `buyCondition`.
// Set the breakeven threshold to 50% of the distance to the take-profit.
if buyCondition
    stopLoss           := close * (1.0 - stopSizeInput)
    takeProfit         := close * (1.0 + profitSizeInput)
    breakEvenThreshold := close * (1.0 + profitSizeInput * breakEvenInput)
    strategy.entry("buy", strategy.long)

// If the breakeven threshold is exceeded while in a position, set the stop to the entry price.
if high >= breakEvenThreshold and strategy.position_size != 0
    stopLoss := strategy.position_avg_price

//@variable Is `true` on a bar a trade is exited.
bool isExitBar = strategy.closedtrades.exit_bar_index(strategy.closedtrades - 1) == bar_index
//@variable Condition to determine when plots are displayed.
bool showPlots = strategy.position_size != 0 or buyCondition or isExitBar
// Plot the entry price, stop loss, take-profit, and the breakeven threshold.
plot(strategy.position_avg_price,         "BE", color.new(color.gray, 60), style = plot.style_linebr)
plot(showPlots ? stopLoss           : na, "SL", color.red,                 style = plot.style_linebr)
plot(showPlots ? takeProfit         : na, "TP", color.green,               style = plot.style_linebr)
plot(showPlots ? breakEvenThreshold : na, "TG", color.blue,                style = plot.style_circles)

// Place a bracket order using the `stopLoss` and `takeProfit` values.
// We call it on every bar so that the stop level is updated when the breakeven threshold is exceeded.
strategy.exit("exit", "buy", stop = stopLoss, limit = takeProfit)
```

Here, the script is designed to shift the stop to breakeven once the
price surpasses a certain price threshold.

**In our script we:**

-   Declare the `stopLoss` variable with the
    [var](/pine-script-docs/language/variable-declarations#var)
    keyword. This ensures its value is retained bar to bar.
-   Set the `stopLoss` variable to the percentage specified in the user
    settings when our entry condition is met.
-   Create a condition to update the stop price to the breakeven level,
    utilizing a price threshold that lies between the entry price and
    the take-profit price. By default, this threshold is set at 50%,
    which means the stop is adjusted to the breakeven price if the price
    rises at least 50% of the distance from the entry price towards the
    take-profit price.
-   Once the price exceeds this threshold, we reassign the `stopLoss`
    variable to the entry price
    ([strategy.position_avg_price](https://www.tradingview.com/pine-script-reference/v5/#var_strategy.position_avg_price)),
    effectively setting the stop loss at breakeven. Keep in mind you can
    use any condition you like.
-   Continuously call the
    [strategy.exit()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.exit)
    function on every bar to ensure the broker emulator receives any
    updates made to the `stopLoss` value.
-   Plot the `strategy.position_avg_price` in light
    [gray](https://www.tradingview.com/pine-script-reference/v5/#var_color.gray)
    throughout the trade for reference.

:::warning[Notice!]
The strategy uses
[strategy.position_avg_price](https://www.tradingview.com/pine-script-reference/v5/#var_strategy.position_avg_price)
as the breakeven level. However, if trading commissions are incorporated
into the strategy, the actual breakeven point might be slightly
different. In reality, to calculate a precise breakeven point, one would
need to account for the commission per contract. Unfortunately, Pine
Script™ does not currently provide a direct way to determine the type
and quantity of commission set by the user. Therefore, this example uses
the entry price as a proxy for the breakeven level.
:::

#### How do I implement a trailing stop loss? 

Implementing a trailing stop loss is a technique for managing risk while
allowing a position to remain open as long as the price moves favorably.
There are two primary methods to achieve this in Pine Script™: using the
built-in functionality of the
[strategy.exit()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.exit)
function or creating custom trailing stop-loss logic.

**Method 1:** Using built-In trailing stop functionality

Pine Script\'s `strategy.exit()` function offers built-in trailing stop
capabilities. This method requires specifying two key components:

-   **Activation level:** The price level that must be crossed to
    activate the trailing stop, which can be set in ticks via the
    `trail_points` parameter or as a price value via the `trail_price`
    parameter.
-   **Trail offset:** The distance the stop loss trails behind the
    bar\'s
    [high](https://www.tradingview.com/pine-script-reference/v5/#var_high)
    or
    [low](https://www.tradingview.com/pine-script-reference/v5/#var_low)
    price, defined in ticks using the `trail_offset` parameter.

When using this method, it\'s important to specify both the
`trail_offset` and either the `trail_price` or `trail_points` arguments.
The trailing stop activates when the market price crosses the specified
activation level and then trails the price by the set offset.

In this long-only example, the `strategy.exit()` function uses the
`trail_points` and `trail_offset` parameters to set a trailing stop. The
stop-loss is adjusted to trail the high, minus the offset points, once
the activation level is crossed:

![image](@assets/images/Strategies-Advanced-order-types-and-conditions-How-do-i-implement-a-trailing-stop-loss-1.png)

``` pine
//@version=5
strategy("Trailing stop order demo", overlay = true)

string TT_SO = "The offset in ticks from the high price for setting the trailing stop. This offset determines the
 trailing distance below the high price once the trailing stop is activated. Prior to activation, this offset is
 utilized as the stop loss distance from the entry price."

//@variable Offset used to determine how far above the entry price (in ticks) the activation level will be located.
int activationOffsetInput = input.int(1000, "Activation Level Offset (in ticks)")
//@variable Offset used to determine how far below the high price (in ticks) the trailing stop will trail the chart.
int stopOffsetInput = input.int(2000, "Stop Offset (in ticks)", tooltip = TT_SO)

//@variable The price at which the trailing stop activation level is located.
float trailPriceActivationLevel = activationOffsetInput * syminfo.mintick + strategy.position_avg_price
//@variable The price at which the trailing stop itself is located.
var float trailingStop = na

// Calculate a fast and slow Simple Moving Average.
float ma1 = ta.sma(close, 14)
float ma2 = ta.sma(close, 28)

//@variable Is `true` when `ma1` crosses over `ma2` and the position is flat.
bool longCondition  = ta.crossover(ma1,  ma2) and strategy.position_size == 0
//@variable Is `true` on a bar a trade is exited.
bool  isExitBar = strategy.closedtrades.exit_bar_index(strategy.closedtrades - 1) == bar_index
float exitPrice = strategy.closedtrades.exit_price(strategy.closedtrades - 1)

// Generate a long market order when `longCondition` is `true`.
// Set a static stop loss and set a trailing stop loss if the activation level is exceeded.
if longCondition
    strategy.entry("Long", strategy.long)
    strategy.exit("Stop",
         from_entry   = "Long",
         trail_points = activationOffsetInput,
         trail_offset = stopOffsetInput,
         loss         = stopOffsetInput
         )

// If the high surpasses the activation level, set the `trailingStop` to whichever is higher:
// the current high minus the price equivalent of `stopOffsetInput` or the previous `trailingStop` value.
if high > trailPriceActivationLevel or isExitBar and exitPrice > trailingStop
    trailingStop := math.max(high - stopOffsetInput * syminfo.mintick, nz(trailingStop))

//@variable The price of the active stop price, using the trailing stop when activated, or a static stop loss otherwise.
float stopLevel = na(trailingStop) ? strategy.position_avg_price - stopOffsetInput * syminfo.mintick : trailingStop

// Visualize the movement of the trailing stop and the activation level.
plot(stopLevel,                 "Stop Level",       color.red,  2, plot.style_linebr)
plot(trailPriceActivationLevel, "Activation level", color.aqua, 1, plot.style_linebr)
// Display the two simple moving averages on the chart.
plot(ma1, "MA 1", color.new(color.lime,    60))
plot(ma2, "MA 2", color.new(color.fuchsia, 60))

// Mark the point the trailing stop is activated with a shape and text.
plotshape(high > trailPriceActivationLevel and na(trailingStop)[1], "Trail Activated", shape.triangledown,
     size = size.small, color = color.aqua, text = "Trailing stop\nactivated", textcolor = color.aqua
     )

// Set the trailing stop to `na` when not in a position.
if strategy.position_size == 0
    trailingStop := na
```

Note that:

    -   To set a trailing stop, simply calling the `strategy.exit()`
        function with the trail-specific parameters is sufficient to
        execute a trailing stop order, but additional logic around the
        `trailingStop` variable is included in our script to enable
        visualization of the internally calculated trailing stop price,
        even though this is not necessary for the function\'s operation.
    -   In our strategy, the `loss` parameter is incorporated in the
        exit call as an alternative exit mechanism. This approach is
        designed to prevent trades that fail to trigger the trailing
        stop from remaining open excessively long during our
        demonstration. It\'s important to note, however, that setting an
        initial static stop-loss is not a prerequisite for executing a
        trailing stop order. We configure the initial loss size to match
        the stop offset size, specified in ticks, as set by the user in
        the menu. Consequently, if the trailing stop is not activated,
        the trade will close when a loss exceeding this predetermined
        size occurs.
    -   The built-in trailing order logic relies on the
        [broker emulator](/pine-script-docs/concepts/strategies#broker-emulator) to make simplified assumptions about price movements
        within historical bars. Each historical bar provides only one
        set of
        [open](https://www.tradingview.com/pine-script-reference/v5/#var_open),
        [high](https://www.tradingview.com/pine-script-reference/v5/#var_high),
        [low](https://www.tradingview.com/pine-script-reference/v5/#var_low)
        or
        [close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
        (OHLC) data, leading the emulator to infer a linear price path:
        from the opening price, to either the high then low or vice
        versa, and finally to the closing price. However, this approach
        does not always capture the actual, often more erratic, intrabar
        price fluctuations that occur in real time. Consequently,
        there\'s a risk that the trailing logic, when applied in real
        time, could behave differently compared to its calculations on
        historical data. This discrepancy can result in
        [repainting](/pine-script-docs/concepts/repainting).
    -   [Premium](https://www.tradingview.com/pricing/) account holders
        can use the
        [bar magnifier](/pine-script-docs/broker-emulator#bar-magnifier) feature to analyze data from smaller timeframes than
        the chart's, providing a greater number of price points to infer
        intrabar price movements. This enhances order simulation
        precision and lowers repainting risk. However, despite the
        increased granularity from lower timeframe data, it doesn\'t
        fully eliminate repainting. Additionally, its 200,000 intrabar
        cap might limit its application to only a portion of the
        historical trades.

**Method 2:** Customizing your own trailing stop

Creating a custom trailing stop-loss provides more flexibility and
control over when and how the trailing stop is activated and how it
behaves. This method involves more complex logic but offers greater
customization. You can define your own criteria for activating the
trailing stop and dictate how it adjusts as the price moves. This might
involve calculating the trailing stop based on various factors like
volatility, moving averages, or other technical indicators.

The process of establishing a custom trailing stop loss involves
calculating the stop price on each bar as the trade progresses. This
calculated value is then fed into the `strategy.exit()` function to set
the `stop` price. By executing the exit function on each bar, the broker
emulator is consistently updated with the latest stop price.

In this example, the script triggers long and short trades based on
crosses of two moving averages. A custom function calculates the
trailing stop using the highest or lowest price from the last 5 bars,
adjusted by an [Average True Range
(ATR)](https://www.tradingview.com/support/solutions/43000501823-average-true-range-atr/)
buffer for a volatility-relative stop distance. This method of
distancing the stop by a measure of average price movement attempts to
reduce premature stop triggers in volatile conditions:

``` pine
//@version=5
strategy("Atr trailing stop demo", overlay = true)

// Sets the lookback period in bars to identify the highest or lowest point for trailing stop calculations.
int SWING_LOOKBACK = 5

// @function                Calculates a dynamic trailing stop by adjusting the highest
//                          (bearish) or lowest (bullish) swing points over a set `length`
//                          of bars using the ATR, for a stop distance proportional to average bar size.
// @param calcStop          (series bool) A condition that triggers the calculation of the trailing stop, ex. being in a trade.
// @param length            (simple int) The number of bars to look back to determine the highest or lowest point for
//                          the trailing stop calculation.
// @param isBull            (simple bool) Indicator of the trailing stop's orientation: true for bullish
//                          scenarios (stop below price) and false for bearish scenarios (stop above price).
// @param atrMultiplier     (simple float) The multiplier applied to the ATR, adjusting the stop's distance from the
//                          identified extreme price point. Optional. Default is 1.0, or 100% of the ATR value.
// @returns                 (float) The trailing stop price, or `na` if `calcStop` is false.
atrTrailingStop(series bool calcStop, simple int length, simple bool isBull, simple float atrMultiplier = 1.0) =>
    var float trailPrice = na
    int   m   = isBull ? 1 : -1
    float atr = ta.atr(14) * atrMultiplier
    float swingPoint = switch
        isBull => ta.lowest(length)  - atr
        =>        ta.highest(length) + atr
    trailPrice := switch
        calcStop    and not calcStop[1] => swingPoint
        calcStop[1] and not calcStop    => na
        => math.max(trailPrice * m, swingPoint * m) * m


// Calculate a fast and slow simple moving average.
float ma1 = ta.sma(close, 14)
float ma2 = ta.sma(close, 28)

// Create conditions for long/short entries on MA crossover/crossunder, provided no existing position is held.
bool longCondition  = ta.crossover(ma1,  ma2) and strategy.position_size == 0
bool shortCondition = ta.crossunder(ma1, ma2) and strategy.position_size == 0

// Create conditions to determine when to calculate trailing stops for long/short positions, based on entries and position.
bool isExitBar = strategy.closedtrades.exit_bar_index(strategy.closedtrades - 1) == bar_index
bool isBull = longCondition  or strategy.position_size > 0 or isExitBar
bool isBear = shortCondition or strategy.position_size < 0 or isExitBar

// Use `atrTrailingStop()` to calculate trailing stops for both long and short positions.
float longStop  = atrTrailingStop(isBull, SWING_LOOKBACK, true)
float shortStop = atrTrailingStop(isBear, SWING_LOOKBACK, false)

// Place long entry order upon `longCondition`.
if longCondition
    strategy.entry("long", strategy.long)
// Place short entry order upon `shortCondition`.
if shortCondition
    strategy.entry("short", strategy.short)

// Create exit orders for long/short trades with ATR trailing stop, called on each bar to update to the latest price.
strategy.exit("long exit",  "long",  stop = longStop)
strategy.exit("short exit", "short", stop = shortStop)

// Display the two simple moving averages and stop levels on the chart.
plot(ma1, "MA 1", color.new(color.lime,    60))
plot(ma2, "MA 2", color.new(color.fuchsia, 60))
plot(isExitBar ? longStop[1]  : longStop,  "Long Stop",  color.red, 2, plot.style_linebr)
plot(isExitBar ? shortStop[1] : shortStop, "Short Stop", color.red, 2, plot.style_linebr)
```

Note that:

    -   We use our custom function, `atrTrailingStop()`, to calculate a
        dynamic trailing stop using the highest or lowest price from the
        last `n` bars, adjusted with an ATR buffer, to attempt to
        proportionally align the stop distance with recent bar sizes.
    -   To ensure the broker emulator is consistently updated with the
        latest stop price during active trades, we call the
        `strategy.exit()` function on each bar.
    -   Due to the fact that strategies run once per bar, the trailing
        stop price in this example is updated at the close of each bar.
        This means that during realtime bars the previous bar\'s stop
        value is used. This approach, while slightly delayed compared to
        the built-in method described in method 1, ensures that the
        trailing stop price isn\'t subject to intrabar price travel
        assumptions, and thus avoids repainting.

When considering the use of built-in versus custom methods for
implementing trailing stop losses in Pine Script™, it\'s important to
understand how the broker emulator\'s behavior impacts the realism of
these mechanisms:

-   **Method 1:** The broker emulator, which simulates strategy
    execution, uses live price updates to evaluate trailing stops set in
    `strategy.exit()` in realtime, allowing it to react to price changes
    within the realtime bar\'s duration. **However, due to assumptions
    about price movements within historical bars, the built-in is
    subject to introduce repainting to your strategies.** If your
    strategy prioritizes timeliness over historical accuracy, the
    built-in method (method 1) is more suitable.
-   **Method 2:** In contrast, custom trailing stop values, which are
    typically updated at the close of each bar, may not capture realtime
    intrabar price movements with the same responsiveness. It\'s
    important to remember that strategies in Pine Script™, by default,
    execute once per bar, meaning that updates to custom stop prices are
    only reflected at the bar\'s close. **This delay comes with the
    benefit of avoiding repainting strategy results.** If backtesting
    accuracy is critical in your strategy development, the custom method
    (method 2) is preferable.

#### How can I set a time-based condition to close out a position? 

Implementing time-based conditions to close positions in Pine Script™
involves comparing the trade entry time with the current bar time. When
the duration since the trade entry exceeds a specified value,
[strategy.close()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.close)
can be used to close out the position.

**Setting up time-based closure**

To create a time-based exit condition, your script must perform the
following steps:

1.  **Track trade entry time:** The script needs to keep track of the
    time when each trade is entered.
2.  **Define timeout value:** Set a specific duration in seconds, after
    which you want the position to be closed.
3.  **Compare duration with timeout:** Continuously compare the current
    time with the trade entry time. If the elapsed time surpasses your
    predefined timeout, trigger the position closure.

**Limitations and considerations**

-   **Historical bars limitation:** In Pine Script™, strategies are
    calculated at the close of each bar, meaning time-based conditions
    can only be evaluated at that moment. This constraint implies that
    on historical bars, **trade times are assessed in increments equal
    to the chart bar\'s duration.**
-   **Realtime vs. historical bars:** In realtime, the same logic
    applies unless you alter the strategy calculation to
    [calc_on_every_tick](/pine-script-docs/concepts/strategies#calc-on-every-tick). This modification allows the trade to close as soon as
    the first tick exceeds the timeout value after trade entry. Remember
    that
    [altering emulator behavior](/pine-script-docs/concepts/strategies#altering-calculation-behavior) typically introduces
    [repainting](/pine-script-docs/concepts/repainting).
-   **Trade duration on different timeframes:** If your timeout value is
    not divisible by the duration of a chart bar, each trade will last
    at least one additional chart bar. For instance, setting a timeout
    of 100 seconds on a 1-minute chart effectively means a minimum of
    two bars before a position can be closed.

In this example script, the custom function `closePositionsAfter()` is
utilized to handle the closing of positions based on time:

![image](@assets/images/Strategies-Advanced-order-types-and-conditions-How-can-i-set-a-time-based-condition-to-close-out-a-position-1.png)

``` pine
//@version=5
strategy("Close position by timeout", overlay = true)

// @function                Automatically closes all open positions that have been active for longer than a specified timeout period.
// @param timeoutInSeconds  (int) The maximum allowed duration for an open trade, measured in seconds.
//                          If an open trade's duration exceeds this value, it will be closed.
// @returns                 (void) The function has no explicit return.
closePositionsAfter(int timeoutInSeconds) =>
    if strategy.opentrades > 0
        for i = 0 to strategy.opentrades - 1
            int timeNow = barstate.isrealtime ? timenow : time_close
            int tradeDurationInSeconds = (timeNow - strategy.opentrades.entry_time(i)) / 1000
            if tradeDurationInSeconds >= timeoutInSeconds
                string entryName    = strategy.opentrades.entry_id(i)
                string tradeComment = str.format("Close \"{0}\" by timeout {1}s", entryName, tradeDurationInSeconds)
                strategy.close(entryName, comment = tradeComment, immediately = true)

// Create long and short conditions based on the crossover/under of 2 moving averages.
bool longCondition  = ta.crossover(ta.sma(close,  14), ta.sma(close, 28))
bool shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))

// Place long entry order upon `longCondition`.
if longCondition
    strategy.entry("long", strategy.long)
// Place short entry order upon `shortCondition`.
if shortCondition
    strategy.entry("short", strategy.short)

// Close positions after 120 sec               
closePositionsAfter(120)
```

**In our script we:**

-   Implement a custom function, `closePositionsAfter()`, to manage the
    time-based closing of positions. The function first checks if there
    are open trades. For each open trade, it calculates the duration
    since it was opened by comparing the current time against the trade
    entry time. If a trade\'s duration exceeds the specified timeout,
    the function triggers a trade closure, marking the event with a
    comment on the chart including the trade\'s duration in seconds.
-   Leverage the `timeNow` variable in the `closePositionsAfter()`
    function to accurately track the current time. In realtime,
    `timeNow` is set to
    [timenow](https://www.tradingview.com/pine-script-reference/v5/#var_timenow),
    ensuring that the time calculation is based on the most recent tick.
    This is applicable if the strategy is set to `calc_on_every_tick`;
    if not, the evaluation occurs at the bar\'s close. For historical
    bars, `timeNow` uses
    [time_close](https://www.tradingview.com/pine-script-reference/v5/#var_time_close),
    the closing time of the bar, to maintain consistency with Pine
    Script\'s [execution model](/pine-script-docs/language/execution-model) where scripts calculate once per historical bar at the
    close.
-   Utilize [built-in](/pine-script-docs/built-in-functions) functions in the `strategy.opentrades.*()` namespace. We
    use
    [strategy.opentrades.entry_time()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.opentrades.entry_time)
    to ascertain the entry time of all open positions. It compares these
    timestamps to the `timeNow` variable to determine the duration of
    each trade. Additionally,
    [strategy.opentrades.entry_id()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.opentrades.entry_id)
    is used to identify and mark trade closures on the chart with their
    specific entry IDs for clarity.
-   Set the `immediately` parameter within the
    [strategy.close()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.close)
    function to
    [true](https://www.tradingview.com/pine-script-reference/v5/#var_true).
    This ensures that trades are simulated at the end of the bar which
    exceeds our timer, rather than waiting for the opening of the next
    bar. Consequently, when a 120-second timeout is applied and the
    script runs on a 1-minute chart, it gives the appearance that trades
    last exactly two bars.

:::warning[Notice!]
The `immediately` parameter\'s functionality is similar to that of
[process_orders_on_close](/pine-script-docs/concepts/strategies#process-orders-on-close), ensuring that the order is simulated at the bar\'s close.
Typically, without these parameters, orders are processed at the opening
of the subsequent bar. For a more detailed understanding of this default
behavior, see
[this](/pine-script-docs/faq#why-are-my-orders-executed-on-the-bar-following-my-triggers) relevant FAQ entry.
:::

Setting a time-based condition to close positions in Pine Script™
requires careful consideration of the script\'s
[execution model](/pine-script-docs/language/execution-model) and
the differences between realtime and historical data. By using a custom
function like `closePositionsAfter()`, you can effectively manage trade
durations and exit positions based on specific time criteria. Remember
to consider the timing nuances of your chosen chart timeframe and how
they interact with your strategy\'s timeout settings.

#### How can I configure a bracket order with a specific risk-to-reward (R:R) ratio? 

To create a bracket order in Pine Script™ with a specified
risk-to-reward (R:R) ratio, you need to define both a stop-loss and a
take-profit order. These orders should be placed at distances from the
entry price that align with the desired R:R ratio. This can be
accomplished by using a single
[strategy.exit()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.exit)
function that incorporates both the stop-loss and take-profit orders,
based on the predetermined R:R ratio.

To apply a specific risk-to-reward ratio, start by calculating the
distance between the entry point and the stop-loss level. This distance,
referred to as the stop distance, represents the potential loss for the
trade. Next, multiply the stop distance by the desired risk-to-reward
ratio to determine the distance for the take-profit level. For example,
if using a risk-to-reward ratio of 2:1, as in our example script, the
distance to the take-profit will be twice the stop distance, indicating
that the potential profit is twice the size of the potential loss:

![image](@assets/images/Strategies-Advanced-order-types-and-conditions-How-can-i-configure-a-bracket-order-with-a-specific-risk-to-reward-rr-ratio-1.png)

``` pine
//@version=5
strategy("R:R demo", overlay = true)

// Declare the stop size in ticks and the risk-to-reward ratio as inputs.
int   lossSizeInput   = input.int(300,   "Loss size (in ticks)", minval = 0)
float riskRewardInput = input.float(2.0, "Risk/Reward multiple", minval = 0)

// Calculate a fast and slow simple moving average.
float ma1 = ta.sma(close, 14)
float ma2 = ta.sma(close, 28)

// Create conditions for long/short entries on MA crossover/crossunder, provided no existing position is held.
bool buyCondition  = ta.crossover(ma1,  ma2) and strategy.position_size == 0
bool sellCondition = ta.crossunder(ma1, ma2) and strategy.position_size == 0

// Place orders when `buyCondition` or `sellCondition` is true.
if buyCondition
    strategy.entry("buy", strategy.long)
if sellCondition
    strategy.entry("sell", strategy.short)
// Define exit point for the entries based on a predefined loss size.
// Calculate the profit target by multiplying the loss size with the user-defined risk-to-reward ratio.
strategy.exit("exit", loss = lossSizeInput, profit = lossSizeInput * riskRewardInput)

// Calculate the price equivalent of the profit and loss level.
float tradeBias       = math.sign(strategy.position_size)
float stopLossPrice   = strategy.position_avg_price - (tradeBias * lossSizeInput * syminfo.mintick)
float takeProfitPrice = strategy.position_avg_price + (tradeBias * lossSizeInput * syminfo.mintick * riskRewardInput)

// Plot the entry price, the stop price, and the price of the take-profit.
p1 = plot(stopLossPrice,   "Stop-loss price",   color.red,   style = plot.style_linebr)
p2 = plot(takeProfitPrice, "Take-profit price", color.green, style = plot.style_linebr)
p3 = plot(strategy.position_avg_price, "Entry price", color.new(color.gray, 70), style = plot.style_linebr)

// Visually highlight the R:R ratio by shading the area between the entry and the stop and the entry and the take-profit.
fill(p1, p3, color.new(color.red,   80))
fill(p2, p3, color.new(color.green, 80))
```

**In our script we:**

-   Create long and short orders using a generic moving average
    crossover strategy as an illustrative example.
-   Incorporate a user input, `lossSizeInput`, to define the size of the
    loss in ticks. This value is then utilized in the loss parameter of
    the `strategy.exit()` function.
-   Implement another user input, `riskRewardInput`, for setting the
    risk-to-reward (R:R) ratio, with a default value of 2. This means
    that the take-profit distance is twice the stop distance.
-   Calculate the take-profit level by multiplying the specified loss
    size by the R:R ratio. The resulting value is used in the `profit`
    parameter of the `strategy.exit()` function.
-   Enhance the visual representation of the R:R ratio by shading the
    areas between the entry and stop-loss points, and between the entry
    and take-profit points, to depict the risk-to-reward relationship.

#### How can I adjust my position size to ensure that I risk a fixed percentage of my equity? 

A useful risk management strategy involves adjusting the position size
to risk a fixed percentage of equity. This method consistently affects
the total equity by ensuring uniform exposure levels, regardless of
equity fluctuations. It also helps in averting disproportionate risks
across a strategy\'s trading history. The key is to modify the position
size in relation to the stop distance, thereby maintaining consistent
risk exposure to the total equity, irrespective of the stop distance\'s
length.

Configuring this in Pine Script™ involves the following steps:

1.  **Calculate risk per contract:** Calculate it by multiplying three
    key factors:

    -   The number of ticks you\'re willing to risk, which is your
        predetermined stop distance in ticks.
    -   The monetary value of each tick for the traded instrument
        ([syminfo.mintick](https://www.tradingview.com/pine-script-reference/v5/#var_syminfo.mintick)).

    \- The number of units each contract represents
    ([syminfo.pointvalue](https://www.tradingview.com/pine-script-reference/v5/#var_syminfo.pointvalue)).
    This calculation yields the total risk in monetary terms for each
    contract of the instrument you\'re trading.

2.  **Determine equity to risk:** Next, ascertain the total amount of
    equity you intend to risk. This is achieved by multiplying your
    current equity
    ([strategy.equity](https://www.tradingview.com/pine-script-reference/v5/#var_strategy.equity))
    with the percentage of equity you\'ve decided to risk. The result is
    the total monetary value of equity you are prepared to risk in your
    next trade.

3.  **Calculate required position size:** Finally, determine the
    appropriate position size. Do this by dividing the amount of equity
    you plan to risk (step 2) by the risk per contract (step 1). This
    calculation determines the necessary position size to achieve the
    desired level of exposure considering the set stop distance.

:::warning[Notice!]
It\'s important to understand that achieving the required position size
might necessitate using leverage, particularly when the stop distance is
short and a higher exposure is needed to meet the specified risk level.
If you wish to prevent the strategy from entering positions that require
margin, set the `margin_long` and `margin_short` parameters to 100 in
the
[strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
declaration function or the *Properties* tab of the settings menu. For
more info on incorporating leverage into strategies, see this [Help
Center](https://www.tradingview.com/support/solutions/43000717375-how-do-i-simulate-trading-with-leverage/)
article.
:::

In our example script, we display two lines: the current total equity
and the calculated value of a position needed for sufficient exposure at
the current price. To ensure the strategy can cover a new position
without leverage, the green line (total equity) should be above the blue
line (position value). If the blue line exceeds the green, leverage is
needed to achieve the required exposure. In such cases, the script
colors the background red and displays the minimum leverage ratio needed
in the data window:

![image](@assets/images/Strategies-Advanced-order-types-and-conditions-How-can-i-adjust-my-position-size-to-ensure-that-i-risk-a-fixed-percentage-of-my-equity-1.png)

``` pine
//@version=5
strategy("Fixed risk", overlay = false, initial_capital = 100000)

// Provide inputs to specify the desired loss (in ticks), the trade R:R ratio, and the percentage of equity to risk.
int   lossSizeInput   = input.int(300,   "Loss size (in ticks)", minval = 0)
float riskRewardInput = input.float(2.0, "Risk/Reward multiple", minval = 0)
float pctRiskInput    = input.float(1.0, "% of equity to risk") / 100

// Calculate a fast and slow simple moving average.
float ma1 = ta.sma(close, 14)
float ma2 = ta.sma(close, 28)

// Create conditions for long/short entries on MA crossover/crossunder, provided no existing position exists.
bool buyCondition  = ta.crossover(ma1,  ma2) and strategy.position_size == 0
bool sellCondition = ta.crossunder(ma1, ma2) and strategy.position_size == 0

// Declare a variable to store the equity value at each trade entry, in order to calculate the percent change in equity.
var float equityAtEntry = 0.0
// Calculate the risk per contract of the instrument.
float riskPerContract = lossSizeInput * syminfo.mintick * syminfo.pointvalue
// Calculate the amount of equity to risk.
float equityToRisk = strategy.equity * pctRiskInput
// Determine the position size necessary to risk the specified percentage of the equity.
float positionSize = equityToRisk / riskPerContract

// Place orders when `buyCondition` or `sellCondition` is true.
// Set the `equityAtEntry` variable to the current equity on each entry.
if buyCondition
    strategy.entry("buy", strategy.long, positionSize)
    equityAtEntry := strategy.equity
if sellCondition
    strategy.entry("sell", strategy.short, positionSize)
    equityAtEntry := strategy.equity

// Define exit point for the entries based on a predefined loss size.
// Calculate the profit target by multiplying the loss size with the user-defined risk-to-reward ratio.
strategy.exit("exit", loss = lossSizeInput, profit = lossSizeInput * riskRewardInput)

// Calculate the percent equity change between the current equity and the equity at entry.
// On the exit bar of each trade, this value can be used to verify the percentage of equity risked.
float equityChgPercent = 100 * (strategy.equity - equityAtEntry) / equityAtEntry
color equityChgColor   = equityChgPercent < 0 ? color.red : color.green,

// Display the current equity, the current value of a new position, and the percentage change in equity to the data window.
plot(strategy.equity, "Current Total Equity", color.green, 2)
plot(positionSize * close, "Value of New Position at Current Price", color.aqua, 2)
plot(equityChgPercent, "Percentage Change in Equity per Trade", equityChgColor, display = display.data_window, format = format.percent)

// Color the background red if the calculated risk value exceeds the available equity. (Leverage required)
bgcolor(strategy.equity < positionSize * close ? color.new(color.red, 80) : na)
// Plot the minimum leverage multiple required to open the position, applicable only if leverage is necessary.
plot(strategy.equity < positionSize * close ? positionSize * close / strategy.equity : na, "Leverage multiple required",
     display = display.data_window
     )
```

**In our script we:**

-   Utilize a generic moving average crossover strategy to generate both
    long and short orders. This serves as a basic example for our
    trading strategy.
-   Implement 3 variables for user inputs:
    -   **lossSizeInput:** Defines the size of the loss in ticks. This
        value is then utilized in the loss parameter of the
        [strategy.exit()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.exit)
        function.
    -   **riskRewardInput:** Determines the risk-to-reward (R:R) ratio.
        With a default value of 2, the take-profit distance is twice the
        stop distance.
    -   **pctStopInput:** Used to calculate the position size. The
        calculated position size is based on the necessary exposure to
        risk the specified percentage of equity over the stop distance.
        This determines how much capital is allocated on each trade.
-   Calculate the `equityAtEntry` variable to track the percentage
    change in equity from the start to the end of each trade, helping in
    monitoring trade performance against the preset risk percentage.
    It\'s important to note that the actual exposure level may vary due
    to the divisibility of each unit into the available capital. This
    might limit the equity risked to less than intended, particularly
    when dealing with small equity amounts, high unit prices, or assets
    such as stocks where trading partial shares is not possible. The
    script displays this percentage change in equity per trade in the
    data window for reference.

It\'s worth noting that the stop distance in our example script is set
as a constant value for demonstration purposes, allowing users to adjust
it interactively through the menu. However, in practice, this stop
distance can be dynamic and vary for each trade, based on factors of
your choosing rather than being a fixed value.

### Strategy optimization and testing 

#### Why did my trade results change dramatically overnight? 

In Pine Script™, the execution of scripts and the results of strategies
can vary over time due to shifts in the
[starting point](/pine-script-docs/concepts/repainting#starting-points) of the chart\'s historical data. Understanding why this
happens requires a grasp of Pine Script\'s
[execution model](/pine-script-docs/language/execution-model) and
factors that influence the historical data visible on your charts.

**Factors influencing historical data and starting points:**

1.  **Account type:** Different TradingView plans provide access to
    varying amounts of historical bars:
    -   20,000 bars for Premium users.
    -   10,000 bars for Pro and Pro+ users.
    -   5,000 bars for other plans.
2.  **Historical data availability:** The data supplied by the data
    provider also impacts the range of historical bars available.
3.  **Dataset alignment:** Depending on the chart\'s timeframe, the
    starting point aligns to specific periods:
    -   **Seconds (1-30):** Aligns to the start of a day.
    -   **Minutes (1-14):** Aligns to the start of a week.
    -   **Minutes (15-29):** Aligns to the start of a month.
    -   **Minutes (30-1439):** Aligns to the start of a year.
    -   **1440 minutes and above:** Aligns to the first available
        historical data point.

:::warning[Notice!]
As time progresses, these factors cause the historical window of your
chart to shift, altering the starting point and potentially affecting
script calculations. For strategies, this means the historical results
you see today might change as the dataset\'s starting point moves.
Essentially, as new data comes in, older data rolls out of the window
based on your subscription limits and dataset alignment, which can lead
to a natural [repainting](/pine-script-docs/concepts/repainting)
of strategy results over time.
:::

**Mitigating the impact on backtesting:**

To reduce the effect of these changes on your backtesting:

1.  **Export strategy results:** Regularly [exporting your strategy
    results](https://www.tradingview.com/support/solutions/43000613680-how-can-i-export-strategy-data/)
    to an external tool like Excel can help maintain a record of
    performance over time despite changes in historical data. Use the
    *export data* option in the top of the *List of Trades* tab in the
    [strategy tester](/pine-script-docs/concepts/strategies#strategy-tester).
2.  **Utilize deep backtesting for premium users:**
    [Premium](https://www.tradingview.com/pricing/) users have access to
    the [deep
    backtesting](https://www.tradingview.com/blog/en/deep-backtesting-is-out-of-beta-41158/)
    feature, which provides results from the entire available dataset of
    a symbol. However, these results won\'t be visible directly on the
    chart.
3.  **Use bar replay:** Employ the bar replay feature on the first chart
    bar. By doing this, you effectively extend the dataset backward,
    allowing your strategy to run on an additional full dataset prior to
    your current range. This process can be repeated a few times to
    analyze multiple datasets.

It\'s important to understand that as time passes, the part of your
strategy\'s historical results that you see will change. With time, the
data alignment rules can lead to the removal of large portions of the
dataset, potentially causing significant alterations in the displayed
results of your strategy. This is a fundamental aspect of how Pine
Script™ and TradingView handle historical data. By being aware of this
and employing the methods above, you can more effectively manage and
understand changes in your strategy\'s performance over time.

#### Why is backtesting on Heikin Ashi and other non-standard charts not recommended? 

It is essential to recognize the limitations of backtesting on
non-standard charts like Heikin Ashi, Renko, Kagi, Point & Figure, and
Range charts. These charts offer unique perspectives on price action but
are not suited for
[strategy backtesting](/pine-script-docs/concepts/strategies#notes-on-testing-strategies) or automated trading systems execution, for several reasons:

1.  Nature Of Non-Standard Charts
    -   **Synthetic price action:** Non-standard charts transform market
        prices into synthetic views of price action. They either focus
        on price movement, disregarding time, or calculate artificial
        [open](https://www.tradingview.com/pine-script-reference/v5/#var_open),
        [high](https://www.tradingview.com/pine-script-reference/v5/#var_high),
        [low](https://www.tradingview.com/pine-script-reference/v5/#var_low)
        and
        [close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
        (OHLC) values. For example, [Heikin
        Ashi](https://www.tradingview.com/support/solutions/43000619436-heikin-ashi/)
        charts calculate each bar\'s values based on averages, which
        distorts the true market price movement.
2.  Impact on Strategy Execution
    -   **Precision and Reliability Issues:** These charts are
        insightful for alternative price action analysis but are
        problematic for testing strategies. The disparity between
        synthetic, calculated chart prices and actual market prices
        introduces a high level of uncertainty in trade execution,
        leading to unreliable backtesting results.
    -   For a more detailed analysis of how non-standard chart types
        affect strategy results, refer to [this
        script](https://www.tradingview.com/script/q9laJNG9-Backtesting-on-Non-Standard-Charts-Caution-PineCoders-FAQ/).
3.  Challenges of Backtesting
    -   **Misaligned Order Fills:** On non-standard charts, the opening
        price of the next bar, where the `broker
        emulator <PageStrategies_BrokerEmulator>` typically simulates order fills, does not correspond
        to real-time market prices. This can result in unrealistic order
        fills, especially evident on Heikin Ashi charts where each
        bar\'s open is an average of the previous bar\'s values, leading
        to unrealistically advantageous order execution scenarios.
    -   **Renko and Other Chart Types:** Charts such as
        [Renko](https://www.tradingview.com/support/solutions/43000502284-renko-charts/),
        [Kagi](https://www.tradingview.com/support/solutions/43000502272-kagi-charts/),
        [Point &
        Figure](https://www.tradingview.com/support/solutions/43000502276-point-and-figure-pnf-charts/),
        and [Range
        Charts](https://www.tradingview.com/support/solutions/43000474007-what-s-range-interval-and-how-do-i-select-it/),
        which emphasize price movement and exclude time, share similar
        challenges. The construction of these charts relies on interval
        close values, whether in the form of *bricks* for Renko,
        *turning points* for Kagi, *columns* for Point & Figure, or
        *bars* for Range Charts. This method does not accurately reflect
        the actual market price at the time these chart elements are
        formed, leading to inaccuracies in order simulation.

While non-standard charts are valuable for analysis, they are not
suitable for backtesting strategies. The synthetic nature of their price
representation can lead to unrealistic and potentially misleading
backtesting results, making them unsuitable for strategy testing and
execution. Traders should use standard price charts for backtesting to
ensure that strategies are tested under conditions that closely mimic
real-market scenarios.

#### How can I backtest deeper into history? 

To conduct more comprehensive backtesting in Pine Script, exploring
further into a security\'s historical data, there are two methods
available. These approaches can extend the dataset used for backtesting,
providing a broader representation of how a strategy might have
performed in the past.

**Method 1:** Using Bar Replay

-   **Extend dataset backward:** The [Bar
    Replay](https://www.tradingview.com/support/solutions/43000712747-what-is-bar-replay/)
    feature can be useful to increase the amount of data available for
    backtesting. By starting the bar replay from the first chart bar in
    history, you effectively roll back your dataset to an earlier point
    in time. This allows your strategy to process and run on a dataset
    that precedes your current chart range.
-   **Limited repetition:** Each iteration of the bar replay extends the
    dataset further back, offering analysis of multiple historical
    datasets. However, there is a limit to the number of times this
    process can be repeated.
-   **Visualization advantage:** This method has the added benefit of
    visualizing the strategy\'s performance directly on the chart, which
    can be insightful for understanding trade entries, exits, and
    behavior during specific historical market conditions.

**Method 2:** Deep Backtesting for premium users

-   **Access to extended data:** For
    [Premium](https://www.tradingview.com/pricing/) TradingView users,
    the [deep
    backtesting](https://www.tradingview.com/support/solutions/43000666199-what-is-deep-backtesting/)
    feature unlocks the ability to calculate the strategy on all
    historical data available for the selected symbol, and not only on
    that which is loaded on the chart.
-   **Chart visibility limitation:** While deep backtesting provides
    comprehensive results, these are not directly visible on the chart.
    Users need to rely on the
    [Strategy Tester's](/pine-script-docs/concepts/strategies#strategy-tester) report for analysis, which may not offer the same
    intuitive understanding as visual chart data.

:::warning[Notice!]
It\'s important to understand that there might be differences in the
results obtained through regular Strategy Tester backtesting and those
from the Deep Backtesting mode. This is further explained
[here](https://www.tradingview.com/?solution=43000666266).
:::

#### How do I backtest multiple symbols at once? 

Backtesting a strategy on multiple symbols simultaneously on TradingView
is not currently possible. This limitation requires a different approach
for traders looking to evaluate a strategy across various markets or
instruments:

-   **Manual application required:** To backtest a strategy on different
    symbols, you need to manually apply the strategy to each chart. This
    involves applying the strategy to the chart and then switching the
    chart to the desired symbol.
-   **Organizing symbols with watchlists:** Utilize TradingView\'s
    watchlist feature to organize and quickly access different symbols
    for backtesting. This method helps streamline the process, making it
    more efficient to cycle through various symbols.
-   **Exporting strategy tester results:** While direct multi-symbol
    backtesting isn\'t possible, TradingView allows you to export the
    results from the
    [Strategy Tester](/pine-script-docs/concepts/strategies#strategy-tester). This feature is beneficial for maintaining records and
    comparing the performance of your strategy on different symbols.
-   **External comparison and analysis:** After exporting the strategy
    performance data for each symbol, you can use external tools like
    spreadsheet software for a detailed comparative analysis. This step
    can help to understand how the strategy performs across a range of
    market conditions and symbols.

While the process might seem laborious due to the lack of a multi-symbol
backtesting feature, these steps ensure that you can still thoroughly
evaluate your strategy\'s effectiveness across different instruments.

#### What does Bar Magnifier do? 

The [Bar Magnifier](/pine-script-docs/broker-emulator#bar-magnifier) feature, available for TradingView
[Premium](https://www.tradingview.com/pricing/) account holders,
significantly enhances the accuracy of order fills in strategy
backtests. This tool uses intrabar inspection to obtain deeper
granularity on price movement within a bar, allowing for more precise
order fills. When selected, Bar Magnifier mode replaces the assumptions
the [broker emulator](/pine-script-docs/concepts/strategies#broker-emulator) must make on price movement using only a single set of OHLC
values for each historical bar.

**Typical behavior**

The broker emulator typically relies on a simplified model of price
movements, using only one set of
[open](https://www.tradingview.com/pine-script-reference/v5/#var_open),
[high](https://www.tradingview.com/pine-script-reference/v5/#var_high),
[low](https://www.tradingview.com/pine-script-reference/v5/#var_low) or
[close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
(OHLC) data per historical bar. This model assumes a linear progression
of prices within each bar: starting at the opening price, moving to
either the high or low (whichever comes first), then to the other (high
or low), and finally to the closing price. However, this method often
fails to accurately reflect the more complex and erratic price movements
that actually happen in realtime within each bar.

**Intrabar inspection**

To address this limitation, the Bar Magnifier tool utilizes intrabar
data, which offers a more granular view of price movements within each
bar. By analyzing the OHLC values from each intrabar, the Bar Magnifier
significantly increases the number of data points available. This
enhanced dataset provides a more robust basis for inferring the
direction and nature of intrabar price movements. Consequently, the Bar
Magnifier enables a more accurate representation of the actual price
fluctuations that occurred within each historical bar.

**Dynamic timeframe adjustment**

The intrabar timeframe utilized by the Bar Magnifier dynamically aligns
with the chart's selected timeframe. This means that for higher chart
timeframes, an appropriately scaled, smaller timeframe is used for
intrabar inspection. The table below outlines how the intrabar timeframe
varies with different chart timeframes:

  -----------------------------------------------
  Chart Timeframe     Intrabar Timeframe Used
  ------------------- ---------------------------
  1S                  1S

  30S                 5S

  1                   10S

  5                   30S

  10                  1

  15                  2

  30                  5

  60                  10

  240                 30

  1D                  60

  3D                  240

  W                   D
  -----------------------------------------------

To fully appreciate the effectiveness of Bar Magnifier, refer to script
demonstrations in the
[User Manual](/pine-script-docs/broker-emulator#bar-magnifier). These examples illustrate the difference this setting
makes, especially in simulating the intrabar fills of *stop* or *limit*
orders.

:::warning[Notice!]
The Bar Magnifier feature enhances the precision of assumptions
regarding price movements within a bar, but it does not facilitate the
determination of intrabar states or conditions based on the chart\'s
timeframe. Its primary function is to improve the accuracy of order
executions for stop orders, limit orders, and *trailing stop* orders
where the direction of price travel can significantly affect the
outcomes of these orders. However, the **Bar Magnifier cannot be used to
simulate intrabar executions of market orders**. Additionally, it\'s
important to note that conditions continue to be evaluated at the close
of each bar, in accordance with the Pine Script
[Execution Model](/pine-script-docs/language/execution-model).
:::

### Advanced features and integration 

#### Can my strategy script place orders with TradingView brokers? 

No, Pine Script™ strategies and indicators are not capable of directly
placing automated orders on exchanges. While Pine Script™ excels in
strategy development and backtesting, it doesn\'t offer the
functionality for live order execution with TradingView supported
brokers or other trading platforms. However, for traders interested in
integrating automation into their trading, there are indirect methods
available. These methods typically involve the use of external tools or
platforms that can interpret Pine Script™ alert signals and execute
trades accordingly. For detailed information on this topic, please refer
to
[this](/pine-script-docs/faq#can-my-pine-strategy-or-indicator-place-automated-orders-in-markets) related FAQ entry.

#### How can I implement a time delay between orders? 

To manage trade frequency and limit trades within a specific time frame,
a time delay strategy can be implemented between trades. This could be
beneficial for preventing rapid, successive trades or imposing a
cooldown period after certain negative criteria are met, such as a
series of consecutive losses. Here's how you can set up a time delay
between orders in Pine Script™:

1.  Check the time or bar of the last trade:
    -   Use
        [strategy.closedtrades.exit_time()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.closedtrades.entry_time)
        or
        [strategy.closedtrades.exit_bar_index()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.closedtrades.exit_bar_index)
        to determine the bar
        [time](https://www.tradingview.com/pine-script-reference/v5/#var_time)
        or
        [bar_index](https://www.tradingview.com/pine-script-reference/v5/#var_bar_index)
        when the last trade exited. These functions allow us to know
        when the last trade was closed, providing a reference point for
        implementing a delay.
2.  Define the delay period:
    -   Decide on the delay duration, whether in time units (minutes,
        hours, days) or a number of bars.
    -   For time-based delays, it\'s necessary to convert the chosen
        time unit into milliseconds, as
        [time variables](/pine-script-docs/concepts/time) in
        Pine Script™ operate in milliseconds.
3.  Create the delay condition:
    -   Perform a comparison between the current bar `time` or
        `bar_index` and the time or bar index of the last trade\'s exit.
    -   If the current time or bar count exceeds the specified delay
        duration, set a boolean variable to
        [true](https://www.tradingview.com/pine-script-reference/v5/#const_true).
        This variable acts as a control mechanism for allowing new
        trades.
4.  Incorporate delay in entry Condition:
    -   Include the delay boolean variable in your strategy\'s entry
        conditions. When this variable turns `true`, the strategy
        permits new trades, provided other trading criteria are also
        met.

In this script, we provide two methods for delaying orders. The first
method allows users to set a time-based delay, where they can choose the
duration and the unit of time (minutes, hours, or days) from the menu.
For instance, a user can set a delay of 20 minutes or 20 hours. The
second method involves delaying orders based on a specified number of
bars, such as waiting for at least 20 bars after the last trade. In this
example, we implement a 15-minute delay between orders and execute the
script on a 1-minute chart:

![image](@assets/images/Strategies-Advanced-features-and-integration-How-can-i-implement-a-time-delay-between-orders-1.png)

``` pine
//@version=5
strategy("time-delayed orders", overlay=true, max_labels_count = 500, max_lines_count = 500)

import PineCoders/Time/4 as PCtime

// Constants
string TU1 = "seconds", string TU2 = "minutes"     
string TU3 = "hours",   string TU4 = "days"            
string TU5 = "weeks",   string TU6 = "months" 
string DT1 = "bars",    string DT2 = "time"

// Tooltips for inputs
string D_TT = "Select the type of delay for executing orders. Choose 'bars' to set the delay based on a specific number
 of price bars since the last trade, or 'time' to set the delay based on a specific duration of time."
string N_TT = "Specify the number of bars or time units for the delay. This sets the duration before a new order is
 triggered. For time-based delays, pair this with the appropriate time unit (e.g., '20 hours' or '20 minutes'). For
 bar-based delays, simply specify the number of bars (e.g., '20 bars')."
string U_TT = "Choose the unit of time for the time-based delay.
 This setting is relevant only if the delay type is set to 'time'."

// User inputs for delay type, number of units/bars, and time units.
string delayTypeInput = input.string(DT2, "Delay type",                   tooltip = D_TT, options = [DT1, DT2])
int    nInput         = input.int(15,     "Number of bars or time units", tooltip = N_TT)
string unitsInput     = input.string(TU2, "Time Units",                   tooltip = U_TT, options = [TU1, TU2, TU3, TU4, TU5])

// Convert the time unit string input to a value in milliseconds for use in the time delay calculation since the last trade.
int mult = switch unitsInput
    TU1 => 1000     
    TU2 => 60000    
    TU3 => 3600000  
    TU4 => 86400000 
    TU5 => 604800000
    =>     2628003000

// Determine if time delay is used, or not.
bool useTimeDelay    = delayTypeInput == DT2
// Find the time and bar_index of the last trade exit.
int  timeOfExit      = strategy.closedtrades.exit_time(strategy.closedtrades - 1)
int  barOfExit       = strategy.closedtrades.exit_bar_index(strategy.closedtrades - 1)
// Calculate the time and number of bars since the last trade.
int  timeSinceExit   = time - timeOfExit
int  barsSinceExit   = bar_index - barOfExit
// Evaluate whether the specified delay, in terms of either time or bars, has elapsed since the last trade to allow a new trade entry.
bool timeAllowed     = (timeSinceExit >= nInput * mult or na(timeOfExit)) and useTimeDelay
bool barAllowed      = (bar_index - barOfExit >= nInput or na(barOfExit)) and not useTimeDelay
bool tradeAllowed    = timeAllowed or barAllowed
// Create a condition for trade entry and a variable that determines when trades exit.
bool entryCondition  = tradeAllowed and strategy.position_size == 0
bool tradeExited     = barOfExit == bar_index

// Execute an entry if `entryCondition` is true.
if entryCondition
    strategy.entry("Long", strategy.long)
    // Set label text: format time since last trade if time-based, or show bar count since otherwise.
    string labelTxt = useTimeDelay ? PCtime.formattedNoOfPeriods(timeSinceExit, unitsInput) : str.format("{0} bars", barsSinceExit)
    // We draw a line and label depicting the actual time or number of bars since the last trade was exited.
    label.new(bar_index, low, labelTxt,
         color     = color.new(color.lime, 80),
         textcolor = color.lime,
         style     = label.style_label_up
         )
    line.new(timeOfExit, low, time, low, xloc.bar_time,
         color = color.new(color.lime, 50),
         style = line.style_arrow_left,
         width = 2
         )

// Close the trade on every tenth bar if there is an open position.
if bar_index % 10 == 0
    strategy.close("Long")

// Highlight the background lime when the entry condition is true, and fuchsia when a trade is exited.
bgcolor(entryCondition ? color.new(color.lime, 85) : tradeExited ? color.new(color.fuchsia, 85) : na)
```

**In our script we:**

-   Offer a choice between two types of delays for trades: a specified
    number of time units or a specific number of chart bars between
    trades.
-   Utilize `strategy.closedtrades.exit_time()` for the time-based
    delay, or `strategy.closedtrades.exit_bar_index()` for the bar-based
    delay. These functions determine when the last trade was exited.
-   Compare the exit `time` or `bar_index` of the last trade with the
    current bar and the set delay, to check if the delay period has been
    surpassed.
-   Create a long entry order when either the `time` of a bar or its
    `bar_index` exceeds the set delay from the last active trade bar. No
    other conditions are used for entry in this demonstration, but users
    can add their own logic to these conditions.
-   Call the
    [strategy.close()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.close)
    function to close active trades after they have been open for 10
    bars. This is done to simply close active trades periodically.
-   Visually indicate the bar where the entry condition is satisfied by
    highlighting the background
    [lime](https://www.tradingview.com/pine-script-reference/v5/#const_color.lime)
    color, and
    [fuschia](https://www.tradingview.com/pine-script-reference/v5/#const_color.fuchsia)
    on the exit bar.
-   Draw an arrow-styled
    [line](/pine-script-docs/concepts/lines-and-boxes#lines) and a
    [label](/pine-script-docs/concepts/text-and-shapes#labels)
    between the entry and exit bars to display the actual elapsed time
    since the last trade was executed. This is shown either in the
    specified time units or as the number of bars that have passed.

**Limitations and considerations**

-   **Historical bars limitation:** In Pine Script™, strategies are
    [calculated at the
    close](https://www.tradingview.com/pine-script-docs/en/v5/language/Execution_model.html#calculation-based-on-historical-bars)
    of each bar, meaning time-based conditions can only be evaluated at
    that moment. This constraint implies that on historical bars,
    **delay times are assessed in increments equal to the chart bar\'s
    duration**.
-   **Session times:** Delays cannot be evaluated when the market is
    closed, as there are no price updates to trigger script execution.
    This means that if a delay were to extend beyond the end of a
    trading session, the delay condition cannot be identified until the
    script runs again on the next session. This would result in a longer
    than anticipated time between orders.
-   **Delay duration on different timeframes:** If your delay value is
    not divisible by the duration of a chart bar, each delay will last
    at least one additional chart bar. For instance, setting a delay of
    100 seconds on a 1-minute chart effectively means a minimum of two
    bars before the delay is exceeded.

#### How can I calculate custom statistics in a strategy? 

Calculating custom statistics allows for gaining deeper insights into
your strategy\'s performance during backtesting, beyond what is offered
by built-in metrics or the Strategy Tester panel. By customizing your
own metrics, you can adapt your backtesting to your specific evaluation
criteria. To effectively implement this, there are few steps to follow:

1.  **Initiating strategy orders:** To calculate custom statistics in a
    strategy, begin by issuing orders through strategy
    [order placement commands](/pine-script-docs/concepts/strategies#order-placement-commands), which mimics sending orders to a broker or exchange.
    This process involves the broker emulator, which simulates order
    execution when their predefined conditions are satisfied.
2.  **Monitoring order execution:** Observe changes in
    [built-in](/pine-script-docs/built-in-functions)
    variables such as
    [strategy.opentrades](https://www.tradingview.com/pine-script-reference/v5/#var_strategy.opentrades)
    and
    [strategy.closedtrades](https://www.tradingview.com/pine-script-reference/v5/#var_strategy.closedtrades)
    to track the execution of orders. Once an order is executed, various
    statistics can be calculated based on these order events.
3.  **Custom statistic calculations:** Custom statistics can be
    calculated by detecting order executions, tracking closed trades,
    monitoring entries into trades, and assessing if a trade is active.
    Using these states, you can begin to evaluate metrics throughout the
    script\'s runtime, summing values, or averaging others to calculate
    custom statistics on the trades that are simulated on the chart\'s
    history.

Our example script utilizes a moving average crossover strategy to
generate orders. It calculates custom statistics either throughout the
duration of trades or upon their conclusion. These statistics, along
with various strategy values, are displayed in the Data Window:

![image](@assets/images/Strategies-Advanced-features-and-integration-How-can-i-calculate-custom-statistics-in-a-strategy-1.png)

``` pine
//@version=5
strategy("Custom strat stats", "", true,
     initial_capital  = 10000,
     commission_type  = strategy.commission.percent,
     commission_value = 0.075,
     max_bars_back    = 1000
     )

// User input for maximum risk percentage of equity per trade.
float riskPctInput = input.float(1.0, "Maximum %Risk On Equity Per Trade", minval = 0., maxval = 100., step = 0.25) / 100.

//#region ———————————————————— Strategy calculations

// Round OHLC to chart prices.
float c   = math.round_to_mintick(close)
float maF = math.round_to_mintick(ta.sma(hlc3, 10))
float maS = math.round_to_mintick(ta.sma(hlc3, 60))
// Calculate entry points based on moving average crossovers, ensuring sufficient equity.
bool enterLong  = ta.crossover(maF,  maS) and strategy.equity > 0
bool enterShort = ta.crossunder(maF, maS) and strategy.equity > 0
// Determine exit points based on high/low channel breaches.
float stopLong  = ta.lowest(20)[1]
float stopShort = ta.highest(20)[1]
// ————— Position sizing.
// Calculate position size to align with the maximum risk on equity as per user input.
// This way, position sizes throttle with equity variations, but always incur the same % risk on equity.
// Note that we are estimating here. We do not yet know the actual fill price because the order will only be executed at the open of the next bar.
float riskOnEntry  = math.abs(c - (enterLong ? stopLong : enterShort ? stopShort : na))
float positionSize = strategy.equity * riskPctInput / riskOnEntry
// ————— Orders to broker emulator.
// Entries, which may include reversals. Don"t enter on first bars if no stop can be calculated yet.
if enterLong and not na(stopLong)
    strategy.entry("Long", strategy.long, qty = positionSize, comment = "►Long")
if enterShort and not na(stopShort)
    strategy.entry("Short", strategy.short, qty = positionSize, comment = "►Short")
// Modify existing exit orders using the current stop value.
strategy.exit("◄Long",  "Long",  stop = stopLong)
strategy.exit("◄Short", "Short", stop = stopShort)
//#endregion

//#region ———————————————————— Custom statistic calculations

// ————— Detect execution of orders based on changes in `strategy.*` variables.
// Track trade closure events.
bool tradeWasClosed  = ta.change(strategy.closedtrades) != 0
// Monitor entries into trades.
bool tradeWasEntered = ta.change(strategy.opentrades) > 0 or
 strategy.opentrades == strategy.opentrades[1] and tradeWasClosed or
 ta.change(strategy.closedtrades) > 1
// Check if a trade is currently active.
bool tradeIsActive   = strategy.opentrades != 0
// Calculate the number of trades entered.
float tradesEntered = ta.cum(tradeWasEntered ? 1 : 0)
// Calculate the percentage of bars involved in a trade.
float barsInTradePct = 100 * ta.cum(tradeIsActive ? 1 : 0) / bar_index
// Calculate average position size.
float avgPositionSize = ta.cum(nz(positionSize))[1] / tradesEntered
// Determine average percentage distance of entry stops.
float stopPct = riskOnEntry / c
float avgEntryStopPct = 100 * ta.cum(nz(stopPct)) / tradesEntered
// Calculate average distance to stop during trades in percentage.
var array<float> distancesToStopInPctDuringTrade = array.new_float(0)
var array<float> distancesToStopInPct            = array.new_float(0)
float stop = strategy.position_size > 0 ? stopLong : strategy.position_size < 0 ? stopShort : na
float distanceToStopInPct = 100 * math.abs(stop - c) / c
// Record and average distances to stop for each trade.
if tradeWasEntered
    // Start with an empty array for each trade.
    array.clear(distancesToStopInPctDuringTrade)
    // Add a new distance for each bar in the trade.
else if tradeIsActive
    array.push(distancesToStopInPctDuringTrade, distanceToStopInPct)
    // At the end of a trade, save the avg distance for that trade in our global values for all trades.
else if tradeWasClosed
    array.push(distancesToStopInPct, array.avg(distancesToStopInPctDuringTrade))
// Avg distance for all trades.
float avgDistancesToStop = array.avg(distancesToStopInPct)
// Calculate the maximum equity at risk for a trade based on the user-defined risk percentage.
float maxEquityToRisk = strategy.equity * riskPctInput
// Calculate the total monetary value of the position at the current market price.
float positionValue   = positionSize * close
// Determine the risk percentage of the trade relative to the entry price.
float priceRiskPct    = riskOnEntry / close
// Calculate the monetary risk of the trade based on position size and price risk.
float tradeRiskPct    = positionSize * riskOnEntry
//#endregion

//#region ———————————————————— Plots

// ————— Chart plots.
// Plot the MAs and stop price to the chart.
plot(maF,  "MA Fast")
plot(maS,  "MA Slow", color.silver)
plot(stop, "Stop",    color.fuchsia, 1, plot.style_circles)
// Plot a fuchsia dash for closed trades at the bottom and a lime plus sign for entered trades at the top of the chart.
plotchar(tradeWasClosed,  "tradeWasClosed",  "—", location.bottom, color.fuchsia, size = size.tiny)
plotchar(tradeWasEntered, "tradeWasEntered", "+", location.top,    color.lime,    size = size.tiny)
// Highlight the background while long and short positions are active.
bgcolor(strategy.position_size > 0 ? color.new(color.teal, 80) : strategy.position_size < 0 ? color.new(color.maroon, 80) : na)

// ————— Data Window plots.
display = display.data_window
plot(na,                     "════════ Risk",               display = display)
plot(strategy.equity,        "Equity",                      display = display)
plot(maxEquityToRisk,        "Max value of equity to risk", display = display)
plot(riskOnEntry,            "Risk On Entry",               display = display)
plot(positionSize,           "Position Size",               display = display)
plot(na,                     "════════ Stats",              display = display)
plot(tradesEntered,          "tradesEntered",               display = display)
plot(barsInTradePct,         "barsInTradePct",              display = display)
plot(avgPositionSize,        "avgPositionSize",             display = display)
plot(avgEntryStopPct,        "avgEntryStopPct",             display = display)
plot(avgDistancesToStop,     "avgDistancesToStop",          display = display)
plot(na,                     "════════ Misc.",              display = display)
plot(strategy.opentrades,    "strategy.opentrades",         display = display)
plot(strategy.closedtrades,  "strategy.closedtrades",       display = display)
plot(strategy.position_size, "strategy.position_size",      display = display)
plot(positionValue,          "Position's Value",            display = display)
plot(close,                  "Estimated entry Price",       display = display)
plot(priceRiskPct,           "Price Risk %",                display = display)
plot(tradeRiskPct,           "Trade Risk Value",            display = display)
plot(enterLong  ? 1 : 0,     "enterLong",                   display = display)
plot(enterShort ? 1 : 0,     "enterShort",                  display = display)
//#endregion
```

**In our script, we:**

-   Calculate a variety of custom metrics, including the average stop
    size, average position size, and the average percentage of bars
    involved in a trade across the dataset. These concepts are
    adaptable, allowing for the calculation of any specific metrics you
    might require for your script.
-   Utilize a position-sizing method to manage risk by adjusting the
    position size to risk a fixed percentage of equity. This technique
    maintains consistent risk exposure and prevents disproportionate
    risks by modifying position size based on stop distance, similar to
    the method shown
    [in this FAQ entry](/pine-script-docs/faq#how-can-iadjust-my-position-size-to-ensure-that-irisk-afixed-percentage-of-my-equity).
-   Incorporate trading costs. To ensure that a strategy performance
    report provides relevant and meaningful data, traders should include
    potential real-world costs in their strategy results. Failing to
    account for these costs can lead to an unrealistic perception of
    strategy performance and diminish the credibility of test results..
    Read more on that
    [here](/pine-script-docs/concepts/strategies#simulating-trading-costs).
-   Round the
    [open](https://www.tradingview.com/pine-script-reference/v5/#var_open),
    [high](https://www.tradingview.com/pine-script-reference/v5/#var_high),
    [low](https://www.tradingview.com/pine-script-reference/v5/#var_low)
    or
    [close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
    (OHLC) built-in variables to the symbol\'s precision. To maintain
    alignment between the prices displayed on charts, which adhere to
    tick precision, and the original values of the OHLC variables, it\'s
    important to round these variables accordingly. This rounding
    ensures that any statistics you calculate align within the
    [Strategy Tester](/pine-script-docs/concepts/strategies#strategy-tester) or with strategy order-related built-ins. We explain the
    implications of this further
    [here](/pine-script-docs/faq#why-do-the-ohlc-built-ins-sometimes-return-different-values-than-the-ones-shown-on-the-chart).

#### How do I incorporate leverage into my strategy? 

Incorporating leverage into Pine Script™ strategies enables traders to
simulate trading scenarios where they can control larger positions than
their actual account balance would typically permit. This feature is
useful for testing the impact of leverage on trading strategies within
the controlled environment of TradingView\'s strategy tester. Here's how
leverage can be effectively integrated into a Pine Script™ strategy:

-   Leverage allows traders to open positions significantly larger than
    their account balance by borrowing capital. This process amplifies
    both potential profits and losses, making it a powerful but risky
    tool.
-   Leverage in Pine Script™ is managed through margin requirements
    specified for long and short positions. These requirements determine
    the minimum portion of a position\'s value that must be covered by
    the trader\'s own capital.
-   Traders can set leverage by adjusting the \"Margin for long
    positions\" and \"Margin for short positions\" in the strategy\'s
    \"Properties\" tab or directly in the script using the `margin_long`
    and `margin_short` parameters in the
    [strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
    declaration function.

Setting a 20% margin ratio means that only 20% of the position\'s value
needs to be funded by the trader\'s balance, allowing positions up to
five times the account balance (leveraging 5:1). For example, with an
available balance of \$10,000 and a 20% margin setting, the strategy can
handle positions up to \$50,000.

:::warning[Notice!]
If a leveraged trade incurs significant losses that cause the trader\'s
portion of the balance to fall below the margin ratio, the broker
emulator will initiate a Margin Call by liquidating four times the
amount required to cover the loss in the simulation, preventing constant
Margin Call events on subsequent chart bars.
:::

For a detailed breakdown on incorporating leverage in your Pine Script™
strategies, see the dedicated [Help Center
article](https://www.tradingview.com/support/solutions/43000717375-how-do-i-simulate-trading-with-leverage/)
for more info.

#### Can you hedge in a Pine Script strategy? 

Hedging, the practice of offsetting risk in trading, cannot be directly
implemented in Pine Script™ strategies due to its design constraints.
Pine Script™, primarily designed for single-asset strategies, handles
positions sequentially, either long or short, and does not support the
simultaneous management of opposing positions within the same or
different assets.

Understanding hedging limits in Pine Script™:

-   **Nature of hedging:** Effective hedging often involves derivatives
    or related securities to mitigate risks against adverse movements in
    the primary position. It\'s akin to purchasing insurance; the cost
    is minimal relative to the hedge\'s coverage.
-   **Inefficacy of dual positions:** Attempting to \"hedge\" by
    concurrently opening a short position alongside a long one does not
    equate to genuine hedging. This approach only leads to additional
    transaction costs without providing the protective benefits of a
    hedge. Reducing the original position size could achieve a similar
    effect more efficiently.
-   **Broker emulator limitations:** The broker emulator can only
    simulate transactions on a single asset at a time and does not
    support simultaneous long and short positions. This inherently
    restricts the ability to execute strategies that require hedging
    across multiple positions, assets, or derivatives.
-   **Lack of options data:** Although it\'s possible to access options
    data in TradingView, Pine Script™ still does not support using
    options to hedge within strategy scripts. This limitation means
    users cannot employ options, a common hedging instrument, to
    mitigate risks directly in their strategies.

While hedging is a useful risk management strategy, its complexity and
reliance on opposing or multi-asset positions extend beyond the
capabilities of Pine Script™ strategies. Traders looking to implement
hedging must explore alternatives outside of Pine Script™ or adjust
their strategies within the scope of single-asset trading simulations.

:::warning[Notice!]
For those interested in suggesting enhancements to TradingView or Pine
Script™, we welcome you to share your ideas on the official [TradingView
subreddit](https://www.reddit.com/r/TradingView/). Our team regularly
reviews these suggestions, taking into account factors such as
popularity among users, alignment with our core business strategy, and
implementation feasibility. Based on these criteria, we may incorporate
your valuable feedback into future updates.
:::

#### Can I connect my strategies to my paper trading account? 

Currently, Pine Script™ does not support direct automated trading or the
placement of automated orders into TradingView\'s built-in [paper
trading
account](https://www.tradingview.com/support/solutions/43000516466-paper-trading-main-functionality/).
However, there are alternative methods available for those looking to
forward test their Pine Script™ strategies. Here are some insights and a
workaround to bridge this gap:

-   The broker emulator closely mimics a paper trading account by
    simulating orders and tracking theoretical positions and capital
    based on the data feeds of the assets on which strategies are
    executed. This feature serves as a method to validate and optimize
    strategies in a risk-free environment.
-   A practical workaround to simulate trading, similar to paper
    trading, involves using [alerts](/pine-script-docs/concepts/alerts) within strategies. These alerts are set up to generate
    signals based on theoretical order fills that match the strategy\'s
    criteria. This approach enables realtime testing of trading
    strategies against live market data by using alerts to mimic trading
    actions without the actual financial risk.
-   Alerts can be customized to include detailed results and performance
    metrics in the alert strings, providing a record of the strategy\'s
    theoretical fills and overall performance in realtime.

:::warning[Notice!]
When configuring alerts for forward testing, utilize a
[date filter](/pine-script-docs/faq#how-do-iimplement-date-time-range-filtering-in-strategies) initiating the date filter\'s start date to today\'s date.
This approach excludes historical trades from the broker emulator\'s
calculations, and any impact they had on current positions, trade sizes,
and available capital going forward in realtime. By doing so, you ensure
the broker emulator is in a neutral state at the time your alert begins
to run on the server.
:::

### Troubleshooting and specific issues 

#### Why are no trades executed after I added the strategy to the chart? 

If you\'ve implemented a [strategy](/pine-script-docs/concepts/strategies) and added it to your chart but observe that it doesn\'t
generate orders, leading to \"No data\" displayed in the \"List of
Trades\" and \"Overview\" tabs of the
[Strategy Tester](/pine-script-docs/concepts/strategies#strategy-tester), consider the following potential reasons and their
solutions:

-   **Incorrect script classification:** Ensure your script is correctly
    declared as a strategy using the
    [strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
    function as its [declaration
    statement](https://www.tradingview.com/pine-script-docs/en/v5/language/Script_structure.html#declaration-statement).
    Scripts declared with
    [indicator()](https://www.tradingview.com/pine-script-reference/v5/#fun_indicator)
    or
    [library()](https://www.tradingview.com/pine-script-reference/v5/#fun_library)
    are unable to generate orders.
-   **Lack of order placement commands:** Your strategy must use
    `strategy.*` commands (e.g.,
    [strategy.order()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.order)
    or
    [strategy.entry()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.entry))
    to place orders. See the strategy
    [order placement commands](/pine-script-docs/concepts/strategies#order-placement-commands) section in the User Manual for more information.
-   **Insufficient capital:** Verify that your strategy has enough
    initial capital to cover the position sizes it attempts to open.
    Remember, the cost of entering a futures contract position is the
    chart price multiplied by the
    [syminfo.pointvalue](https://www.tradingview.com/pine-script-reference/v5/#var_syminfo.pointvalue),
    which can be significantly greater than the chart price. For a quick
    fix, increase the initial capital to a very high value in the
    *Properties* tab.
-   **Total account loss:** Verify that the Strategy Tester tab indeed
    shows no trades, and it\'s not just an absence of trades on recent
    bars. It\'s possible that the simulated account balance has
    experienced a total loss of equity earlier in the available history.
    As a result, the account may lack sufficient capital to continue
    trading the symbol and fail to show trades only in the chart\'s
    recent history.
-   **No exit condition:** A frequent oversight in strategy creation is
    the establishment of entry conditions that rely on having no prior
    positions open, without incorporating a corresponding exit condition
    for those trades. Without explicit instructions to close an open
    position (for instance, through
    [strategy.close()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.close)
    or
    [strategy.exit()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy.exit)
    commands), the strategy may only display a single entry order early
    in the chart\'s history and the *List of Trades* tab. This lack of
    exit conditions leads to an absence of strategy results in the
    *Overview* tab since no trades are conclusively closed.
-   **Runtime errors:** Check for runtime errors indicated by a red
    exclamation mark on the chart pane next to the script\'s title.
    Resolve any issues by correcting the script as necessary.
-   **Unmet order conditions:** Ensure the conditions for placing orders
    are met within your script. Use visual plotting techniques like
    [plotshape()](https://www.tradingview.com/pine-script-reference/v5/#fun_plotshape)
    to debug and prove conditions. If necessary, adjust the conditions
    in your strategy\'s source code.

For more detailed guidance and troubleshooting tips, refer to our
dedicated article on this topic in the [Help
Center](https://www.tradingview.com/support/solutions/43000478450-i-ve-successfully-added-a-strategy-to-my-chart-but-it-doesn-t-generate-orders/).

#### Why is my strategy repainting? 

Repainting, in the context of TradingView, refers to a phenomenon where
script values or signals change retrospectively, creating a discrepancy
between historical data representation and realtime data behavior. This
discrepancy primarily arises due to the different ways in which scripts
process `historical versus
realtime data <PageRepainting_HistoricalVsRealtimeCalculations>`.

:::warning[Notice!]
When repainting occurs in strategies it also invalidates backtesting
results, as they are not representative of the strategy's behavior in
realtime.
:::

The following are the most commonly encountered issues that can lead to
discrepancies between the behavior of your strategy in realtime and
historical calculations:

-   **\`calc_on_every_tick\`:** When the
    [calc_on_every_tick](/pine-script-docs/concepts/strategies#calc-on-every-tick) setting is enabled in a strategy script, it recalculates
    with every price update, which may cause orders and alerts to
    trigger during the formation of a bar in realtime. This behavior
    contrasts with historical bars, where calculations are generally
    performed at the close of the bar, relying on a fixed, single set of
    data per bar. Realtime bars, on the other hand, receive multiple
    price updates before closing, leading to potential differences in
    strategy behavior due to the dynamic nature of the data compared to
    the static nature of calculations on historical bars when you reload
    the chart. To avoid repainting, set the `calc_on_every_tick`
    parameter to `false` in the
    [strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
    declaration statement.
-   **\`calc_on_order_fills\`:** The
    [calc_on_order_fills](/pine-script-docs/concepts/strategies#calc-on-order-fills) setting triggers a strategy to recalculate immediately
    after simulating an order fill. For example, this feature is
    particularly useful for strategies that rely on entry prices to set
    exit prices on the entry bar (Like
    [this one](/pine-script-docs/faq#how-can-iset-astop-loss-and-take-profit-level-as-apercentage-from-my-entry-point)), rather than waiting for the bar to close. However,
    employing this setting can introduce *lookahead bias* into your
    strategy, leading to potentially unrealistic outcomes. For instance,
    if a strategy\'s entry conditions are met within a bar that also
    triggers an exit, the strategy would execute an entry order within
    the same bar on the next tick. In historical simulations, such
    entries could occur at any of the bar\'s
    [open](https://www.tradingview.com/pine-script-reference/v5/#var_open),
    [high](https://www.tradingview.com/pine-script-reference/v5/#var_high),
    [low](https://www.tradingview.com/pine-script-reference/v5/#var_low)
    or
    [close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
    (OHLC) prices, depending on the simulated intrabar price movement.
    This could result in entry prices that are unrealistically
    favorable, such as entries at the absolute high or low of a bar,
    which could skew historical performance results. In realtime
    trading, however, such precise timing is unachievable, resulting in
    a difference of behavior of the strategy on historical and realtime
    data. To avoid repainting, set the `calc_on_order_fills` parameter
    to `false` in the
    [strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
    declaration statement.
-   **\`process_orders_on_close\`:** Since strategies and their alerts
    execute at the close of a bar, the next possible moment for an entry
    order to be filled is the beginning of the next bar. Therefore, by
    default, the broker emulator simulates order fills at the opening
    price of the bar immediately after the bar where the entry condition
    was met. However, the
    [process_orders_on_close](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Strategies.html#process-orders-on-close)
    setting uses the close price of the condition bar for its order
    prices, rather than the open of the next bar. The difference in
    these prices means the realtime behavior of the strategy differs
    from the results seen on historical bars. See `"Why
    are my orders executed on the bar following my triggers?" <PageFaq_Strategies_OrderExecutionAndManagement_WhyAreMyOrdersExecutedOnTheBarFollowingMyTriggers>` for more info. To avoid repainting, set the
    `process_orders_on_close` parameter to `false` in the
    [strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
    declaration statement.
-   **Incorrect alert type:** Each `strategy.*()` order function comes
    with integrated [alert](/pine-script-docs/concepts/alerts)
    capability, called [order fill
    events](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Alerts.html#order-fill-events),
    that trigger upon the fulfillment of an order by the broker
    emulator. Strategy *order fill alerts* are superior to using the
    [alert()](https://www.tradingview.com/pine-script-reference/v5/#fun_alert)
    function in strategies because they are inherently synchronized with
    the behavior of the broker emulator, versus the logic of the script.
    This synchronization reduces the likelihood of
    [repainting](/pine-script-docs/concepts/repainting),
    improving the reliability of the alerts. For more on the different
    types of alerts and how to use them, see
    [this FAQ](/pine-script-docs/faq#how-do-imake-an-alert-available-from-my-script) entry.
-   **Using \`request.security()\`:** When requesting values from a
    higher timeframe, they are subject to repainting since realtime bars
    can contain unconfirmed information from developing HTF bars, and
    the script may adjust the times that new values come in on
    historical bars. To avoid repainting HTF data, one must ensure that
    the function only returns confirmed values with consistent timing on
    all bars, regardless of bar state. See
    `` Repainting \`request.security()\` calls <PageRepainting_HistoricalVsRealtimeCalculations_RepaintingRequestSecurityCalls> `` and
    [Avoiding repainting](/pine-script-docs/concepts/other-timeframes-and-data#avoiding-repainting) for detailed guidance.

Although these are the most common causes of repainting in strategies
summarized, they are not the only causes. For additional information and
a broader understanding of the causes of repainting, consult the section
on [repainting](PageRepainting) in the Pine Script™ User Manual.

#### How do I turn off alerts specifically for my stop loss and take profit orders? 

In automated trading strategies, it\'s common practice to set stop-loss
and take-profit orders simultaneously with the entry order using the
entry alert. These orders are designed to execute automatically on the
exchange, making alerts for their fills sometimes unnecessary or even
problematic, especially when integrated with third-party order execution
engines or custom applications. Here\'s how you can manage order fill
alerts for a specific order, disabling them when unnecessary:

-   **Understanding the role of alerts:** Each `strategy.*()` order
    function comes with integrated
    [alert](/pine-script-docs/concepts/alerts) capability,
    called [order fill
    events](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Alerts.html#order-fill-events),
    that trigger upon the fulfillment of an order by the broker
    emulator. However, in cases where stop-loss and take-profit orders
    are managed externally by the exchange or an automated system,
    receiving alerts for these fills can lead to redundancy and
    logistical issues.
-   **Disabling alerts for specific orders:** To prevent alerts from
    firing for stop-loss and take-profit order fills simulated by the
    broker emulator, strategy
    [order placement commands](/pine-script-docs/concepts/strategies#order-placement-commands) provide a parameter called `disable_alert`. By setting
    this parameter to `true`, you can effectively suppress alerts for
    these orders.
-   **Implementation:** When defining your exit functions or any other
    *order placement commands* you wish to suppress alerts for, you can
    include the `disable_alert` parameter and set it to `true`. This
    adjustment ensures that while the broker emulator will still
    simulate the fills for these orders, no alerts will be triggered for
    them.

``` pine
// Example of disabling order fill alerts for a stop and take-profit order.
strategy.exit("Exit", stop = stopLevel, limit = limitLevel, disable_alert = true)
```

By selectively disabling alerts for stop-loss and take-profit orders,
traders can eliminate unnecessary notifications and avoid potential
complications with automated order execution systems, ensuring that
actions are taken only when needed.

## Strings and Formatting 

-   [How can I place text on the chart?](/pine-script-docs/faq#how-can-iplace-text-on-the-chart)
-   [How can I position text on either side of a single bar?](/pine-script-docs/faq#how-can-iposition-text-on-either-side-of-asingle-bar)
-   [How can I lift plotshape() text up?](/pine-script-docs/faq#how-can-ilift-plotshape-text-up)
-   [How can I print a value at the top right of the chart?](/pine-script-docs/faq#how-can-iprint-avalue-at-the-top-right-of-the-chart)
-   [How can I split a string into characters?](/pine-script-docs/faq#how-can-isplit-astring-into-characters)

### How can I place text on the chart? 

You can display text using one of the following methods:

-   The
    [plotchar()](https://www.tradingview.com/pine-script-reference/v5/#fun_plotchar)
    or
    [plotshape()](https://www.tradingview.com/pine-script-reference/v5/#fun_plotshape)
    functions for static text.
-   [Labels](/pine-script-docs/concepts/text-and-shapes#labels),
    when you need to display dynamic text that may vary bar to bar.
-   [Tables](/pine-script-docs/concepts/tables), for showcasing
    either static or dynamic text, and they remain fixed within the
    visual area of the chart or indicator.

The `plotchar()` or `plotshape()` functions are useful to display fixed
text on bars. There is no limit to the number of bars you may use those
functions on, but you cannot decide at runtime which text to print.
While a single `plotchar()` function call can print only one character
on a bar, the text parameter of `plotshape()` allows you to plot a
string. When you want to print two different characters on bars, each
depending on a condition that can only be evaluated at runtime, you must
use two distinct calls, each one printing on a different condition:

``` pine
//@version=5
indicator("plotchar text demo", "", true)
float rsi   = ta.rsi(close, 14)
bool  rsiUp = ta.crossover( rsi, 50)
bool  rsiDn = ta.crossunder(rsi, 50)
plotchar(rsiUp, "Up",   "▲", location.belowbar, color.lime,    text = "RSI Up",   size = size.tiny)
plotchar(rsiDn, "Down", "▼", location.abovebar, color.fuchsia, text = "RSI Down", size = size.tiny)
```

We need two distinct calls here because the argument to the char
parameter in `plotchar()` must be of "input string" type, which means it
can be determined by an input, but not calculated dynamically at
runtime. This for example, would not work:

``` pine
plotchar(rsiUp or rsiDn, "Up/Down", rsiUp ? "▲" : "▼", location.top, size = size.tiny)
```

[Labels](/pine-script-docs/concepts/text-and-shapes#labels) are
particularly helpful when you need to display text that varies from one
bar to another. For instance, if you want to depict values like pivot
levels, which are unpredictable before the execution of the script,
labels are necessary. However, a script can only display a limited
number of labels. By default, this limit is set to approximately the 50
most recent labels drawn by the script. You can extend this limit up to
500 by adjusting the `max_labels_count` parameter in the
[indicator()](https://www.tradingview.com/pine-script-reference/v5/#fun_indicator)
or
[strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
functions.

The following demonstrates how labels can be used to display text
similar to our initial example using `plotchar()`. Notably, both the
text and the position of the label can now be determined at runtime,
thus allowing the use of \"series string\" arguments. We conditionally
set the attributes of the labels and require only a single label
function:

``` pine
//@version=5
indicator("plotchar demo", "", true)
float rsi   = ta.rsi(close, 14)
bool  rsiUp = ta.crossover( rsi, 50)
bool  rsiDn = ta.crossunder(rsi, 50)
if rsiUp or rsiDn
    string labelText = rsiUp ? "▲\nRSI Up"   : "RSI Down\n▼"
    color  textColor = rsiUp ? color.lime    : color.fuchsia
    string labelPos  = rsiUp ? yloc.belowbar : yloc.abovebar
    label.new(bar_index, na, labelText, yloc = labelPos, color = color(na), textcolor = textColor)
```

[Tables](/pine-script-docs/concepts/tables) are useful to
display text that floats in a fixed position of the indicator's visual
space, untethered to chart bars. Composed of cells set in a grid of rows
and columns, they parallel the structure of a spreadsheet. Tables
provide a structured way of arranging and presenting information, which
can be advantageous when displaying multiple variables or parameters.

One of the unique aspects of tables is that their contents always
reflect the final state of the table from the script\'s last execution.
This means that the variable contents displayed in tables do not change
as users move their cursor over specific chart bars, differentiating
tables from labels or `plotchar()`.

In the following example, we utilize a table to illustrate the value of
the RSI. This is a departure from the previous examples where we only
displayed when the RSI was above or below the 50 level. As these points
on historical bars are not visible, we provide additional information on
the RSI by showcasing the actual RSI value.

``` pine
//@version=5
indicator("RSI Table", "", true)

var table rsiDisplay = table.new(position.top_right, 1, 1, bgcolor = color.gray, frame_width = 2, frame_color = color.black)
float rsi = ta.rsi(close, 14)
if barstate.isfirst
    table.cell(rsiDisplay, 0, 0, "", text_color = color.white)
else if barstate.islast
    table.cell_set_text(rsiDisplay, 0, 0, str.format("RSI: {0, number, #.##}", rsi))
```

### How can I position text on either side of a single bar? 

The positioning of the label relative to a bar can be controlled by
using label styles such as `style = label.style_label_left`. It\'s
important to clarify that \"left\" or \"right\" in this context refers
to the position of the pointer, not the label. Consequently, when
\"left\" is selected, the label actually appears on the right side of
the bar due to the position of the pointer. To manage the alignment of
the text within the label, use `textalign = text.align_left`. Lastly, to
only display the text without any background color, you can make the
label\'s background color transparent or set the color to
[na](https://www.tradingview.com/pine-script-reference/v5/#var_na).

The following three labels are all positioned on the chart's last bar:

![image](@assets/images/Strings-and-formatting-How-can-i-position-text-on-either-side-of-a-single-bar-1.png)

``` pine
//@version=5
indicator("Text position demo", "", true)

// @function            Prints a label with the specified text at a specific position and alignment.
// @param txt       (string) The text to be displayed in the label.
// @param pos       (string) The label style.
// @param align         (string) The horizontal alignment of text within the label.
// @returns             (void) Function has no explicit return.
print(string txt, string pos, string align) =>
    var label lbl = label.new(na, na, na, xloc.bar_index, yloc.price, color(na), pos, color.gray, size.huge, align)
    label.set_xy(lbl, bar_index, ta.highest(10)[1])
    label.set_text(lbl, txt)

print("123\nRL", label.style_label_left,   text.align_left)
print("123\nLR", label.style_label_right,  text.align_right)
print("123\nC",  label.style_label_center, text.align_center)
```

### How can I lift plotshape() text up? 

To raise the text in
[plotshape()](https://www.tradingview.com/pine-script-reference/v5/#fun_plotshape),
you will need to use the newline character (n) followed by a
non-printable special character - U+200E. The Unicode character U+200E,
also known as the \"Left-to-Right Mark\", is a \"Zero Width Space\" used
to control the directionality of text display, without adding any actual
space or visible content. The latest version of the Pine Script™ Editor
makes the special character U+200E visible and it\'s highlighted in red,
represented as \[U+200E\].

When you want the text to go upwards, the U+200E character must be the
last character in the string. On the other hand, when plotting under the
bar and you want the text to go downwards, it should be the first
character in the string.

You can use [this online
tool](https://unicode-table.com/en/tools/generator/) to generate a
U+200E character that can be copied and pasted.

Here\'s an example of how you can implement this:

``` pine
//@version=5
indicator("Lift text demo", "", true)

// The non-printing character U+200E is now visible in Pine editor as [U+200E].
// It's used in conjunction with "\n" to control text placement.
plotshape(true, "", shape.arrowup,   location.abovebar, color.green,  textcolor = color.green,  text = "A")
plotshape(true, "", shape.arrowup,   location.abovebar, color.lime,   textcolor = color.lime,   text = "B\n‎")
plotshape(true, "", shape.arrowdown, location.belowbar, color.red,    textcolor = color.red,    text = "C")
plotshape(true, "", shape.arrowdown, location.belowbar, color.maroon, textcolor = color.maroon, text = "‎\nD")
```

Notice the lettering does not overlap above or below the bars, and each
character is stacked vertically:

![image](@assets/images/Strings-and-formatting-How-can-i-lift-plotshape-text-up-1.png)

### How can I print a value at the top right of the chart? 

To print a value at the top right of the chart, you can refer to
[this](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Tables.html?highlight=tables#placing-a-single-value-in-a-fixed-position)
specific example in the Pine Script™ User Manual which utilizes a
[table](/pine-script-docs/concepts/tables) for this purpose.

### How can I split a string into characters? 

You can split a string into individual characters using the
[str.split()](https://www.tradingview.com/pine-script-reference/v5/#fun_str.split)
function with an empty string (\"\") as the separator argument. Here is
a code example:

``` pine
//@version=5
indicator("Split a string into characters")

// @function            Prints a label with the specified text at the current bar.
// @param txt       (string) The text to be displayed in the label.
// @returns             (void) Function has no explicit return.
print(string txt) =>
    var label = label.new(na, na, na, xloc.bar_index, yloc.price, color(na), label.style_none, chart.fg_color, size.large, text.align_left)
    label.set_xy(label, bar_index, ta.highest(10)[1])
    label.set_text(label, txt)

string sourceStringInput = input("123456789")
var array<string> charactersArray = str.split(sourceStringInput, "")

print(str.format("sourceStringInput: {0}\n", sourceStringInput))
print(str.format("charactersArray: {0}", charactersArray))
```

In this script, `sourceStringInput` is the string that you want to
split. The function
[str.split()](https://www.tradingview.com/pine-script-reference/v5/#fun_str.split)
breaks `sourceStringInput` into an array of individual characters, which
we store in `charactersArray`. The `print()` function is used to display
the original string and the array of split characters on the chart.

## Techniques 

-   `` How can I prevent the \`x1\` is too far from the current \`bar_index\` error? <PageFaq_Techniques_HowCanIPreventTheX1IsTooFarFromTheCurrentBarindexError> ``
-   `` How can I update the \`x2\` values or the right side of all lines and boxes created using \`array.new_line()\`
    or \`array.new_box()\` functions? <PageFaq_Techniques_HowCanIUpdateTheX2ValuesOrTheRightSideOfAllLinesAndBoxesCreatedUsingArraynewlineOrArraynewboxFunctions> ``
-   `` How to avoid repainting when NOT using the \`request.security()\` function? <PageFaq_Techniques_HowToAvoidRepaintingWhenNotUsingTheRequestsecurityFunction> ``
-   [How can I trigger a condition only when a number of bars have elapsed since the last condition occurred?](/pine-script-docs/faq#how-can-itrigger-acondition-only-when-anumber-of-bars-have-elapsed-since-the-last-condition-occured)
-   [How can my script identify what chart type is active?](/pine-script-docs/faq#how-can-my-script-identify-what-chart-type-is-active)
-   [How can I plot the chart's visible high and low?](/pine-script-docs/faq#how-can-iplot-the-charts-visible-high-and-low)
-   [How can I remember the last time a condition occurred?](/pine-script-docs/faq#how-can-iremember-the-last-time-acondition-occured)
-   [How can I plot the previous and current day's open?](/pine-script-docs/faq#how-can-iplot-the-previous-and-current-days-open)
-   [How can I count the occurrences of a condition in the last x bars?](/pine-script-docs/faq#how-can-icount-the-occurences-of-acondition-in-the-last-xbars)
-   [How can I implement an On/Off switch?](/pine-script-docs/faq#how-can-iimplement-an-on-off-switch)
-   [How can I allow transitions from condition A►B or B►A, but not A►A nor B►B?](/pine-script-docs/faq#how-can-iallow-transitions-from-condition-abor-babut-not-aanor-bb)
-   [Can I merge two or more indicators into one?](/pine-script-docs/faq#can-imerge-two-or-more-indicators-into-one)
-   [How can I rescale an indicator from one scale to another?](/pine-script-docs/faq#how-can-irescale-an-indicator-from-one-scale-to-another)
-   [How can I calculate my script's run time?](/pine-script-docs/faq#how-can-icalculate-my-scripts-run-time)
-   [How can I save a value when an event occurs?](/pine-script-docs/faq#how-can-isave-avalue-when-an-event-occurs)
-   [How can I count touches of a specific level?](/pine-script-docs/faq#how-can-icount-touches-of-aspecific-level)
-   [How can I know if something is happening for the first time since the beginning of the day?](/pine-script-docs/faq#how-can-iknow-if-something-is-happening-for-the-first-time-since-the-begining-of-the-day)
-   [How can I optimize Pine Script™ code?](/pine-script-docs/faq#how-can-ioptimize-pine-script-code)
-   [How can I access a stock's financial information using Pine Script™?](/pine-script-docs/faq#how-can-iaccess-astocks-financial-information-using-pine-script)
-   [How can I find the maximum value among the last pivots?](/pine-script-docs/faq#how-can-ifind-the-maximum-value-among-the-last-pivots)
-   [How can I display plot values in the chart's scale?](/pine-script-docs/faq#how-can-idisplay-plot-values-in-the-charts-scale)
-   [How can I reset a sum on a condition?](/pine-script-docs/faq#how-can-ireset-asum-on-acondition)
-   [How can I accumulate a value for two exclusive states?](/pine-script-docs/faq#how-can-iaccumulate-avalue-for-two-exclusive-states)
-   [How can I organize my script's inputs in the Settings/Inputs tab?](/pine-script-docs/faq#how-can-iorganize-my-scripts-inputs-in-the-settings-inputs-tab)

### How can I prevent the \`x1\` is too far from the current \`bar_index\` error? 

To avoid the \'*x is too far from the current bar_index*\' error, avoid
creating objects too distant from the bar of origin. This issue arises
due to the existing restriction that an x point on a
[line](/pine-script-docs/concepts/lines-and-boxes#lines),
[label](/pine-script-docs/concepts/text-and-shapes#labels), or
[box](/pine-script-docs/concepts/lines-and-boxes#boxes) should not
be either 10000 bars or more in the past or over 500 bars in the future
relative to the bar from which it\'s drawn.

If you need to exceed these limits, use the
[xloc.bar_time](https://www.tradingview.com/pine-script-reference/v5/#var_xloc.bar_time)
in place of the `xloc` parameter, and use
[time](https://www.tradingview.com/pine-script-reference/v5/#fun_time)
as an alternative to
[bar_index](https://www.tradingview.com/pine-script-reference/v5/#var_bar_index)
for the `x` arguments. The advantage of this method is that objects
drawn based on time do not face the same limitations.

### How can I update the \`x2\` values or the right side of all lines and boxes created using \`array.new_line()\` or \`array.new_box()\` functions? 

You can accomplish this by storing your lines or boxes in an array and
then implementing a
[for\...in](https://www.tradingview.com/pine-script-reference/v5/#op_for...in)
loop to iterate over each line or box to revise the `x2` value using
[line.set_x2()](https://www.tradingview.com/pine-script-reference/v5/#fun_line.set_x2)
or
[box.set_right()](https://www.tradingview.com/pine-script-reference/v5/#fun_box.set_right)
functions. Here\'s a simple illustration using lines:

``` pine
//@version=5
indicator("Update x2 demo", "", true)

int activeLevelsInput = input.int(10, "Number of levels")
int pivotLegsInput    = input.int(5,  "Pivot length")

// Save pivot prices.
float pHi = ta.pivothigh(pivotLegsInput, pivotLegsInput)
// Initialize an array for lines on the first bar, sized to match the count of levels to track.
var array<line> pivotLines = array.new<line>(activeLevelsInput)

// Check for a pivot. Add a new line to the array. Remove and delete the oldest line.
if not na(pHi)
    line newPivotLine = line.new(bar_index[pivotLegsInput], pHi, bar_index, pHi)
    pivotLines.push(newPivotLine)
    pivotLines.shift().delete()

// Update all line x2 values.
if barstate.islast
    for eachLine in pivotLines
        eachLine.set_x2(bar_index)
```

### How to avoid repainting when NOT using the \`request.security()\` function? 

[Repainting](/pine-script-docs/concepts/repainting) in the
context of Pine Script™ refers to the phenomenon where indicators and
strategies appear to alter their output upon refreshing the page versus
what\'s observed in realtime, presenting a challenge for accurate
analysis and decision-making. It\'s an issue that can affect a
significant portion of scripts, but understanding repainting is crucial
for mitigating its effects and developing reliable tools.

**Understanding repainting**

The most common form of repainting occurs due to discrepancies between
the static nature of historical data and the dynamic nature of realtime
data. While historical bars present a single set of Open, High, Low, and
Close (OHLC) data, realtime bars continuously update with new prices
until the bar closes. This difference can cause scripts to exhibit
different behaviors when analyzing historical versus realtime data.

**Common misconceptions**

It\'s essential to recognize that not all forms of repainting are
inherently deceptive or detrimental. Many useful indicators, like the
MACD and the RSI, update their values in realtime and stabilize once the
bar closes, reflecting a benign form of repainting that doesn\'t
necessarily undermine their utility.

**Strategies to avoid repainting**

For the majority of cases, repainting occurs when a script can calculate
on fluctuating price updates as a bar forms, which may differ from the
stable values observed on historical or fully-formed bars. To ensure
consistency between historical and realtime calculations and avoid this
type of repainting, consider the following strategies:

-   **Use confirmed values:** Incorporate data from fully formed bars
    into your calculations. This approach relies on stable, confirmed
    values, reducing the likelihood of discrepancies between realtime
    and historical data.
-   **Alerts on bar close:** Configure alerts to trigger at the close of
    a bar. By doing so, alerts are based on confirmed data, aligning
    realtime notifications with historical values. Read more about
    repainting alerts in
    [this FAQ entry](/pine-script-docs/faq#why-is-my-alert-firing-when-its-not-supposed-to).
-   **Leverage previous bar\'s data:** Utilizing data from the previous
    bar ensures reliance on confirmed information, avoiding the
    unpredictability of intrabar price movements.
-   **Open value calculations:** Though less common, using the open
    value of the current bar for calculations can also mitigate
    repainting since the open price remains constant through the bar\'s
    duration.

For further exploration of these methods, the PineCoders publication
[\"How to avoid repainting when NOT using
security()\"](https://www.tradingview.com/script/s8kWs84i-How-to-avoid-repainting-when-NOT-using-security/)
offers additional insight and detailed examples. Additionally, for a
more nuanced examination, the Pine Script™
[User Manual](/pine-script-docs/concepts/repainting) addresses
the intricacies of repainting in detail.

### How can I trigger a condition only when a number of bars have elapsed since the last condition occurred? 

The
[ta.barssince()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.barssince)
function allows you to implement a condition when a certain number of
bars have elapsed since the last occurrence of that condition.

Here\'s a sample script to demonstrate:

![image](@assets/images/Techniques-How-can-i-trigger-a-condition-only-when-a-number-of-bars-have-elapsed-since-the-last-condition-occured-1.png)

``` pine
//@version=5
indicator("Bars since demo", overlay = true)
int  lengthInput = input.int(3, "Length")
bool cond = close > open and close[1] > open[1]
int  count = ta.barssince(cond[1]) + 1
bool trigger = cond and count > lengthInput
plot(cond ? 0 : count, "Count", display = display.data_window)
plotchar(cond)
plotchar(trigger, "", "O", color = color.red)
```

In this script, the `cond` condition is established which checks whether
the
[close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
value was greater than the
[open](https://www.tradingview.com/pine-script-reference/v5/#var_open)
value for two consecutive bars. A blue star is plotted whenever this
condition is satisfied. Then, a `trigger` variable is defined, which
becomes true only when two specific conditions are met: first, the
`cond` condition must be met; second, the number of bars elapsed since
the `cond` was last true must be greater than the value determined by
`lengthInput`. A red \"O\" is plotted on the chart, overlaying the blue
star, each time these conditions are met. In addition to these visual
markers, the count since the `cond` was last true is also displayed in
the data window.

### How can my script identify what chart type is active? 

The recent release of Boolean
[built-in](/pine-script-docs/built-in-functions)
functions within the `chart.*` namespace now enables your script to
detect the type of chart your script is running on:

``` pine
//@version=5
indicator("Chart type", "", true)

chartTypeToString() =>
    string result = switch
        chart.is_standard   => "Standard"
        chart.is_heikinashi => "Heikin-Ashi"
        chart.is_kagi       => "Kagi"
        chart.is_linebreak  => "Line Break"
        chart.is_pnf        => "Point and Figure"
        chart.is_range      => "Range"
        chart.is_renko      => "Renko"

if barstate.islastconfirmedhistory
    var table display = table.new(position.bottom_right, 1, 1, bgcolor = chart.fg_color)
    table.cell(display, 0, 0, str.format("Chart type: {0}", chartTypeToString()), text_color = chart.bg_color)
```

This script defines a function, `chartTypeToString()`, which utilizes
the [chart.*` `built-ins](/pine-script-docs/built-in-functions) to identify the chart type and convert this information into
a string. It then displays the detected chart type in a table on the
chart.

### How can I plot the chart\'s visible high and low? 

To plot the high and low within the range of visible bars, a script can
utilize the
[chart.left_visible_bar_time](https://www.tradingview.com/pine-script-reference/v5/#var_chart.left_visible_bar_time)
and
[chart.right_visible_bar_time](https://www.tradingview.com/pine-script-reference/v5/#var_chart.right_visible_bar_time)
built-ins. These variables allow the script to identify the visible
range of bars on the chart and calculate the maximum or minimum values
within that range. The
[VisibleChart](https://www.tradingview.com/script/j7vCseM2-VisibleChart/)
library by [PineCoders](https://www.tradingview.com/u/PineCoders/)
offers such functionality with its `high()` and `low()` functions, which
dynamically calculate the highest and lowest values of the currently
visible bars.

Below is a script that uses these functions to create two horizontal
[lines](/pine-script-docs/concepts/lines-and-boxes#lines) on the
chart, signifying the highest and lowest price points within the range
of visible bars. [Labels](/pine-script-docs/concepts/text-and-shapes#labels) are generated for these lines, displaying both the price and
the corresponding timestamp for each high and low point.As the chart is
manipulated through scrolling or zooming, these lines and labels
dynamically update to reflect the highest and lowest values of the newly
visible bars:

![image](@assets/images/Techniques-How-can-i-plot-the-charts-visible-high-and-low-1.png)

``` pine
//@version=5
indicator("Chart's visible high/low", "", true)

import PineCoders/VisibleChart/4 as PCvc

// Calculate the chart's visible high and low prices and their corresponding times.
int x1 = PCvc.highBarTime()
int x2 = PCvc.lowBarTime()
float chartHi = PCvc.high()
float chartLo = PCvc.low()

// Draw lines and labels on the last bar.
if barstate.islast
    line.new(x1, chartHi, x2, chartHi, xloc.bar_time, extend.both, color.lime)
    line.new(x1, chartLo, x2, chartLo, xloc.bar_time, extend.both, color.fuchsia)
    string hiTxt = str.format("{0}\n{1}", str.tostring(chartHi, format.mintick), str.format_time(x1, format = "dd/MM/yy @ HH:mm"))
    string loTxt = str.format("{0}\n{1}", str.tostring(chartLo, format.mintick), str.format_time(x2, format = "dd/MM/yy @ HH:mm"))
    label.new(x1, chartHi, hiTxt, xloc.bar_time, yloc.price, color.new(color.lime, 80),    label.style_label_down, color.lime)
    label.new(x2, chartLo, loTxt, xloc.bar_time, yloc.price, color.new(color.fuchsia, 80), label.style_label_up,   color.fuchsia)
```

Values derived from visible chart variables are dynamic, meaning they
may alter throughout the script\'s runtime. To accurately reflect the
entire visible range, the script defers drawing the lines until the last
bar (using
[barstate.islast](https://www.tradingview.com/pine-script-reference/v5/#var_barstate.islast)).
This not only ensures that the calculations have accounted for the
entire visible range, but also guarantees that the lines are drawn only
once. By initializing the visible chart values in the
[global scope](/pine-script-docs/faq#what-does-scope-mean) and outside the local block defined by
[barstate.islast](https://www.tradingview.com/pine-script-reference/v5/#var_barstate.islast),
the functions are given the ability to process the entire dataset before
determining the final high and low values.

:::warning[Notice!]
Keep in mind that when your script uses
[chart.left_visible_bar_time](https://www.tradingview.com/pine-script-reference/v5/#var_chart%7Bdot%7Dleft_visible_bar_time)
or
[chart.right_visible_bar_time](https://www.tradingview.com/pine-script-reference/v5/#var_chart%7Bdot%7Dright_visible_bar_time),
your script will recalculate on all bars each time the user scrolls or
zooms their chart. To provide script users with the best experience you
should strive to keep calculations to a minimum and use efficient code
so that traders are not always waiting for your script to recalculate
every time they scroll or zoom their chart.
:::

For more information and helpful tips, refer to the
[VisibleChart](https://www.tradingview.com/script/j7vCseM2-VisibleChart/)
library\'s documentation.

### How can I remember the last time a condition occurred? 

To remember the last time a condition occurred, you can use various
methods.

-   **Method 1** - Use the
    [built-in](/pine-script-docs/built-in-functions)
    function
    [ta.barssince()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.barssince).
    This is the simplest way to track the distance from the condition.
-   **Method 2** - Save the
    [bar_index](https://www.tradingview.com/pine-script-reference/v5/#var_bar_index)
    when the condition occurs. Then, calculate the difference between
    the current
    [bar_index](https://www.tradingview.com/pine-script-reference/v5/#var_bar_index)
    and the saved one to determine the distance between them.
-   **Method 3** - This method is an alternative to
    [ta.barssince()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.barssince).
    As the script executes on each successive bar, it watches for the
    condition. When the condition is encountered, the distance is
    initialized to 0. The distance is then incremented by one on each
    bar until the condition is reencountered.
-   **Method 4** - Instead of referencing the value using a historical
    offset with the number of bars since the occurrence, this method
    saves the value itself on each condition occurrence. This is the
    most efficient method if you are looking for the value rather than
    the distance itself.

In the first three methods, the resulting value can be used as an index
with the
[\[\]](https://www.tradingview.com/pine-script-reference/v5/#op_%5B%5D)
history-referencing operator because it accepts a
["series"](/pine-script-docs/language/type-system#series) value, i.e., a value that can change on each bar. This
demonstrates the fact that we derive the distance in bars since the
condition.

The fourth method is more efficient because it avoids referencing the
series multiple times throughout its history. Instead, it saves the
value of the series at a specific point in time. This method also
reduces the risk of runtime errors in your scripts if the size of the
historical reference is [too
large](https://www.tradingview.com/pine-script-docs/en/v5/Error_messages.html#pine-script-cannot-determine-the-referencing-length-of-a-series-try-using-max-bars-back-in-the-indicator-or-strategy-function).

Here\'s a script that demonstrates these methods:

``` pine
//@version=5
indicator("Track distance from condition", "", true)
// Plot the high/low from bar where condition occurred the last time.

// Conditions
bool upBar = close > open
bool dnBar = close < open
bool up3Bars = dnBar and upBar[1] and upBar[2] and upBar[3]
bool dn3Bars = upBar and dnBar[1] and dnBar[2] and dnBar[3]
display = display.data_window

// Method 1: Using "ta.barssince()".
plot(high[ta.barssince(up3Bars)], color = color.new(color.blue, 80), linewidth = 16)
plot(low[ta.barssince(dn3Bars)],  color = color.new(color.red,  80), linewidth = 16)
plot(ta.barssince(up3Bars), "1. ta.barssince(up3Bars)", display = display)
plot(ta.barssince(dn3Bars), "1. ta.barssince(dn3Bars)", display = display)

// Method 2: This method involves storing the `bar_index` value when a specific condition is met.
var int barWhenUp = na
var int barWhenDn = na
if up3Bars
    barWhenUp := bar_index
if dn3Bars
    barWhenDn := bar_index
plot(high[bar_index - barWhenUp], color = color.new(color.blue, 70), linewidth = 8)
plot(low[bar_index  - barWhenDn], color = color.new(color.red,  70), linewidth = 8)
plot(bar_index - barWhenUp, "2. bar_index - barWhenUp", display = display)
plot(bar_index - barWhenDn, "2. bar_index - barWhenDn", display = display)

// Method 3: This method manually replicates the functionality of the "ta.barssince()" function.
var int barsFromUp = na
var int barsFromDn = na
barsFromUp := up3Bars ? 0 : barsFromUp + 1
barsFromDn := dn3Bars ? 0 : barsFromDn + 1
plot(high[barsFromUp], color = color.blue, linewidth = 3)
plot(low[barsFromDn],  color = color.red,  linewidth = 3)
plot(barsFromUp, "3. barsFromUp", display = display)
plot(barsFromDn, "3. barsFromDn", display = display)

// Method 4: This method stores the value when a certain condition is met. It is the most efficient approach as it avoids
// the use of historical operators, thereby reducing the possibility of errors.
var float highWhenUp = na
var float lowWhenDn  = na
if up3Bars
    highWhenUp := high
if dn3Bars
    lowWhenDn  := low

plot(highWhenUp, color = color.new(color.white, 70), linewidth = 1)
plot(lowWhenDn,  color = color.new(color.white, 70), linewidth = 1)
```

### How can I plot the previous and current day\'s open? 

To plot the opening prices for both the current and previous day, we
first establish a timeframe for the script using the Settings/Inputs.
Here, we define the period as one day. The function
[timeframe.change()](https://www.tradingview.com/pine-script-reference/v5/#fun_timeframe.change)
is employed to identify shifts in the timeframe. Upon detecting a change
in the timeframe, the running open is stored as the previous day\'s
variable and the current
[open](https://www.tradingview.com/pine-script-reference/v5/#var_open)
is obtained.

Two types of plot styles are available, namely lines or circles. If the
line style is chosen, we take specific measures to prevent diagonal
lines between levels. This is achieved by not plotting
[na](https://www.tradingview.com/pine-script-reference/v5/#fun_na) on
changes while using
[plot.style_linebr](https://www.tradingview.com/pine-script-reference/v5/#var_plot.style_linebr).
Instead, we opt not to use a color on bars where there\'s a change,
which results in a single-bar gap instead of the two-bar gap that occurs
when we plot a
[na](https://www.tradingview.com/pine-script-reference/v5/#fun_na)
value:

``` pine
//@version=5
indicator("Previous and current day open", "", true)

string periodInput = input.timeframe("D", "Higher Timeframe")
bool   linesInput  = input.bool(true, "Lines")

bool newPeriod = timeframe.change(periodInput)
var float oYesterday = na
var float oToday     = na

if newPeriod
    oYesterday := oToday
    oToday     := open

stylePlots = linesInput ? plot.style_line : plot.style_circles
plot(oYesterday, "oYesterday", linesInput and newPeriod ? na : color.gray,   2, stylePlots)
plot(oToday,     "oToday",     linesInput and newPeriod ? na : color.silver, 2, stylePlots)
bgcolor(newPeriod ? color.new(color.gray, 80) : na)
```

Bear in mind, this method employs the chart\'s timeframe transitions to
establish open prices and does not make adjustments for session times.
This is especially relevant for markets that don\'t operate on a 24-hour
basis, where the session\'s open may differ from the bar\'s open. For
example, if the chart bar begins at 9:00 but the market opens at 9:30,
the open of the bar is utilized, not the session open.

To match the values with those depicted on higher timeframe charts,
it\'s necessary to access their data feeds. You can achieve this by
using
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security):

``` pine
//@version=5
indicator("Previous and current day open", "", true, max_lines_count = 500)

string periodInput = input.timeframe("D", "Higher timeframe")
bool   linesInput  = input.bool(true,     "Lines")

[htfOpen1, htfOpen2, htfTime, htfTimeClose] = request.security(syminfo.tickerid, periodInput, [open[1], open[2], time[1], time_close[1]], lookahead = barmerge.lookahead_on)
[htfRtOpen, htfRtOpen1] = request.security(syminfo.tickerid, periodInput, [open, open[1]])

var line rtOpen  = line.new(na, na, na, na, xloc.bar_time, color = color.lime)
var line rtOpen1 = line.new(na, na, na, na, xloc.bar_time, color = color.gray)
var int rtStart  = time
var int rtEnd    = time_close(periodInput)

if ta.change(htfTime)
    line.new(htfTime, htfOpen1, htfTimeClose, htfOpen1, xloc.bar_time, color = color.lime)
    line.new(htfTime, htfOpen2, htfTimeClose, htfOpen2, xloc.bar_time, color = color.gray)
    rtStart := time
    rtEnd   := time_close(periodInput)

line.set_xy1(rtOpen1, rtStart, htfRtOpen1), line.set_xy2(rtOpen1, rtEnd, htfRtOpen1)
line.set_xy1(rtOpen,  rtStart, htfRtOpen),  line.set_xy2(rtOpen,  rtEnd, htfRtOpen)

bgcolor(timeframe.change(periodInput) ? color.new(color.gray, 80) : na)
```

This script employs two data feeds from a higher timeframe. To reduce
the risk of repainting, we adhere to the strategies outlined in the
`` Repainting \`request.security()\` calls <PageRepainting_HistoricalVsRealtimeCalculations_RepaintingRequestSecurityCalls> `` section of the Pine Script Manual. These techniques are
applicable to values that have been confirmed after the closure of the
higher timeframe.

These confirmed values are plotted retroactively on each preceding day
when a new day begins. For the real-time bar of the higher timeframe,
which represents the current day, a separate set of lines is established
corresponding to the values of the current day.

Given that the current day has not yet concluded, these values could be
susceptible to repainting. While this is less apparent when using the
opening price, it could become more pronounced if the closing price is
used, as it changes throughout the day.

### How can I count the occurrences of a condition in the last x bars? 

The most efficient method is using the built-in
[math.sum()](https://www.tradingview.com/pine-script-reference/v5/#fun_math.sum)
function (Method 1). It maintains a running total of the count as each
bar is processed, instead of reviewing all bars within the lookback
period every time. This method can take a
[simple](/pine-script-docs/language/type-system#simple) or
[series](/pine-script-docs/language/type-system#series) length.

On the other hand, a less efficient approach is to use a
[for](https://www.tradingview.com/pine-script-reference/v5/#kw_for) loop
to retrospectively review each bar within the lookback period (Method
2). This is because it repeatedly examines all bars, despite the fact
that all but the last bar were already reviewed when the script
initially ran. This can result in slower processing and longer chart
loading times. Additionally, the potential for runtime errors increases
as there\'s a limit to the number of historical references a series can
have.

Method 1 demonstrates how to take advantage of series and an
understanding of the Pine Script™ runtime environment to code your
scripts. While there are circumstances where
[for](https://www.tradingview.com/pine-script-reference/v5/#kw_for)
loops are necessary, especially for certain types of backward analysis
that require information only available after the related data bars have
elapsed, it\'s typically recommended to avoid them when possible.

In the example provided, both methods are shown, with their plots
overlaid for comparison. Also, two additional plots demonstrate the use
of a series length. In most cases, count functions would return
[na](https://www.tradingview.com/pine-script-reference/v5/#fun_na) if
the length is greater than the number of available bars. To work around
this, we use the
[math.min()](https://www.tradingview.com/pine-script-reference/v5/#fun_math.min)
function to compare two values: the length input, or the number of
available chart bars. Taking the lesser of the two values allows us to
get a count on the number of elapsed bars when that number is less than
the length, as is the case on early bars:

![image](@assets/images/Techniques-How-can-i-count-the-occurences-of-a-condition-in-the-last-x-bars-1.png)

``` pine
//@version=5
indicator("Number of occurrences demo")

int lengthInput = input.int(100, "Length", minval = 1)

// Condition to count.
bool condition = close > open

// ————— Method 1. This function uses Pine's built-in function. Can be "simple" or "series" length.
ideal_timesInLast(bool cond, int len) =>
    float result = math.sum(cond ? 1 : 0, len)

// ————— Method 2. Very inefficient way to go about the problem. Not recommended.
inefficient_timesInLast(bool cond, int len) =>
    // At each bar we loop back len - 1 bars to re-count conditions that were already counted in previous calls, except for the current bar's condition.
    int cnt = 0
    for i = 0 to len - 1
        if na(cond[i])
            cnt := na
        else if cond[i]
            cnt += 1
    cnt

// Find the occurrences with a "simple" length.
float v1 = ideal_timesInLast(condition,       lengthInput)
int   v2 = inefficient_timesInLast(condition, lengthInput)
// Here, we apply the `math.min()` function to select the lesser value between `lengthInput` and `bar_index + 1`.
// This ensures that a value is rendered even for the initial bars, where the number of chart bars is fewer than `lengthInput`.
float v3 = ideal_timesInLast(condition,       math.min(lengthInput, bar_index + 1))
int   v4 = inefficient_timesInLast(condition, math.min(lengthInput, bar_index + 1))
plot(v3, "ideal_TimesInLast series length",       color.red, 4)
plot(v4, "inefficient_TimesInLast series length", color.white)
plot(v1, "ideal_TimesInLast simple length",       color.fuchsia, 4)
plot(v2, "inefficient_TimesInLast simple length", color.white)
```

### How can I implement an On/Off switch? 

The [var](/pine-script-docs/language/variable-declarations#var)
keyword in Pine Script™ ensures a variable is only initialized once. If
it\'s declared in the
[global scope](/pine-script-docs/faq#what-does-scope-mean), the initialization happens on the first bar. If it\'s
declared within a local block, initialization occurs the first time that
block is executed. From there, the variable maintains its most recent
value across subsequent bars unless it\'s reassigned. This
characteristic is particularly useful in scenarios where a variable\'s
value needs to persist across multiple script iterations over successive
bars.

One practical application of this behavior is the creation of an on/off
switch feature. With such a feature, a condition once met sets a
variable, `onOffSwitch`, to
[true](https://www.tradingview.com/pine-script-reference/v5/#kw_true) or
\"on\", maintaining this state until another condition is met to turn
the switch \"off\", setting `onOffSwitch` back to
[false](https://www.tradingview.com/pine-script-reference/v5/#kw_false).
Here\'s an example of how you can implement this:

![image](@assets/images/Techniques-How-can-i-implement-an-on-off-switch-1.png)

``` pine
//@version=5
indicator("On/Off condition example", "", true)
bool upBar = close > open
// On/off conditions.
bool triggerOn  = upBar and upBar[1] and upBar[2]
bool triggerOff = not upBar and not upBar[1]
// Switch state is implicitly saved across bars thanks to initialize-only-once keyword `var`.
var bool onOffSwitch = false
// Turn the switch on when `triggerOn` is true. If it is already on,
// keep it on unless `triggerOff` occurs.
onOffSwitch := triggerOn or onOffSwitch and not triggerOff
bgcolor(onOffSwitch ? color.new(color.green, 90) : na)
plotchar(triggerOn,  "triggerOn",  "▲", location.belowbar, color.lime, size = size.tiny, text = "On")
plotchar(triggerOff, "triggerOff", "▼", location.abovebar, color.red,  size = size.tiny, text = "Off")
```

Each instance of the on and off conditions is displayed with an arrow
and the word \"on\" or \"off\", with a green background highlighting the
bars where the switch is in the \"on\" state.

### How can I allow transitions from condition A►B or B►A, but not A►A nor B►B? 

You can establish a system that strictly controls the transitions
between different states, preventing any consecutive repetitions of the
same condition. For instance, you might want \'Condition A\' to trigger
only after \'Condition B\' has been triggered and vice versa,
effectively creating an alternating sequence of \'A\' and \'B\' events.
This could also be useful to prevent multiple conditions or alerts
triggering in a single direction.

Here\'s an illustrative example:

![image](@assets/images/Techniques-How-can-i-allow-transitions-from-condition-ab-or-ba-but-not-aa-nor-bb-1.png)

``` pine
//@version=5
indicator("AB or BA example", "", true)

// ————— Trigger conditions.
bool upBar        = close > open
bool condATrigger = upBar and upBar[1]
bool condBTrigger = not upBar and not upBar[1]
// ————— Conditions. These variables will only be true/false on the bar where they occur.
bool condA = false
bool condB = false
// ————— State variable set to true when last triggered condition was A, and false when it was condition B.
// This variable's state is propagated throughout bars (because we use the "var" keyword to declare it).
var bool lastCondWasA = false
// ————— State transitions so that we allow A►B or B►A, but not A►A nor B►B.
if condATrigger and not lastCondWasA
    // The trigger for condA occurs and the last condition set was condB.
    lastCondWasA := true
    condA        := true
else if condBTrigger and lastCondWasA
    // The trigger for condB occurs and the last condition set was condA.
    lastCondWasA := false
    condB        := true

bgcolor(lastCondWasA ? color.new(color.green, 90) : na)
plotchar(condA, "condA", "▲", location.belowbar, color.new(color.lime, 30), size = size.tiny, text = "A")
plotchar(condB, "condB", "▼", location.abovebar, color.new(color.red,  30), size = size.tiny, text = "B")
// Note that we do not plot the marker for triggers when they are allowed to change states, since we then have our condA/B marker on the chart.
plotchar(condATrigger and not condA, "condATrigger", "•", location.belowbar, color.green,  size = size.tiny, text = "a")
plotchar(condBTrigger and not condB, "condBTrigger", "•", location.abovebar, color.maroon, size = size.tiny, text = "b")
```

This script enforces an alternating sequence of `condA` and `condB`
events, where `condA` can only be activated after `condB`, and `condB`
can only be activated after `condA`. This is achieved by using a state
variable, `lastCondWasA`, to keep track of the last triggered condition,
and then using that information to control the state transitions.

This setup allows for a more sophisticated control of operation
sequences between states beyond merely triggering single states. It also
ensures that the chart is marked only on the first change of state
(depicted with an arrow). Such a condition could be useful when creating
alerts that are triggered by state changes.

### Can I merge two or more indicators into one? 

It is possible to combine indicators, however, it\'s crucial to pay
attention to the scale each indicator uses. Combining a moving average
indicator, designed to overlay the bar chart, with a volume bar
indicator that\'s meant for a separate indicator pane within the same
script can lead to issues. This is because their values operate on
different scales.

Once you ensure that the scales of your indicators are compatible or you
have found a way to normalize or re-scale them, you can consolidate the
codes from all indicators into a single script. This process involves
avoiding any variable name clashes to maintain the independence and
integrity of each indicator\'s calculations. There might be a need to
convert some parts of the code from one Pine Script™ version to another.
Therefore, it\'s important to be aware of the versions used in each
script.

:::warning[Notice!]
If the indicators you've merged are CPU intensive, you may run into
runtime limitations when executing the compound script.
:::

### How can I rescale an indicator from one scale to another? 

Rescaling an indicator from one scale to another requires different
strategies depending on whether the minimum and maximum possible values
of the signal to be rescaled are known or not.

If these values are unknown, like for
[volume](https://www.tradingview.com/pine-script-reference/v5/#var_volume)
or
[ta.macd()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.macd),
a function that uses past history to determine the minimum and maximum
values is required. An example of such a function is our `normalize()`
function below. This solution is imperfect because the minimum and
maximum values have to be discovered as your script progresses bar by
bar. We prefer it to techniques using
[ta.lowest()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.lowest)
and
[ta.highest()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.highest)
over a fixed period, because it uses the minimum and maximum values for
the complete set of elapsed bars instead of a subset of fixed length.
Ideally, you would know the minimum and maximum values for the whole
series in advance, but that is currently not possible in Pine.

If the minimum and maximum values of the series are known, like for RSI
or Stoch, you should use our example\'s `rescale()` function. This
function only translates the values into another space without changing
their relative proportion.

In an example where we wish to present
[ta.rsi()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.rsi)
and
[volume](https://www.tradingview.com/pine-script-reference/v5/#var_volume)
in one part of our indicator's pane in the -100/100 range, we can
rescale the
[ta.rsi()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.rsi),
as it is a bounded indicator with known values between 0 and 100. On the
other hand, the
[volume](https://www.tradingview.com/pine-script-reference/v5/#var_volume)
needs to be normalized to the -100/100 scale due to its unbounded
nature.

Suppose we want to include
[ta.cci()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.cci),
another unbounded indicator, in our indicator\'s 100/300 space. Though
75% of its values should lie in the -100/100 space, there are no fixed
upper and lower bounds. Therefore, normalization is necessary. In the
100/300 bounded space, there are no precise equivalents for the -100 and
100 levels, so we arbitrarily decided on 150/250 levels, about 25% of
the way into the range from the lower and upper bounds:

``` pine
//@version=5
indicator("FAQ - Rescaling/Normalizing values")


// ————— When the scale of the signal to rescale is unknown (unbounded).

// @function            Rescales a signal with an unknown scale (unbounded) using its historical low and high values.
// @param src       (series float) The series to be rescaled.
// @param min       (simple float) The minimum value of the rescaled series.
// @param max       (simple float) The maximum value of the rescaled series.
// @returns             (float) The rescaled value of the signal.
normalize(series float src, simple float min, simple float max) =>
    var float historicMin = 10e10
    var float historicMax = -10e10
    historicMin := math.min(nz(src, historicMin), historicMin)
    historicMax := math.max(nz(src, historicMax), historicMax)
    float result = min + (max - min) * (src - historicMin) / math.max(historicMax - historicMin, 10e-10)


// ————— When the scale of the signal to rescale is known (bounded).

// @function            Rescales a signal with a known scale (bounded) to a new scale.
// @param src       (series float) The series to be rescaled.
// @param oldMin        (simple float) The minimum value of the original signal's scale.
// @param oldMax        (simple float) The maximum value of the original signal's scale.
// @param newMin        (simple float) The minimum value of the new rescaled scale.
// @param newMax        (simple float) The maximum value of the new rescaled scale.
// @returns             (float) The rescaled value of the signal.
rescale(series float src, simple float oldMin, simple float oldMax, simple float newMin, simple float newMax) =>
    float result = newMin + (newMax - newMin) * (src - oldMin) / math.max(oldMax - oldMin, 10e-10)


// ————— Usual CCI calculations.
int cciLengthInput = input.int(20, "CCI Length", minval = 1)
int rsiLengthInput = input.int(14, "RSI Length", minval = 1)
float srcInput     = input.source(close, "Source")
float ma           = ta.sma(srcInput, cciLengthInput)
float cci          = (srcInput - ma) / (0.015 * ta.dev(srcInput, cciLengthInput))

// —————————— Plots

// ————— Normalized CCI.
plot(normalize(cci, 100, 300), "Normalized CCI", #2962FF)
// Arbitrary and inexact equivalent of 100 and -100 levels rescaled to the 100/300 scale.
band00 = hline(150, "Lower Band", color.new(#C0C0C0, 90), hline.style_solid)
band01 = hline(250, "Upper Band", color.new(#C0C0C0, 90), hline.style_solid)
fill(band01, band00, color.new(#21328F, 80), "Background")

// ————— Normalized volume in the same region as the rescaled RSI.
color volColor = close > open ? #26a69a : #ef5350
plot(normalize(volume, -100, 100), "Normalized volume", volColor, style = plot.style_columns, histbase = -100)
hline(100,  "", color.new(color.gray, 50), hline.style_dashed)
hline(-100, "", color.new(color.gray, 50), hline.style_solid)

// ————— Rescaled RSI.
plot(rescale(ta.rsi(srcInput, rsiLengthInput), 0, 100, -100, 100), "Rescaled RSI", #8E1599)
hline(0, "RSI 50 level", color.new(color.gray, 70), hline.style_solid)
// Precise equivalent of 70 and 30 levels rescaled to the -100/100 scale.
band10 = hline(-40, "Lower Band", color.new(#9915FF, 80), hline.style_solid)
band11 = hline(40,  "Upper Band", color.new(#9915FF, 80), hline.style_solid)
fill(band11, band10, color.new(#9915FF, 90), "Background")

// ————— Plot actual values in Data Window.
plot(na,                "═══════════════", display = display.data_window)
plot(cci,               "Real CCI",        display = display.data_window)
plot(volume,            "Real volume",     display = display.data_window)
plot(ta.rsi(close, 14), "Real RSI",        display = display.data_window)
```

![image](@assets/images/Techniques-How-can-i-rescale-an-indicator-from-one-scale-to-another-1.png)

Note that:

    -   Our indicator is the top one in the screenshot, with standard
        CCI and RSI indicators positioned below it.
    -   At points 1 and 2, the value of CCI relative to the horizontal
        levels is unreliable.
    -   We have exact, rescaled values for RSI. Even though the rescaled
        values for RSI differ from the real values, they are consistent
        in relation to each other and the horizontal levels. They are
        merely represented on a different scale.
    -   The normalized values for volume and CCI, which are now relative
        to their historical min/max, have been substantially transformed
        and therefore, their reliability may be compromised. In the
        process of normalization, they lose their exact proportionality,
        which is an unavoidable trade-off when confining an unbounded
        value to a finite scale.
    -   For your reference, the actual values for the indicators can be
        viewed in the Data Window.

### How can I calculate my script\'s run time? 

You can use the code from the PineCoders
[LibraryStopwatch](https://www.tradingview.com/script/xTHx0lQy-LibraryStopwatch/).
These functions allow you to measure the duration of script execution,
enabling you to experiment with various scenarios while developing your
code and identify the most efficient version. However, keep in mind that
limitations associated with
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
continue to apply. Since these calls are managed in a manner akin to
concurrent threads, their execution is beyond the scope of visibility of
the stopwatch functions.

### How can I save a value when an event occurs? 

To save a value when an event occurs, a simple method is to use the
[var](/pine-script-docs/language/variable-declarations#var)
keyword to declare a variable. Unlike other methods, a variable declared
with the [var](/pine-script-docs/language/variable-declarations#var) keyword is only initialized once at
[bar_index](https://www.tradingview.com/pine-script-reference/v5/#var_bar_index)
zero instead of on each bar. This feature allows the variable to
maintain its value without needing explicit reassignment on every bar, a
requirement in earlier versions of Pine.

In older versions, a variable was reinitialized at the start of each
bar, so it had to be manually reset to the value from the previous bar
to retain its information bar to bar, as demonstrated in the following
code:

``` pine
priceAtCross  = 0.
priceAtCross := nz(priceAtCross[1])
```

With the introduction of the
[var](/pine-script-docs/language/variable-declarations#var)
keyword, such reassignment is no longer necessary, leading to cleaner
code. You can declare a variable using
[var](/pine-script-docs/language/variable-declarations#var) and
then update it conditionally when a specific event (such as a crossover)
occurs:

``` pine
//@version=5
indicator("Save a value when an event occurs", "", true)
float hiHi = ta.highest(high, 5)[1]
var float priceAtCross = na
if ta.crossover(close, hiHi)
    // When a crossover occurs, assign the current close price to `priceAtCross`.
    // By using `:=`, we ensure that the global variable `priceAtCross` is updated.
    // If a new local variable was created (by using `=` instead), it wouldn't affect the global `priceAtCross`
    // since local variables cannot be referenced outside the block they're declared in.
    priceAtCross := close
plot(hiHi)
plot(priceAtCross, "Price At Cross", color.orange, 3, plot.style_circles)
```

In this example, the
[var](/pine-script-docs/language/variable-declarations#var)
keyword allows the `priceAtCross` variable to maintain its value between
bars until a crossover event occurs. At that point, the variable is
updated with the current close price. The use of the
[:=](/pine-script-docs/language/operators#reassignment-operator)
operator ensures that the global variable `priceAtCross` is the one
being modified, preventing the creation of a new local variable that
would be inaccessible outside the
[if](/pine-script-docs/language/conditional-structures#if) block.

### How can I count touches of a specific level? 

This technique outlines a method for counting touches of a predetermined
level, such as the median, by tracking the series on each bar. This
approach requires maintaining separate tallies for up and down bar
touches and taking into account any gaps across the median. Whenever a
touch occurs, a value of 1 is recorded in a series, and the
[math.sum()](https://www.tradingview.com/pine-script-reference/v5/#fun_math.sum)
function is then used to count these instances within the last
`touchesLengthInput` bars.

Keeping track of touches on every bar is essential for efficient
processing of your script. If tracking were not maintained on each bar,
it would be necessary to resort to loops, which would be inefficient and
impractical in this case. More importantly, attempting to analyze all
bars in history through loops would eventually lead to errors in the
script, making it technically impossible to process them all. Hence,
tracking and keeping count as you go proves to be the best method,
particularly since the Pine Script™ runtime is already designed to
process your script on each bar.

![image](@assets/images/Techniques-How-can-i-count-touches-of-a-specific-level-1.png)

``` pine
// Can work in overlay or pane mode and plots differently for each case.
bool overlay = false

//@version=5
indicator("Median Touches", "", overlay)

int medianLengthInput  = input.int(100, "Median calculation: Number of previous closes")
int touchesLengthInput = input.int(50,  "Number of previous bars to check for price touches")
float median = ta.percentile_nearest_rank(close, medianLengthInput, 50)
// Don"t count neutral touches when price doesn't move.
bool barUp = close > open
bool barDn = close < open
// Bar touches median.
bool medianTouch    = high    > median and low  < median
bool gapOverMedian  = high[1] < median and low  > median
bool gapUnderMedian = low[1]  > median and high < median
// Record touches.
int medianTouchUp = medianTouch and barUp or gapOverMedian  ? 1 : 0
int medianTouchDn = medianTouch and barDn or gapUnderMedian ? 1 : 0
// Count touches over the last n bars.
float touchesUp = math.sum(medianTouchUp, touchesLengthInput)
float touchesDn = math.sum(medianTouchDn, touchesLengthInput)
// —————————— Plots
// ————— Both modes
// Markers
plotchar(medianTouchUp, "medianTouchUp", "▲", overlay ? location.belowbar : location.bottom, color.lime)
plotchar(medianTouchDn, "medianTouchDn", "▼", overlay ? location.abovebar : location.top,    color.red)
// ————— Overlay mode
// Median for overlay mode.
plot(median, "Median", color.orange, display = overlay ? display.all : display.none)
// ————— Pane mode
// Base areas.
lineStyle = overlay ? plot.style_line : plot.style_columns
display   = overlay ? display.data_window : display.all
plot( touchesUp, "Touches Up", color.green,  style = lineStyle, display = display)
plot(-touchesDn, "Touches Dn", color.maroon, style = lineStyle, display = display)
// Exceeding area.
float minTouches     = math.min(touchesUp, touchesDn)
bool  minTouchesIsUp = touchesUp < touchesDn
basePlus = plot(not overlay ? minTouches : na,                     "Base Plus", display = display.none)
hiPlus = plot(not overlay and not minTouchesIsUp ? touchesUp : na, "High Plus", display = display.none)
baseMinus = plot(not overlay ? -minTouches : na,                   "Base Plus", display = display.none)
loMinus = plot(not overlay and minTouchesIsUp ? -touchesDn : na,   "Low Minus", display = display.none)
fill(basePlus,  hiPlus,  color.lime)
fill(baseMinus, loMinus, color.red)
```

Our example script also offers flexibility in its display modes. It can
be used in overlay mode to show the median and touches on the chart, or
in a separate pane to display the counts. By adjusting the overlay
variable from
[false](https://www.tradingview.com/pine-script-reference/v5/#kw_false)
to [true](https://www.tradingview.com/pine-script-reference/v5/#kw_true)
and re-adding the indicator to the chart, you can switch between the two
modes.

### How can I know if something is happening for the first time since the beginning of the day? 

We present three different techniques for this purpose in our example
script.

-   **Method 1** - We utilize the
    [ta.barssince()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.barssince)
    function to check if the number of bars since the last occurrence of
    a condition, plus one, is greater than the number of bars since the
    beginning of the new day.
-   **Method 2** - In this method, we manually track the condition,
    making it unnecessary to use
    [ta.barssince()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.barssince).
    When the timeframe changes to a new day, a flag is set to allow the
    trigger. If the condition occurs and the flag is set, the first
    occurrence is identified. This method is designed to be more
    readable.
-   **Method 3** - This method is more straightforward than the second
    one. Similar to Method 2, it manually tracks the condition as well,
    but uses a more compact logic.

``` pine
//@version=5
indicator("First time since BOD example", "", true)

bool cond = close > open
// ————— Method 1.
bool first1 = cond and ta.barssince(cond[1]) + 1 > ta.barssince(timeframe.change("D"))
plotchar(first1, "first1", "•", location.top, size = size.small)

// ————— Method 2.
var bool allowTrigger2 = false
bool     first2        = false
if timeframe.change("D")
    allowTrigger2 := true
if cond and allowTrigger2
    allowTrigger2 := false
    first2        := true
plotchar(first2, "first2", "•", location.top, color = color.silver, size = size.normal)

// ————— Method 3.
var bool allowTrigger3 = false
bool     first3        = false
allowTrigger3 := timeframe.change("D") or allowTrigger3 and not first3[1]
first3        := allowTrigger3 and cond
plotchar(first3, "first3", "•", location.top, color = color.orange, size = size.large)
```

The script plots three dots that are slightly offset vertically from one
another, with each dot representing a different method. This
visualization demonstrates that all the methods yield the same result,
although the achieve it through different means.

### How can I optimize Pine Script™ code? 

Optimizing Pine Script™ code is essential for increasing execution
speed, improving resource efficiency, and avoiding reaching the
platform\'s inherent constraints. Below are key strategies and best
practices for enhancing your code.

1.  **Understand the Pine Script™ execution model**
    -   Familiarize yourself with the Pine Script™ runtime model and
        series to structure your code effectively.
    -   Refer to the User Manual sections on the
        [execution model](/pine-script-docs/language/execution-model) and [time series](/pine-script-docs/language/time-series) for guidance.
2.  **Choose script types wisely**
    -   Use indicator scripts instead of strategy scripts for faster
        execution, as they consume fewer resources.
    -   Only employ strategy scripts when necessary.
3.  **Utilize built-in functions**
    -   Prefer [built-in](/pine-script-docs/built-in-functions) functions for calculating values to maximize
        efficiency.
4.  **Optimize code structure**
    -   Structure code to execute on the fly, leveraging bar-by-bar
        progression to minimize looking back.
    -   Minimize the use of
        [for](https://www.tradingview.com/pine-script-reference/v5/#kw_for)
        loops, as they\'re only necessary when values required for
        calculations are unavailable during bar-by-bar execution.
    -   If
        [for](https://www.tradingview.com/pine-script-reference/v5/#kw_for)
        loops are used, reduce iterations and statements within the loop
        as much as possible.
    -   Move variables that are used in every iteration outside of the
        loop, if possible. This prevents them from being re-initialized
        on each iteration.
5.  **Reduce overhead**
    -   Limit the use of
        [request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
        calls.
    -   If multiple calls fetch values from the same symbol and
        timeframe, use tuples to return multiple values, reducing
        overhead.
6.  **Modify drawings efficiently**
    -   Use `label/box/line.set_*()` functions to modify drawings once,
        instead of constantly deleting and recreating them.
    -   When possible, or when historical bars do not require them, draw
        or modify objects on the last bar.
    -   Enclose these functions in a
        [barstate.islast](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Bar_states.html#barstate-islast)
        local block to limit execution to the last bar. This approach is
        particularly useful for tables, which only display the content
        from the latest script iteration and do not allow referencing
        values throughout history anyway.
7.  **Handle max_bars_back sensibly**
    -   Use `max_bars_back` only when necessary, and keep its value to
        the strict minimum required. Consult the [Help
        Center](https://www.tradingview.com/support/solutions/43000587849/)
        article on `max_bars_back` for details.
    -   When possible, it is preferable to use the functional version,
        [max_bars_back()](https://www.tradingview.com/pine-script-reference/v5/#fun_max_bars_back),
        instead of specifying the historical buffer requirement directly
        within the
        [indicator()](https://www.tradingview.com/pine-script-reference/v5/#fun_indicator)
        or
        [strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
        declaration. This approach allows for the maintenance of the
        historical buffer for a single variable, rather than all
        variables within a script.
8.  **Isolate large code sections**
    -   Encapsulating large code sections in functions can often improve
        performance with proper understanding of [global/local scope
        constraints](https://www.tradingview.com/pine-script-docs/en/v5/language/User-defined_functions.html#scopes-in-the-script).
    -   Move functions to [libraries](/pine-script-docs/concepts/libraries) and import them when necessary. This approach can
        augment your script\'s capabilities and benefit from reduced
        [limitations](/pine-script-docs/writing/limitations)
        compared to typical restrictions found in indicator scripts.
        Additionally, library functions are compiled and cached daily,
        reducing script runtime.
9.  **Use the var keyword for complex initializations**
    -   Declare variables with the
        [var](/pine-script-docs/language/variable-declarations#var) keyword when initialization involves time-consuming
        operations like complex functions, arrays, objects, or string
        manipulations.
10. **Minimize string concatenations**
    -   Reduce the use of string concatenations, as they can be slow.
        Note that some constant evaluations like `s = "foo" + "bar"` are
        optimized to `s = "foobar"`, but others aren't.
11. **Measure execution time**
    -   If not using
        [request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security),
        consider using PineCoder\'s
        [Stopwatch](https://www.tradingview.com/script/xTHx0lQy-LibraryStopwatch/)
        library to measure your script\'s execution time. Use a trial
        and error process to improve efficiency.
12. **Utilize alternative techniques to avoid specific functions**
    -   In rare cases, employing carefully crafted Pine alternatives may
        be more efficient than standard functions.
    -   Consider techniques similar to the one mentioned
        [here](/pine-script-docs/faq#how-can-isave-avalue-when-an-event-occurs) to bypass the use of
        [ta.valuewhen()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.valuewhen).
    -   Implement approaches resembling
        [method 4](/pine-script-docs/faq#how-can-iremember-the-last-time-acondition-occured) to circumvent the use of
        [ta.barssince()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.barssince).

### How can I access a stock\'s financial information using Pine Script™? 

1.  Using the
    [request.financial()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.financial)
    function: This is a straightforward method that allows you to
    directly request financial data.
2.  Using the
    [request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
    function: This method enables you to access information on earnings,
    splits, and dividends using certain techniques as illustrated in
    [this](https://www.tradingview.com/script/XUX5VVN0-Earnings-Splits-Dividends/)
    script. Please note, however, that this method is not officially
    supported by TradingView and may become inoperative in the future.
3.  Through the
    [Financials](https://www.tradingview.com/blog/en/fundamental-analysis-is-now-available-on-tradingview-15448/)
    button on your chart: The financial information can be accessed
    directly from your chart, and appears as an indicator. This method
    involves the following setup:
    a.  Your script must allow for an
        [external input](/pine-script-docs/faq#how-can-iuse-one-scripts-output-as-an-input-into-another).
    b.  Both your script and the required Financial indicators must be
        loaded on the chart.
    c.  The selection of the Financials indicator\'s output as an input
        into your indicator must be done manually through your script\'s
        Settings/Inputs. This process will enable your script to access
        information from up to ten of those Financial indicators at a
        time.

### How can I find the maximum value among the last pivots? 

To find the maximum value among a set of *n* pivots, where *n* is
specified by the variable `numPivotsInput` in our script, we need to
store these values for comparison. While separate variables could be
assigned to each passing pivot for comparison, using an
[array](/pine-script-docs/language/arrays) simplifies both the
process and the code significantly.

The array is managed in a way that mimics a
[queue](/pine-script-docs/language/arrays#using-an-array-as-aqueue): each time a new pivot is identified, the oldest element is
removed from the array and the new pivot is added to the end. This
queuing technique ensures that the array maintains the most recent n
elements for comparison.

A notable advantage of this array-based method is its adaptability. To
change the number of pivots we are tracking, we simply need to modify
the input value, `numPivotsInput`, which determines the size of the
array.

To identify the highest value among the stored pivots, we use the
[array.max()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.max)
function and plot this maximum value on the chart. Additionally, we
place markers on the chart: one set to indicate the bars where the
pivots are located, and another to highlight the points in time when
these pivots were detected.

It\'s important to note that there is a delay between these two points.
This delay, or delta, exists because a pivot is only confirmed and
detected after a certain number of bars have elapsed since the actual
pivot bar. This number of bars is equal to the specified
`pivotLengthInput` in our script:

``` pine
//@version=5
indicator("Max pivot demo", "", true)
// Create inputs to specify the pivot legs and the number of last pivots to keep to compare.
int pivotLengthInput = input.int(5, "Pivot length", minval = 1)
int numPivotsInput   = input.int(3, "Number of pivots to check")
// Initialize an array with a size based on the number of recent pivots to evaluate.
var array<float> pivotsArray = array.new<float>(numPivotsInput)
// Find the pivot value and set up a condition to verify if a value has been found.
float ph = ta.pivothigh(pivotLengthInput, pivotLengthInput)
bool newPH = not na(ph)
// When a new pivot is found, add it to the array and discard the oldest value.
if newPH
    pivotsArray.push(ph)
    pivotsArray.shift()
// Display the max value from the array on the chart, along with markers indicating the positions and detection times of the pivot highs.
plot(pivotsArray.max())
plotchar(newPH, "newPH", "•", location.abovebar, offset = - pivotLengthInput)
plotchar(newPH, "newPH", "▲", location.top)
```

Note that:

    -   To detect a new pivot, we use the condition `not na(PH)` instead
        of simply evaluating the value of the pivot itself. This
        approach is taken because, in conditional expressions, numerical
        values that are evaluated as true and zero as false will trigger
        a compiler warning. By checking for `not na(PH)`, we avoid the
        warning and circumvent the issue of potentially missing a pivot
        when its value is zero. This method is more robust and is the
        recommended way to test for a pivot.

### How can I display plot values in the chart\'s scale? 

To display the names and values of plots in the chart\'s scale with your
indicator, follow these steps:

1.  **Access the Chart Settings menu:**
    -   You can reach this menu by either right-clicking on the chart or
        clicking on the cog wheel icon located in the chart\'s
        upper-right corner.
2.  **Navigate to the Scales tab within the Chart Settings menu.**
3.  **Check two checkboxes:**
    -   \"Indicators and Financials Name Labels\"
    -   \"Indicators and Financials Value Labels\"

Note that:

    -   If you enable the \"Indicators and Financials Name Labels\'\'
        option, the `shorttitle` will be used as the label if it is
        available. If a `shorttitle` is not provided, the full title of
        the indicator will be used as the label instead.
    -   Additionally, the name of the plot will appear in the label.

![image](@assets/images/Techniques-How-can-i-display-plot-values-in-the-charts-scale-1.png)

``` pine
//@version=5
indicator("SMA Script", "", true)
float maOne = ta.sma(close, 20)
float maTwo = ta.sma(close, 50)
plot(maOne, "MA1")
plot(maTwo, "MA2", color.fuchsia)
```

In our script, we simply calculate two moving averages and plot them.
This is done for illustrative purposes, allowing us to display both the
name and values of the indicator in our example.

### How can I reset a sum on a condition? 

To preserve the value of a variable from bar to bar, we need to
initialize it with the
[var](/pine-script-docs/language/variable-declarations#var)
keyword. This ensures that our `vol` variable is initialized only on the
first bar, and its value is retained across subsequent bars. Next, we
need to specify the condition under which the `vol` variable should be
reset. In this case, the resetting condition is defined as a MACD cross.
On each bar, we add the current
[volume](https://www.tradingview.com/pine-script-reference/v5/#var_volume)
to the `vol` variable, resulting in the summing of volumes, or
cumulative volume, on consecutive bars. However, if the specified reset
condition occurs, we reset the `vol` variable sum back to zero. We
display up and down arrows on the chart to visually indicate the points
at which our condition occurs.

![image](@assets/images/Techniques-How-can-i-reset-a-sum-on-a-condition-1.png)

``` pine
//@version=5
indicator("Reset sum on condition example")
color TEAL = color.new(color.teal, 50)
color RED  = color.new(color.red,  50)
[macdLine, signalLine, _] = ta.macd(close, 12, 26, 9)
bool crossUp = ta.crossover(macdLine,  signalLine)
bool crossDn = ta.crossunder(macdLine, signalLine)
bool cond = crossUp or crossDn
var float vol = na
vol := cond ? 0. : vol + volume
plot(vol, "Cumulative volume", close >= open ? TEAL : RED, 1, plot.style_columns)
plotshape(crossUp, "crossDn", shape.arrowup,   location.top, color.lime)
plotshape(crossDn, "crossUp", shape.arrowdown, location.top, color.fuchsia)
```

Note that:

    -   In the
        [ta.macd()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.macd)
        function call, we only require two of the three values returned
        in the [tuple](/pine-script-docs/language/type-system#tuples). To avoid unnecessary variable declaration and to
        slightly improve performance, we replace the third tuple value
        with an underscore. This convention allows us to disregard
        unneeded variables that are returned by functions in our script.

### How can I accumulate a value for two exclusive states? 

In the context of programming, an exclusive state means that at any
given time, the system can be in one and only one of the defined states.
This is in contrast to non-exclusive states, where multiple states can
exist simultaneously.

Considering the accumulation of a value in relation to two exclusive
states, it suggests a scenario where you have two separate states that
cannot occur at the same time, and you are interested in accumulating or
tracking a certain value (e.g., a sum or a count) that is associated
with each of these states.

Take, for instance, a simple strategy defined by two exclusive states:
*buy* and *sell*. When the strategy is in the *buy* state, it
accumulates the
[volume](https://www.tradingview.com/pine-script-reference/v5/#var_volume)
of shares being traded. Upon transitioning to the *sell* state, the
accumulation of volume begins anew. Because these states are exclusive,
meaning the strategy cannot be in both *buy* and *sell* states
simultaneously, the logic for tracking cumulative values remains clear
and distinct for each state. We outline this concept in our solution.

In our script example, the cumulative counts are displayed in a Weis
Wave fashion, visually representing the cumulative volume for bullish
and bearish states. Additionally, the script visually marks the
occurrences of triggers with arrows for debugging purposes:

![image](@assets/images/Techniques-How-can-i-accumulate-a-value-for-two-exclusive-states-1.png)

``` pine
//@version=5
indicator("Cumulative volume", "")

bool beginUp = ta.rising(close,  2)
bool beginDn = ta.falling(close, 2)
var float volUp = na
var float volDn = na
// Reset to `na` on opposite condition; init to volume on matching condition and variable is `na`; otherwise, accumulate volume.
volUp := beginDn ? na : beginUp and na(volUp) ? volume : volUp + volume
volDn := beginUp ? na : beginDn and na(volDn) ? volume : volDn + volume

plot(+volUp, "Up Volume", color.green,  4, plot.style_columns)
plot(-volDn, "Dn Volume", color.maroon, 4, plot.style_columns)
plotchar(beginUp, "Up Reset", "▲", location.bottom, color.green,  size = size.tiny)
plotchar(beginDn, "Dn Reset", "▼", location.top,    color.maroon, size = size.tiny)
```

**In our script, we:**

1.  Establish the conditions that will initiate a change in our states.
    In this example, these conditions are based on rising or falling
    values of the
    [close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
    price. Specifically, we have two trigger conditions: `beginUp` and
    `beginDn`. A state is initiated when its corresponding trigger
    condition is met. This state persists until the trigger condition
    for the opposite state is met for the first time.
2.  Declare two variables, `volUp` and `volDn`, to hold the cumulative
    volume for uptrend and downtrend states, respectively. We use the
    [var](/pine-script-docs/language/variable-declarations#var)
    keyword to preserve these variables\' values from bar to bar. At any
    given time, only one state is active, and its corresponding variable
    accumulates volume, while the other is set to
    [na](https://www.tradingview.com/pine-script-reference/v5/#fun_na).
3.  Update the cumulative values as follows:
    a.  When a new state is triggered, reset the accumulated value for
        the opposite state. For example, when entering the *buy* state,
        reset `volDn` to
        [na](https://www.tradingview.com/pine-script-reference/v5/#fun_na).
    b.  If a state is triggered and its associated variable is
        [na](https://www.tradingview.com/pine-script-reference/v5/#fun_na),
        start accumulating from the current volume.
    c.  If the system is already in a particular state, such as *buy*,
        continue adding the current volume to its associated variable,
        like `volUp`.

### How can I organize my script\'s inputs in the Settings/Inputs tab? 

This script shows how to organize your inputs using the following
tricks:

-   **Grouping inputs:** Leverage the `group` parameter in your
    [input()](https://www.tradingview.com/pine-script-reference/v5/#fun_input)
    functions to designate a section header for a group of inputs. This
    helps to categorize and group related inputs together. By employing
    constants for group names ahead of each input section within the
    code, we simplify any potential name changes and improve script
    readability with clear title lines for each input group.
-   **Visual boundaries:** Use ASCII characters to create separators,
    establishing visual boundaries for distinct group sections. For
    continuous separator lines, reference group headers 1 and 2 which
    employ ASCII characters 205 or 196. Conversely, the dash (ASCII 45)
    and Em dash (ASCII 151), showcased in group headers 3 and 4, do not
    join continuously, resulting in a less visually appealing
    distinction. It\'s also important to understand that Unicode
    characters might display variably across different machines and
    browsers, potentially altering their appearance or spacing for
    various users.
-   **Indentation of sub-sections:** For a hierarchical representation,
    use Unicode whitespace characters to indent input sub-sections. This
    visual indentation can signify their association with a broader
    category in the settings. Among these characters, the Em space ( ):
    8195 (0x2003) is our preferred choice for its tab-like spacing.
    Group 3 in our script provides a demonstration of this approach.
-   **Vertical alignment of inlined inputs:** In our script, Group 1
    showcases the challenges of achieving uniform vertical alignment
    when dealing with inline inputs with varied `title` lengths. To
    counteract this misalignment, Group 2 uses the Unicode EN space ( ):
    8194 (0x2002) for padding, since regular spaces are stripped from
    the label. For precise alignment, you can utilize different
    quantities and types of Unicode spaces. See
    [here](https://jkorpela.fi/chars/spaces.html) for a list of Unicode
    spaces of different widths. It\'s important to note that, much like
    the separator characters, the rendering of these spaces might differ
    across browsers and machines.
-   **Structuring blocks of inlined inputs:** Structure multiple related
    inputs into consolidated blocks using the inline parameter. For a
    compact single-line display, designate the title argument to just
    the first input and skip it for the others. Refer to group 4 for an
    example.

``` pine
//@version=5
indicator("Inputs", overlay = true)

// Defining options strings improves script readability.
// It also enables the creation of boolean variables by comparing these constants with user input strings in a single line of code.
string EQ1 = "On" // Do not use ampersand ("&") in `options` arguments.
string EQ2 = "Off"

// The `GRP*` strings used for group headers demonstrate using ASCII characters to create a visual boundary,
// making it easier for users to differentiate between different sections in the menu.

// Group 1 demonstrates inline inputs that do not align vertically in the menu.
string GRP1 = "════════════ Settings ═════════════" // ASCII 205
float  ao1SrcInput    = input.source(close, "AO source",     inline = "11", group = GRP1)
int    ao1LenInput    = input.int(14,       "Length",        inline = "11", group = GRP1)
float  long1SrcInput  = input.source(close, "Signal source", inline = "12", group = GRP1)
int    long1LenInput  = input.int(3,        "Length",        inline = "12", group = GRP1)

// In Group 2, the title of `ao2SrcInput` is padded with three Unicode EN spaces (U+2002) to compensate for the misalignment.
string GRP2           = "──────────── Settings ────────────" // ASCII 196
float  ao2SrcInput    = input.source(close, "AO source   ",  inline = "21", group = GRP2)
int    ao2LenInput    = input.int(14,       "Length",        inline = "21", group = GRP2)
float  long2SrcInput  = input.source(close, "Signal source", inline = "22", group = GRP2)
int    long2LenInput  = input.int(3,        "Length",        inline = "22", group = GRP2)

// This configuration uses Unicode white space characters to indent input sub-sections. We use Em space ( ): 8195 (0x2003).
string GRP3           = "————————————— Settings ———————————————" // ASCII 151 (Em dash)
float  level1Input    = input.float(65.,    "First level",               group = GRP3)
float  level2Input    = input.float(65.,    "  Second Level",            group = GRP3)
bool   level3Input    = input.string(EQ1,   "    Checkbox equivalent",   group = GRP3, options = [EQ1, EQ2]) == EQ1
float  level4Input    = input.float(65.,    "Widest Legend            ", group = GRP3)

// These options demonstrate the use of the `inline` parameter to create structured blocks of inputs that are relevant to one another.
string GRP4 = "------------------------ Settings ----------------------------" // ASCII 45 (dash)
bool   showMa1Input   = input(true,         "MA №1", inline = "1", group = GRP4)
string ma1TypeInput   = input.string("SMA", "",      inline = "1", group = GRP4, options = ["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"])
float  ma1SourceInput = input(close,        "",      inline = "1", group = GRP4)
int    ma1LengthInput = input.int(20,       "",      inline = "1", group = GRP4, minval = 1)
color  ma1ColorInput  = input(#f6c309,    "",      inline = "1", group = GRP4)

bool   showMa2Input   = input(true,         "MA №2", inline = "2", group = GRP4)
string ma2TypeInput   = input.string("SMA", "",      inline = "2", group = GRP4, options = ["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"])
float  ma2SourceInput = input(close,        "",      inline = "2", group = GRP4)
int    ma2LengthInput = input.int(50,       "",      inline = "2", group = GRP4, minval = 1)
color  ma2ColorInput  = input(#fb9800,    "",      inline = "2", group = GRP4)

bool   showMa3Input   = input(true,         "MA №3", inline = "3", group = GRP4)
string ma3TypeInput   = input.string("SMA", "",      inline = "3", group = GRP4, options = ["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"])
float  ma3SourceInput = input(close,        "",      inline = "3", group = GRP4)
int    ma3LengthInput = input.int(100,      "",      inline = "3", group = GRP4, minval = 1)
color  ma3ColorInput  = input(#fb6500,    "",      inline = "3", group = GRP4)

// @function            Calculates various types of moving averages for the `source` based on the specified `maType`.
// @param series        (series float) Series of values to process.
// @param length        (simple int) Number of bars (length).
// @param maType        (simple string) The type of moving average to calculate.
//                      Options are "SMA", "EMA", "SMMA (RMA)", "WMA", and "VWMA".
// @returns             (float) The moving average of the `source` for `length` bars back.
ma(series float source, simple int length, simple string maType) =>
    switch maType
        "SMA"        => ta.sma(source,  length)
        "EMA"        => ta.ema(source,  length)
        "SMMA (RMA)" => ta.rma(source,  length)
        "WMA"        => ta.wma(source,  length)
        "VWMA"       => ta.vwma(source, length)
        =>              na

// Calculate the moving averages with the user-defined settings.
float ma1 = ma(ma1SourceInput, ma1LengthInput, ma1TypeInput)
float ma2 = ma(ma2SourceInput, ma2LengthInput, ma2TypeInput)
float ma3 = ma(ma3SourceInput, ma3LengthInput, ma3TypeInput)

// Plot the moving averages, if each checkbox is enabled.
plot(showMa1Input ? ma1 : na, "MA №1", ma1ColorInput)
plot(showMa2Input ? ma2 : na, "MA №2", ma2ColorInput)
plot(showMa3Input ? ma3 : na, "MA №3", ma3ColorInput)
```

Note that:

    -   Due to the fact checkboxes cannot be indented, using the
        [input()](https://www.tradingview.com/pine-script-reference/v5/#fun_input)
        function\'s options parameter for dropdown selections will make
        your sections appear more organized compared to using
        checkboxes. Observe how `level3Input` is compared with the `EQ1`
        \"ON\'\' constant to produce a boolean variable in a single line
        of code. This method provides a visually appealing indented
        on-off switch in the menu without adding complexity to the code.
    -   For a consistent visual appearance, vertically center your
        separator titles across all inputs. Due to the proportional
        spacing of the MS Trebuchet font used for TV text, achieving
        this might require some trial and error.
    -   To ensure separators align just slightly to the left of the
        furthest edge of dropdowns, begin with your longest input title,
        as it sets the width of the db. By doing this, you can prevent
        the time-consuming process of readjusting line characters around
        your separator's name every time the db width changes due to
        longer input titles.
    -   To avoid adjusting separators if your longest input title is
        shorter than initially anticipated, you can extend its length
        using Unicode white space. Refer to the code example for input
        `level4Input` for a demonstration.

Tips:

    -   Your script's plots and inputs constitute their user interface.
        Inputs thus play a key role in the user experience. The more
        options you provide, the more important the design of your
        Inputs dialog box becomes, especially when users don't read
        script descriptions or if your description is lacking.
    -   Arrange the sequence of inputs prioritizing user convenience
        rather than the order used in your calculations. Position the
        most important or frequently used selections at the beginning
        and assess the user\'s navigation through your input list.
    -   Never use two checkboxes for mutually exclusive selections. Opt
        for dropdowns, which offer the flexibility to include multiple
        relevant options.
    -   Do not be stingy when naming option selections. The dropdown
        widget can accommodate long strings.
    -   Avoid using ampersands in option arguments, as they interfere
        with the functionality of boolean expressions.
    -   Choose your default values wisely.
    -   Provide adequate min and max values for numeric values,
        selecting the proper float or int type.
    -   Customize step values based on the specific needs of each input
        when necessary. Tailoring the step size to the context of the
        input enhances its usability, ensuring that each arrow click
        adjusts the value by a relevant amount.

## Times Dates Sessions 

-   [How can I get the time of the first bar in the dataset?](/pine-script-docs/faq#how-can-iget-the-time-of-the-first-bar-in-the-dataset)
-   [How can I convert a time to a date-time string?](/pine-script-docs/faq#how-can-iconvert-atime-to-adatetime-string)
-   [How can I know how many days are in the current month?](/pine-script-docs/faq#how-can-iknow-how-many-days-are-in-the-current-month)
-   [How can I detect the chart's last day?](/pine-script-docs/faq#how-can-idetect-the-charts-last-day)
-   [How can I plot a value starting n months/years back?](/pine-script-docs/faq#how-can-iplot-avalue-starting-nmonths-years-back)
-   [How can I track highs/lows for a specific timeframe?](/pine-script-docs/faq#how-can-itrack-highs-lows-for-aspecific-timeframe)
-   [How can I track the highs/lows within a specific session or time of day?](/pine-script-docs/faq#how-can-itrack-the-highs-lows-within-aspecific-session-or-time-of-day)
-   [How can I track highs/lows between specific intrabar hours?](/pine-script-docs/faq#how-can-itrack-highs-lows-between-specific-intrabar-hours)
-   [How can I detect a specific date/time?](/pine-script-docs/faq#how-can-idetect-aspecific-date-time)
-   [How can I know the date when the highest value was found?](/pine-script-docs/faq#how-can-iknow-the-date-when-the-highest-value-was-found)
-   [How can I detect bars opening at a specific hour?](/pine-script-docs/faq#how-can-idetect-bars-opening-at-aspecific-hour)
-   [Can I time the duration of a condition?](/pine-script-docs/faq#can-itime-the-duration-of-acondition)
-   [How can I identify the nth occurrence of a weekday in the month?](/pine-script-docs/faq#how-can-iidentify-the-nth-occurrence-of-aweekday-in-the-month)
-   [How can I implement a countdown timer?](/pine-script-docs/faq#how-can-iimplement-acountdown-timer)
-   [How can I get the week of the month?](/pine-script-docs/faq#how-can-iget-the-week-of-the-month)

### How can I get the time of the first bar in the dataset? 

By utilizing the behavior of the
[var](/pine-script-docs/language/variable-declarations#var)
keyword, the provided code initializes a variable solely on the
dataset\'s first bar. As a result, during its initial execution, the `t`
variable is assigned to the
[time](https://www.tradingview.com/pine-script-reference/v5/#fun_time)
built-in, which represents the Unix format time (milliseconds since
00:00:00 UTC on 1 January 1970).

``` pine
//@version=5
indicator('Time at first bar')
// Capture the time of the first bar in the dataset.
var int t = time
plot(t)
```

### How can I convert a time to a date-time string? 

In this code, we\'ve implemented a custom function, `timeToString()`, to
improve readability and ensure consistent time formatting. This function
serves as a wrapper around the native
[str.format_time()](https://www.tradingview.com/pine-script-reference/v5/#fun_str.format_time)
function, which translates a Unix timestamp into a string representation
of date-time. Instead of specifying the format string in every call,
`timeToString()` applies a consistent format: `"YYYY.MM.dd @ HH:mm:ss"`.
This chosen format draws inspiration from the ISO 8601 date and time
representation but with periods for date separation and an \'@\' symbol
for date-time distinction. For more info on customizing your formatting,
consult the
[str.format_time()](https://www.tradingview.com/pine-script-reference/v5/#fun_str.format_time)
documentation.

Our example code provides four distinct methods to obtain the date-time,
with two of them showcasing a 4-day future offset:

``` pine
//@version=5
indicator("Time to string example")

// Function converts a timestamp to a formatted string.
timeToString(t) =>
    str.format_time(t, format = "YYYY.MM.dd @ HH:mm:ss")

// Capture the time of the first bar in the dataset.
var int t = time

// Create table on the first bar only.
var table tbl = table.new(position.middle_right, 1, 1)

// On the first bar, build the table cell.
if barstate.isfirst
    table.cell(tbl, 0, 0, "", bgcolor = color.yellow, text_color = color.black, text_halign = text.align_left, text_font_family = font.family_monospace)
// On the last bar, build display text and populate the table.
else if barstate.islast
    string txt = str.format(
      "Date/time at bar_index = 0               {0}
      \nCurrent Date/time                        {1}
      \nDate/time 4 days from current time       {2}
      \nDate/time at beginning of last bar       {3}
      \nDate/time 4 days after last bar''s start: {4}",
      timeToString(t), 
      timeToString(timenow),
      timeToString(timestamp(year(timenow), month(timenow), dayofmonth(timenow) + 4, hour(timenow), minute(timenow), second(timenow))),
      timeToString(time), 
      timeToString(timestamp(year, month, dayofmonth + 4)))
    table.cell_set_text(tbl, 0, 0, txt)
```

### How can I know how many days are in the current month? 

To calculate the number of days in the current month, including
adjustments for leap years, you can use our demonstration code as an
example. This script defines a function, `daysPerMonth()`, which returns
the total number of days in the specified month of a given year. By
default, it uses the current year and month but can be customized for
any year and month by passing the year or month number as arguments:

![image](@assets/images/Times-dates-sessions-How-can-i-know-how-many-days-are-in-the-current-month-1.png)

``` pine
//@version=5
indicator("Days in month")

// @function                Calculates the number of days in a specified month, accounting for leap years.
// @param yearNumber        (int) The year of the `monthNumber` month. Optional. Default is the current year.
// @param monthNumber       (int, optional) The month for which to find the number of days. Optional. Default is the current month.
// @returns                 (int) The number of days in the `monthNumber` month of the `yearNumber` year.
daysPerMonth(int yearNumber = year, int monthNumber = month) =>
    bool leapYear = (yearNumber % 4 == 0 and yearNumber % 100 != 0) or (yearNumber % 400 == 0)
    int result = switch
        monthNumber == 2 => leapYear ? 29 : 28
        =>                  31 - (monthNumber - 1) % 7 % 2

plot(daysPerMonth())
```

### How can I detect the chart\'s last day? 

Detecting the last day on a chart can be approached in multiple ways.
Below, we present two methods for achieving this.

**Method 1:**

To detect the last day on a chart, we use a flag variable `isLastDay`.
This flag is set to true when the daily timeframe begins a new day and
the difference between the time of the last chart bar
([last_bar_time](https://www.tradingview.com/pine-script-reference/v5/#var_last_bar_time))
and the current bar\'s time
([time](https://www.tradingview.com/pine-script-reference/v5/#var_time))
is less than the time in one day.

``` pine
//@version=5
indicator("Last day example", overlay = true)
var bool isLastDay = false
if timeframe.change("D") and last_bar_time - time < timeframe.in_seconds("D") * 1000
    isLastDay := true
bgcolor(isLastDay ? color.new(color.red, 90) : na)
```

**Method 2:**

To detect if a bar\'s date corresponds to today\'s date, we use the
[timenow](https://www.tradingview.com/pine-script-reference/v5/#var_timenow)
function to retrieve the current time. From this, we extract the year,
month, and day and compare them to the
[built-in](/pine-script-docs/built-in-functions) chart
variables for a bar\'s corresponding date values. As the script
progresses bar by bar, these time variables update. When they match the
current date, the function returns true. We color the background red,
like in the first example.

``` pine
//@version=5
indicator("Detect today", "", true)
isToday() =>
    int currentYear  = year(timenow)
    int currentMonth = month(timenow)
    int currentDay   = dayofmonth(timenow)
    bool result = year == currentYear and month == currentMonth and dayofmonth == currentDay
bgcolor(isToday() ? color.new(color.red, 90) : na)
```

When using either of these methods in realtime, it\'s important to
recognize an inherent limitation, compounded by the unpredictable nature
of the data: we can never truly determine if a chart\'s bar represents
today or is the chart\'s last day until it transpires. Because the
[last_bar_time](https://www.tradingview.com/pine-script-reference/v5/#var_last_bar_time)
and
[timenow](https://www.tradingview.com/pine-script-reference/v5/#var_timenow)
constantly update to mirror the time of the newest bar, the condition
perpetually remains true for every ensuing bar. Consequently, each
subsequent realtime bar is interpreted as if it\'s the chart\'s last
day, potentially limiting the usefulness of detecting today, or the
chart\'s last day in your scripts.

### How can I plot a value starting n months/years back? 

It is possible for the
[timestamp()](https://www.tradingview.com/pine-script-reference/v5/#fun_timestamp)
function to accept negative argument values, converting them to accurate
dates. For instance, a negative month value deducts the corresponding
number of months from the outcome. This capability enables retrospective
examination over any number of months or years. Our example script
demonstrates this method and also provides an option to either set the
resulting date to the first of the targeted month or to derive the date
based on the current date and time:

![image](@assets/images/Times-dates-sessions-How-can-i-plot-a-value-starting-n-months-years-back-1.png)

``` pine
//@version=5
indicator("Plot value starting n months/years back", "", true)
int  monthsBackInput  = input.int(3, minval = 0)
int  yearsBackInput   = input.int(0, minval = 0)
bool calcFromNowInput = input(false, "Calculate from current Date/Time instead of first of the month")

bool isTargetDate = time >= timestamp(
  year(timenow)  - yearsBackInput,
  month(timenow) - monthsBackInput,
  calcFromNowInput ? dayofmonth(timenow) : 1,
  calcFromNowInput ? hour(timenow)       : 0,
  calcFromNowInput ? minute(timenow)     : 0,
  calcFromNowInput ? second(timenow)     : 0)
bool isBeginMonth = not isTargetDate[1] and isTargetDate
var float valueToPlot = na
if isBeginMonth
    valueToPlot := high
plot(valueToPlot)
bgcolor(isBeginMonth ? color.new(color.red, 80) : na)
```

Here, we calculate the date three months prior to the current time,
using the
[timestamp()](https://www.tradingview.com/pine-script-reference/v5/#fun_timestamp)
function along with
[timenow](https://www.tradingview.com/pine-script-reference/v5/#var_timenow).
This allows us to determine the time when the script is added to the
chart. As the script executes on each bar, it compares the bar
[time](https://www.tradingview.com/pine-script-reference/v5/#var_time)
with the previously calculated time offset. When the time of a bar
matches our specified target date, we assign the high of that bar as our
value to plot and color the background red for demonstration.

### How can I track highs/lows for a specific timeframe? 

This code demonstrates a method to track the high and low values of a
timeframe that avoids using
[request.security()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security)
calls, which slow down your script. Within the script\'s Inputs, users
can select the source for calculating highs/lows and define the period
after which the high/low should be reset:

![image](@assets/images/Times-dates-sessions-How-can-i-track-highs-lows-for-a-specific-timeframe-1.png)

``` pine
//@version=5
indicator("Periodic hi/lo example", "", true)

// Inputs.
bool   showHiInput = input.bool(true,      "Show highs")
bool   showLoInput = input.bool(true,      "Show lows")
float  srcHiInput  = input.source(high,    "Source for Highs")
float  srcLoInput  = input.source(low,     "Source for Lows")
string periodInput = input.timeframe("1D", "Period after which hi/lo is reset")

// Declare with `var` to retain values bar to bar.
var float hi = na
var float lo = na
// When a new period begins, reset hi/lo.
bool  isNewPeriod = timeframe.change(periodInput)
hi := isNewPeriod ? srcHiInput : math.max(srcHiInput, hi)
lo := isNewPeriod ? srcLoInput : math.min(srcLoInput, lo)
// Plot the hi, lo, and an invisible mid value for area fill.
p1 = plot(hi, "Highs", isNewPeriod ? na : color.new(color.lime,    60), display = showHiInput ? display.all : display.none)
p2 = plot(lo, "Lows",  isNewPeriod ? na : color.new(color.fuchsia, 60), display = showLoInput ? display.all : display.none)
p3 = plot(hl2, editable = false, display = display.none)
// Create fills between the current mid price and the highest and lowest price.
fill(p1, p3, color = isNewPeriod ? na : color.new(color.lime,    90))
fill(p2, p3, color = isNewPeriod ? na : color.new(color.fuchsia, 90))
// Highlight the background when a new period begins.
bgcolor(isNewPeriod ? color.new(color.gray, 90) : na)
```

**In our script we:**

-   Declare both `hi` and `lo` variables using the
    [var](/pine-script-docs/language/variable-declarations#var)
    keyword. This ensures that their values are retained bar to bar.
-   Detect the beginning of a new timeframe using the
    [timeframe.change()](https://www.tradingview.com/pine-script-reference/v5/#fun_timeframe.change)
    function, in tandem with the user period input.
-   Upon detecting a new timeframe, the `hi` and `lo` variables are set
    based on the source inputs provided by the user. By default, they
    are set to the bar\'s
    [high](https://www.tradingview.com/pine-script-reference/v5/#var_high)
    and
    [low](https://www.tradingview.com/pine-script-reference/v5/#var_low)
    values, respectively.
-   For each following bar after the new timeframe\'s onset, we update
    our `hi` and `lo` variables. Specifically, for the `hi` value, it is
    updated with the greater value between the current bar\'s high and
    the previously assigned high variable. Similarly, for the `lo`
    value, it\'s updated with the lesser value between the current
    bar\'s low and the previously assigned low variable.
-   To visually distinguish between periods, we change the color of
    plots to
    [na](https://www.tradingview.com/pine-script-reference/v5/#var_na)
    every time a new timeframe begins.

### How can I track the highs/lows within a specific session or time of day? 

To find if a time is within a specific session, you can use the
[time()](https://www.tradingview.com/pine-script-reference/v5/#fun_time)
function, which retrieves the UNIX time of the current bar based on a
given timeframe and session. If the time point falls outside the
session, the function returns
[na](https://www.tradingview.com/pine-script-reference/v5/#var_na). To
determine if a time is within a specific session, you can pass a
[session
string](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Sessions.html#session-strings)
to the
[time()](https://www.tradingview.com/pine-script-reference/v5/#fun_time)
function and then check if the result is
[na](https://www.tradingview.com/pine-script-reference/v5/#var_na):

![image](@assets/images/Times-dates-sessions-How-can-i-track-the-highs-lows-within-a-specific-session-or-time-of-day-1.png)

``` pine
//@version=5
indicator("Session hi/lo", "", true)

// Inputs.
string DEFAULT = "Default"
string EQ1     = "On"
string EQ2     = "Off"
bool   plotOutsideInput = input.string(EQ2,          "Plot outside of hours", options = [EQ1, EQ2]) == EQ1
bool   showHiInput      = input.string(EQ1,          "Show highs",            options = [EQ1, EQ2]) == EQ1
bool   showLoInput      = input.string(EQ1,          "Show lows",             options = [EQ1, EQ2]) == EQ1
float  srcHiInput       = input.source(high,         "Source for Highs")
float  srcLoInput       = input.source(low,          "Source for Lows")
string timeAllowedInput = input.session("1200-1500", "Allowed hours")
string timezoneInput    = input.string(DEFAULT,      "Timezone", options = [DEFAULT, "GMT-12", "GMT-11", "GMT-10",
  "GMT-9", "GMT-8", "GMT-7", "GMT-6", "GMT-5", "GMT-4", "GMT-3", "GMT-2",  "GMT-1",  "GMT-0",  "GMT+1",  "GMT+2",
  "GMT+3", "GMT+4", "GMT+5", "GMT+6", "GMT+7", "GMT+8", "GMT+9", "GMT+10", "GMT+11", "GMT+12", "GMT+13", "GMT+14"])

// Check to see if we are in allowed hours using session info.
int timeIsAllowed = time(timeframe.period, timeAllowedInput, timezoneInput == DEFAULT ? syminfo.timezone : timezoneInput)
var float hi = na
var float lo = na
if timeIsAllowed
    // We are entering allowed hours; reset hi/lo.
    if not timeIsAllowed[1]
        hi := srcHiInput
        lo := srcLoInput
    else
        // We are in allowed hours; track hi/lo.
        hi := math.max(srcHiInput, hi)
        lo := math.min(srcLoInput, lo)

// Plot hi/lo within allowed hours, or if `plotOutsideInput` is enabled.
plot(showHiInput and (plotOutsideInput or timeIsAllowed) ? hi : na, "Highs", color.lime,    3, plot.style_circles)
plot(showLoInput and (plotOutsideInput or timeIsAllowed) ? lo : na, "Lows",  color.fuchsia, 3, plot.style_circles)
bgcolor(not timeIsAllowed ? color.new(color.red, 90) : na)
```

**In our script we:**

-   Utilize the 3-parameter version of the
    [time()](https://www.tradingview.com/pine-script-reference/v5/#fun_time)
    function to ascertain whether we are within user-specified hours and
    timezone for tracking highs and lows.
-   Pass two user settings to the
    [time()](https://www.tradingview.com/pine-script-reference/v5/#fun_time)
    function:
    -   The session input, allowing the user to determine session times.
    -   An option to adjust the timezone. If this isn\'t specified, the
        default timezone of the symbol is used, which is the symbol\'s
        exchange timezone.
-   Declare both `hi` and `lo` variables using the
    [var](/pine-script-docs/language/variable-declarations#var)
    keyword. This ensures that their values are retained bar to bar.
-   Set the `hi` and `lo` variables on the first bar of the session
    based on the source inputs provided by the user. By default, they
    are set to the bar\'s
    [high](https://www.tradingview.com/pine-script-reference/v5/#var_high)
    and
    [low](https://www.tradingview.com/pine-script-reference/v5/#var_low)
    values, respectively.
-   Update our `hi` and `lo` variables for each following bar after the
    beginning of the session. Specifically, for the `hi` value, it is
    updated with the greater value between the current bar\'s high and
    the previously assigned high variable. Similarly, for the `lo`
    value, it\'s updated with the lesser value between the current
    bar\'s low and the previously assigned low variable.
-   Provide an option to plot values even if they are outside the
    specified time range. By default, only values within the range are
    plotted.
-   Highlight the background red when a bar\'s time falls outside the
    session time.

### How can I track highs/lows between specific intrabar hours? 

Historical charts display one set of OHLCV data for each bar, which can
mask specific values and times that occur within a bar\'s timeframe.
This level of granularity makes it difficult to identify values and
times that start or end within a chart bar. To overcome this limitation,
intrabar inspection is necessary.

Intrabar inspection involves analyzing data from a lower timeframe than
the chart\'s timeframe for a more granular representation of what
occurred within a chart bar. For instance, if one looks at an hourly
chart, the market open might occur mid-bar, making it hard to determine
pre-market highs and lows. By pulling data from a lower timeframe, such
as a 15-minute chart, we increase the number of data points, providing a
clearer insight into that hour\'s events.

In our example script, we employ the concept of intrabar inspection to
illustrate pre-market highs and lows. Specifically, we make use of the
[request.security_lower_tf()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security_lower_tf)
function to access data from a 15-minute chart:

![image](@assets/images/Times-dates-sessions-How-can-i-track-highs-lows-between-specific-intrabar-hours-1.png)

``` pine
//@version=5
indicator("Pre-market high/low", "", true)

// Inputs.
string DEFAULT          = "Default"
string timeAllowedInput = input.session("0700-0930", "Allowed hours")
float  srcHiInput       = input.source(high,         "Source for Highs")
float  srcLoInput       = input.source(low,          "Source for Lows")
string lowerTfInput     = input.timeframe("15",      "Intrabar resolution used")
string timezoneInput    = input.string(DEFAULT,      "Timezone", options = [DEFAULT, "GMT-12", "GMT-11", "GMT-10",
  "GMT-9", "GMT-8", "GMT-7", "GMT-6", "GMT-5", "GMT-4", "GMT-3", "GMT-2",  "GMT-1",  "GMT-0",  "GMT+1",  "GMT+2",
  "GMT+3", "GMT+4", "GMT+5", "GMT+6", "GMT+7", "GMT+8", "GMT+9", "GMT+10", "GMT+11", "GMT+12", "GMT+13", "GMT+14"])


// @function            Determines and tracks the highest and lowest values of `srcHi` and `srcLo` between specified session times.
// @param srcHi         (series float) The source data for the high value.
// @param srcLo         (series float) The source data for the low value.
// @param sess      (simple string) The session duration specified in the format "start time - end time". Example: "0930-1600"
// @param timeZone      (simple string) The time zone of the session in "GMT-0" format. Optional. Default is the symbol's timezone.
// @returns             ([float, float]) A tuple of the highest and lowest values of the source data between the specified session times.
hiLoBetweenTime(series float srcHi, series float srcLo, simple string sess, simple string timeZone = "Default") =>
    var float hi = na
    var float lo = na
    // Check to see if we are in allowed hours using session and timezone info.
    bool inSession = not na(time("", sess, timeZone == "Default" ? syminfo.timezone : timeZone))
    if inSession
        // We are entering allowed hours; reset hi/lo.
        if not inSession[1]
            hi := srcHi
            lo := srcLo
        else
            // We are in allowed hours; track hi/lo.
            hi := math.max(hi, srcHi)
            lo := math.min(lo, srcLo)
    [hi, lo]


// Request data from lower timeframe using the `hiLoBetweenTime()` function.
[hiArray, loArray] = request.security_lower_tf(
     ticker.modify(syminfo.tickerid, session.extended),
     lowerTfInput,
     hiLoBetweenTime(
         srcHiInput,
         srcLoInput,
         timeAllowedInput,
         timezoneInput))

// Check that array is populated before pulling the most recent value and plot.
float highAtTime = hiArray.size() > 0 ? hiArray.last() : na
float lowAtTime  = loArray.size() > 0 ? loArray.last() : na
plot(highAtTime, "High", color.green)
plot(lowAtTime,  "Low",  color.red)

// Raise error if lower tf is the same or greater than chart's tf.
if timeframe.in_seconds() <= timeframe.in_seconds(lowerTfInput)
    runtime.error("The lower timeframe for intrabar inspection must be lower than the chart's timeframe.")
```

**In our script we:**

-   Create a function, `hiLoBetweenTime()`, to track the session\'s
    highs and lows.
    -   Within that function, we utilize the 3-parameter version of the
        [time()](https://www.tradingview.com/pine-script-reference/v5/#fun_time)
        function to determine whether we are within user-specified hours
        and timezone for tracking highs and lows.
    -   Declare two variables, `hi` and `lo`, using the
        [var](/pine-script-docs/language/variable-declarations#var) keyword. This ensures that their values are retained
        bar to bar.
    -   Set the `hi` and `lo` variables on the first bar of the session
        based on the source inputs provided by the user.
    -   Update our `hi` and `lo` variables for each following bar after
        the beginning of the session to the highest and lowest values so
        far.
-   Modify the symbol string using
    [ticker.modify()](https://www.tradingview.com/pine-script-reference/v5/#fun_ticker.modify)
    to include extended session data, ensuring the script identifies
    premarket highs and lows even when the chart is set to regular
    trading hours.
-   Pass the `hiLoBetweenTime()` function to
    [request.security_lower_tf()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security_lower_tf)
    to determine the session\'s highs and lows within the context of the
    lower timeframe.
-   The
    [request.security_lower_tf()](https://www.tradingview.com/pine-script-reference/v5/#fun_request.security_lower_tf)
    function returns an array with a value for each bar in the lower
    timeframe. From this array, we extract the most recent value to
    determine the current high or low.
-   Raise an error with
    [runtime.error()](https://www.tradingview.com/pine-script-reference/v5/#fun_runtime.error)
    if the chosen lower timeframe for intrabar inspection isn\'t shorter
    than the main chart\'s timeframe, ensuring users don\'t erroneously
    pick the same or a longer timeframe for intrabar analysis.

### How can I detect a specific date/time? 

To detect a specific date or time, we will utilize the
[built-in](/pine-script-docs/built-in-functions)
variables:
[year](https://www.tradingview.com/pine-script-reference/v5/#var_year),
[month](https://www.tradingview.com/pine-script-reference/v5/#var_month),
[dayofmonth](https://www.tradingview.com/pine-script-reference/v5/#var_dayofmonth),
[hour](https://www.tradingview.com/pine-script-reference/v5/#var_hour),
[minute](https://www.tradingview.com/pine-script-reference/v5/#var_minute),
and
[second](https://www.tradingview.com/pine-script-reference/v5/#var_second).
These variables return the values corresponding to their names for each
bar on which the script runs. It\'s important to note that they return
time in the exchange\'s timezone, as detailed
[here](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Time.html?highlight=time#time-built-ins)
in the Pine Script™ User Manual. To align your chart settings with the
exchange timezone, click the time shown in the bottom right corner of
your chart and set it to \"exchange\" time.

In the chart snapshot, the script\'s inputs set the time to \"12:30\".
The lighter shades of green mark each bar that falls within the time
criteria, whereas the bright background green signifies the beginning of
the target date/time, or the first bar that aligns with the set time.
Notice that the chart time matches \"12:30\", which would not be the
case if the chart's time had not been set to the exchange's timezone.

Often it is necessary to capture a value during the transition to the
target time. Here, we demonstrate how to store the open value each time
the target date/time is achieved. When plotting the captured value, we
first evaluate for transitions. This approach ensures the display plot
remains free from an unwanted stepped appearance, resulting in a
continuous line for each period.

![image](@assets/images/Times-dates-sessions-How-can-i-detect-a-specific-date-time-1.png)

``` pine
//@version=5
indicator("Detecting a specific time (in the exchange's timezone)", "", true)

int yearInput   = input.int(0,  "Year (use 0 for all)",    minval = 0)
int monthInput  = input.int(0,  "Month (use 0 for all)",   minval = 0, maxval = 12)
int dayInput    = input.int(0,  "Day (use 0 for all)",     minval = 0, maxval = 31)
int hourInput   = input.int(24, "Hour (use 24 for all)",   minval = 0, maxval = 24)
int minuteInput = input.int(60, "Minute (use 60 for all)", minval = 0, maxval = 60)
int secondInput = input.int(60, "Second (use 60 for all)", minval = 0, maxval = 60)

// Determine if the current date/time matches or exceeds the user's input, until any larger unit (set to its default value) changes.
bool targetReached =
  (yearInput   == 0  or year       >= yearInput)   and
  (monthInput  == 0  or month      >= monthInput)  and
  (dayInput    == 0  or dayofmonth >= dayInput)    and
  (hourInput   == 24 or hour       >= hourInput)   and
  (minuteInput == 60 or minute     >= minuteInput) and
  (secondInput == 60 or second     >= secondInput)

// Detect the start of the user-specified date/time range.
bool targetStart = not targetReached[1] and targetReached
// Highlight background when target date/time is reached.
bgcolor(targetReached ? color.new(color.green, 90) : na, title = "In allowed time")
// Highlight background brighter when first entering the target date/time.
bgcolor(targetStart ? color.new(color.lime, 50) : na, title = "Entry into allowed time")

// Store the opening price at the start of the user-specified date/time.
var float savedOpen = na
if targetStart
    savedOpen := open
plot(savedOpen, "Saved open", targetStart ? na : color.gray, 3)

// Plot current bar"s date/time in the Data Window.
plot(year,       "year",       display = display.data_window)
plot(month,      "month",      display = display.data_window)
plot(dayofmonth, "dayofmonth", display = display.data_window)
plot(hour,       "hour",       display = display.data_window)
plot(minute,     "minute",     display = display.data_window)
plot(second,     "second",     display = display.data_window)
```

### How can I know the date when the highest value was found? 

To determine the date on which the highest value occurred, we follow a
two-step process. Initially, we utilize the function
[ta.highest()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.highest)
to ascertain the highest value itself. Subsequently, to determine the
date of this occurrence, we use the function
[ta.highestbars()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.highestbars).
This function is designed to work in tandem with `ta.highest()`,
providing an offset value of 0 for the bar corresponding to the highest
value. In our example script, we utilize this behavior to determine when
the highest or lowest point occurs and conditionally update values for
our labels and plots when the condition is met:

![image](@assets/images/Times-dates-sessions-How-can-i-know-the-date-when-the-highest-value-was-found-1.png)

``` pine
//@version=5
indicator("Date of High/Low", "", true)

int lengthInput = input.int(100)

// @function            Sets the position of a label to the specified y-coordinate and updates its text to the current bar's date and time.
// @param lbl       (label) The label object that needs to be updated.
// @param y             (float) The y-coordinate to set the label's position to.
// @returns             (void) Function has no explicit return.
setLabel(label lbl, float y) =>
    label.set_xy(lbl, bar_index, y)
    label.set_text(lbl, str.format_time(time, "YYYY.MM.dd @ HH:mm:ss"))

// Use the `var` keyword to declare variables for high and low times and labels, allowing them to be updated bar-by-bar.
var int hiTime = na
var int loTime = na
var label hiLabel = label.new(na, na, "", color = na, textcolor = color.lime)
var label loLabel = label.new(na, na, "", color = na, textcolor = color.fuchsia)
// Find the highest and lowest values over the input lookback and the bars they occurred.
float hiValue  = ta.highest(lengthInput)
float loValue  = ta.lowest(lengthInput)
float hiOffset = ta.highestbars(lengthInput)
float loOffset = ta.lowestbars(lengthInput)

// If the high and low occur on the current bar, update the label and time variables.
if hiOffset == 0
    setLabel(hiLabel, hiValue)
    hiTime := time
if loOffset == 0
    setLabel(loLabel, loValue)
    loTime := time

// Plot the highest and lowest values.
// Display the individual time attributes (hour, minute, day, month, year) of the high and low times in the data window.
plot(hiValue,            "High",              color.lime)
plot(loValue,            "Low",               color.fuchsia)
plot(na,                 "═════════════════", color.lime,    display = display.data_window)
plot(hour(hiTime),       "Hour of high",      color.lime,    display = display.data_window)
plot(minute(hiTime),     "Minute of high",    color.lime,    display = display.data_window)
plot(dayofmonth(hiTime), "Day of high",       color.lime,    display = display.data_window)
plot(month(hiTime),      "Month of high",     color.lime,    display = display.data_window)
plot(year(hiTime),       "Year of high",      color.lime,    display = display.data_window)
plot(na,                 "═════════════════", color.fuchsia, display = display.data_window)
plot(hour(loTime),       "Hour of low",       color.fuchsia, display = display.data_window)
plot(minute(loTime),     "Minute of low",     color.fuchsia, display = display.data_window)
plot(dayofmonth(loTime), "Day of low",        color.fuchsia, display = display.data_window)
plot(month(loTime),      "Month of low",      color.fuchsia, display = display.data_window)
plot(year(loTime),       "Year of low",       color.fuchsia, display = display.data_window)
```

**In our script we:**

-   Declare two variables, `hiTime` and `loTime`, with the
    [var](/pine-script-docs/language/variable-declarations#var)
    keyword. This ensures their values are retained bar to bar.
-   Declare two accompanying labels with
    [var](/pine-script-docs/language/variable-declarations#var)
    to display the high and low time at the respective highest or lowest
    bar in the lookback period.
-   To determine when new highs or lows occur, we verify that the bar
    offset functions return 0. If true, we:
    -   Update our `hiTime` or `loTime` variables to the current time.
    -   Modify the label to display the bar time using a custom
        function. This function sets the label\'s x and y coordinates
        and formats the Unix time into a more readable format.
-   Plot the highest and lowest level for visual reference.
-   In the data window, we display the high and low times, broken down
    into individual time attributes. This demonstrates how to extract
    specific time values from the Unix timestamps of the highest and
    lowest bars.

### How can I detect bars opening at a specific hour? 

This code demonstrates three methods for detecting bars that open at
1800 hours:

``` pine
//@version=5
indicator("1800 hours")
int  t       = time(timeframe.period, "1800-1900")
int  tt      = timestamp(year, month, dayofmonth, 18, 00, 00)
bool method1 = hour == 18 and minute == 00
bool method2 = not na(t) and na(t[1])
bool method3 = tt == time
plotchar(method1 ? 1 : na, "method1", "•", location.absolute, color.red,    size = size.tiny)
plotchar(method2 ? 2 : na, "method2", "•", location.absolute, color.orange, size = size.tiny)
plotchar(method3 ? 3 : na, "method3", "•", location.absolute, color.yellow, size = size.tiny)
```

**Method 1** - Directly checks the current bar\'s time.

-   We check if the built-in
    [hour](https://www.tradingview.com/pine-script-reference/v5/#var_hour)
    variable is equal to 18 and if the minute variable is equal to 0.

**Method 2** - Uses the
[time()](https://www.tradingview.com/pine-script-reference/v5/#fun_time)
function with a session string to detect the start of the session.

-   Using the `time()` function with a [session
    string](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Sessions.html?highlight=session#session-strings),
    we generate a session time. If it\'s outside the session time, the
    function returns
    [na](https://www.tradingview.com/pine-script-reference/v5/#var_na).
    We then determine the first bar that falls within the session by
    verifying if the current returned time is not
    [na](https://www.tradingview.com/pine-script-reference/v5/#var_na)
    and was
    [na](https://www.tradingview.com/pine-script-reference/v5/#var_na)
    one bar earlier.

**Method 3** - Compares the current bar\'s time with a specific
timestamp.

-   We generate a timestamp using the
    [timestamp()](https://www.tradingview.com/pine-script-reference/v5/#fun_timestamp)
    function by specifying 18 hours and 0 minutes, and inputting the
    current day, month, and year. We then verify if the bar\'s time
    matches this timestamp.

### Can I time the duration of a condition? 

In Pine Script™, the introduction of
[varip](https://www.tradingview.com/pine-script-reference/v5/#kw_varip)
variables allows tracking the duration a condition remains true during
the execution of a script on a realtime bar. This can be particularly
useful for trades to ensure they exit only when an exit condition
persists for a specific duration. This duration could be either shorter
than the chart\'s timeframe or extend across multiple realtime bars.

To illustrate how a timer functions, we use a label that exhibits three
states:

1.  **Red** - Awaiting condition.
2.  **Yellow** - Condition met and timer initiated.
3.  **Green** - Timer\'s set duration surpassed, simulating a
    time-delayed alert.

If the difference between the high and the open in ticks exceeds the
input value, a timer starts and will turn the label green once the input
time is exceeded to simulate a time-delayed alert. There is an alert
that triggers, if configured, when the timer is reached.

:::warning[Notice!]
The condition inherently relies on the characteristics of a single bar,
and as a result, the reset condition might appear arbitrary in this
context. However, the implementation offers an input choice to either
reset the condition with each new bar or let it extend across several
bars. This design provides the potential for a timer that spans longer
than a single bar, especially if the condition holds true over multiple
realtime bars. Keep that in mind if you adapt the code for your own
timer.
:::

![image](@assets/images/Times-dates-sessions-Can-i-time-the-duration-of-a-condition-1.png)

``` pine
//@version=5
indicator("Seconds Since", overlay = true)

import PineCoders/Time/4 as PCtime

string TICKS_TT = "The number of ticks between the open and the high to trigger the alert. Once the value is exceeded the timer will start."
string SEC_TT   = "Seconds for which the condition must be continuously true before the alert triggers."
string RESET_TT = "When checked, the duration will reset every time a new realtime bar begins."

int    ticksInput   = input.int(0,     "Number Of Ticks From Open",   tooltip = TICKS_TT)
float  secondsInput = input.int(20,    "Seconds condition must last", tooltip = SEC_TT, minval = 1)
bool   resetInput   = input.bool(true, "Reset timing on new bar",     tooltip = RESET_TT)

// Condition to check for the difference in ticks from the high and the open.
bool cond = math.abs(high - open) > syminfo.mintick * ticksInput
// Time the duration the condition has been true.
int secFromOpen = PCtime.secondsSince(cond, resetInput and barstate.isnew)
// Condition to check if the duration is greater than the input timer.
bool timeAlert = secFromOpen > secondsInput
// Format a time string for the timer label.
string alertTime = str.format_time(secFromOpen * 1000, "mm:ss")

// Set the contents for the label depending on the stage of the alert timer.
string alertString = switch
    timeAlert => "Timed Alert Triggered\n\n" + alertTime
    cond      => "Condition Detected...\n\nTimer count\n" + alertTime
    =>           "Waiting for condition..."

// Display alert timer using a label. Update values on the last bar for efficiency.
if barstate.islast
    // Declare a basic label once.
    var label condTime = label.new(na, na, yloc = yloc.abovebar, style = label.style_label_lower_left, textcolor = chart.fg_color)
    // Update label for changes to location, color, and text.
    label.set_x(condTime, bar_index)
    label.set_text(condTime, alertString)
    label.set_color(condTime, timeAlert ? color.new(color.green, 50) : cond ? color.orange : color.new(color.red, 50))

// Fire alert if timer is triggered.
if timeAlert
    alert("Timed Alert Triggered")
```

**In our script we:**

-   Import the `secondsSince()` function from the PineCoder\'s
    [time](https://www.tradingview.com/script/tyeeNU9I-Time/) library
    -   The `secondsSince()` function determines the duration, in
        seconds, during which a certain condition remains uninterrupted
        in its true state. The timing commences when this condition
        shifts from a false to true state. Should the condition revert
        to false or an optional resetting condition be met, the timing
        sequence restarts. By default, if this resetting condition
        isn\'t supplied, the function restarts its timing at the onset
        of a new bar.
    -   **The function only works in real time** as historical bars have
        a limited number of data points per bar. It relies on realtime
        updates and the times that they occur.
-   Provide an input, `secondsInput`, that denotes the number of seconds
    a condition should persist as true. This input is then compared with
    the time returned by the `secondsSince()` function to determine if
    the duration condition has been met.
-   Set the labels text and color based on whether the condition has
    been detected or not, or if the timed alert has triggered.

:::warning[Notice!]
Due to the fact that scripts only run on price updates, it is possible
for the timer to exceed a given specified time on symbols with low
liquidity. For example, the condition checking that the time has been
exceeded would not trigger until a price update occurred with a
timestamp that causes the timed alert to trigger. Simply put: without a
price update, the script won\'t run and the trigger won\'t activate.
:::

**Additional References:**

-   For a practical example of this function in action, refer to our
    [Volatility
    Stop](https://www.tradingview.com/script/v9YZoIw1-Volatility-Stop/)
    script.
-   For more information on the `secondsSince()` function and the use of
    [varip](https://www.tradingview.com/pine-script-reference/v5/#kw_varip)
    variables, consult the PineCoder\'s [Using \`varip\`
    variables](https://www.tradingview.com/script/ppQxBISk-Using-varip-variables-PineCoders/)
    publication.

### How can I identify the nth occurrence of a weekday in the month? 

Determining the nth occurrence of a specific weekday within a month can
be a complex task in Pine Script™. This calculation could be relevant
for scheduled events that occur on specific weekdays, such as *Quad
Witching*. Quad Witching days, characterized by the simultaneous
expiration of various options contracts, can significantly impact market
volatility. For traders and analysts, the ability to programmatically
identify these days could be valuable, either to capitalize on the
volatility or to steer clear due to its unpredictable nature.

Our example script shows how to use our `weekDayOfMonth()` function to
detect the third friday of each month --- a common timing for Quad
Witching events. The script visually distinguishes each third Friday of
every third month in aqua to indicate Quad Witching days, while marking
other third Fridays in purple:

![image](@assets/images/Times-dates-sessions-How-can-i-identify-the-nth-occurance-of-a-weekday-in-the-month-1.png)

``` pine
// @version=5
indicator("N-th weekday of the month")

//@variable The weekday to check for in the current month. 1 = Monday.
int weekdayInput = input.int(5, "Weekday", 1, 7)
//@variable The occurrence of the weekday to check for in the current month.
int occurrenceInput = input.int(3, "Occurrence", 1, 5)

// @function                Calculates the number of days in a specified month, accounting for leap years.
// @param yearNumber        (int) The year of the `monthNumber` month. Optional. Default is the current year.
// @param monthNumber       (int, optional) The month for which to find the number of days. Optional. Default is the current month.
// @returns                 (int) The number of days in the `monthNumber` month of the `yearNumber` year.
daysPerMonth(int yearNumber = year, int monthNumber = month) =>
    bool isLeapYear = (yearNumber % 4 == 0 and yearNumber % 100 != 0) or (yearNumber % 400 == 0)
    int result = switch
        monthNumber == 2 => isLeapYear ? 29 : 28
        =>                  31 - (monthNumber - 1) % 7 % 2

//@function            Creates a timestamp representing the N-th occurrence of a specified weekday within a given month.
//@param yearNumber    (int) The year of the timestamp.
//@param monthNumber   (int) The month of the timestamp.
//@param weekdayNumber (int) The weekday of the timestamp. Can be a value between 1 and 7, where 1 is a Monday.
//@param occurrence    (int) The occurrence of the `weekdayNumber` to check for.
//@returns             (int) The timestamp at the N-th `occurrence` of the `weekdayNumber` in the month.
weekdayOfMonth(int yearNumber, int monthNumber, int weekdayNumber, int occurrence) =>
    int startTime = timestamp(yearNumber, monthNumber, 1)
    int daysInTheMonth = daysPerMonth(yearNumber, monthNumber)
    int endTime = timestamp(yearNumber, monthNumber, daysInTheMonth)
    int weekday = dayofweek(startTime) - 1
    if syminfo.timezone == "Etc/UTC" and not timeframe.isintraday
        weekday -= 1
    if weekday == 0
        weekday := 7
    int offset = weekdayNumber - weekday
    if offset < 0
        offset := 7 + offset
    int result = startTime + (offset + 7 * (occurrence - 1)) * 86400000
    if result > endTime
        result := na
    result
//@variable The timestamp at the `occurrenceInput` occurrence of the `weekdayInput` in the current month.
int occurrenceTime = weekdayOfMonth(year(time_close), month(time_close), weekdayInput, occurrenceInput)
//@variable Is `true` when `time_close` reaches the `occurrenceTime`, `false` otherwise.
bool isAtOccurrence = time_close[1] < occurrenceTime and time_close >= occurrenceTime
//@variable Is `true` on every 3rd month of the occurrence.
bool isQuadWitching = isAtOccurrence and month % 3 == 0

// Plot the `occurrenceTime` and `time_close`.
plot(occurrenceTime, "Time of the N-th weekday occurrence", color.orange, 3, plot.style_linebr)
plot(time_close, "Bar close time")
// Highlight the background for `isQuadWitching` aqua and `isAtOccurrence` purple.
bgcolor(isQuadWitching ? color.aqua : isAtOccurrence ? color.purple : na, title = "Time condition highlight")
```

**In our script we:**

-   Provide inputs for users to specify the target weekday (e.g., Friday
    as 5) and the nth occurrence (e.g., 3 for the third occurrence).
    This allows for dynamic adjustments from the menu without altering
    the script\'s logic.
-   Create a custom function, `daysPerMonth()`, which calculates the
    number of days in any given month, considering leap years. This is
    crucial for accurately determining the last possible date a specific
    nth occurrence could fall on.
-   Determine the timestamp for the nth occurrence of a selected weekday
    within a specific month using the `weekdayOfMonth()` function. This
    function first calculates the start time of the month and assesses
    the total number of days it contains. The function accounts for the
    unique characteristic of futures symbols, which begin trading on
    Sunday night, potentially causing a one-day discrepancy in the
    calculation. By adjusting for this initial weekday offset, the
    function aligns the calculation to ensure that the nth occurrence of
    the target weekday is accurately determined within the symbol\'s
    context.
-   Visually mark the identified dates on the chart by highlighting the
    background and plotting the time to the Data Window. Additionally,
    it conditionally changes the chart\'s background color to highlight
    Quad Witching days specifically.

### How can I implement a countdown timer? 

In our example, we demonstrate a countdown timer similar to the one
displayed on the chart scale used to determine the time remaining in
each bar. This code functions on intraday and 1D timeframes. For
timeframes longer than 1D, more sophisticated logic is necessary.

To calculate the time remaining in the current bar, we subtract
[timenow](https://www.tradingview.com/pine-script-reference/v5/#var_timenow)
from
[time_close](https://www.tradingview.com/pine-script-reference/v5/#var_time_close)
and then display the result in a table. We use
[str.format_time()](https://www.tradingview.com/pine-script-reference/v5/#fun_str.format_time)
to present the timestamp in a format similar to the countdown timer
visible on your chart:

![image](@assets/images/Times-dates-sessions-How-can-i-implement-a-countdown-timer-1.png)

``` pine
//@version=5
indicator("Count Down timer", overlay = true)

int alertTimeInput = input.int(10, "Seconds left timer")

int timeLeftInBar = (timeframe.isdaily and timeframe.multiplier == 1) or timeframe.isintraday ? time_close - math.min(timenow, time_close) : 0
bool timerTriggered = timeLeftInBar > alertTimeInput * 1000

var table timer = table.new(position = position.bottom_center, columns = 1, rows = 1)
if barstate.isfirst
    table.cell(timer, 0, 0, text_color = chart.fg_color, text_size = size.large)
else if barstate.islast
    color  backgroundColor = timerTriggered ? #089981 : #f23645
    string countDown = str.format_time(timeLeftInBar, "HH:mm:ss", "UTC-0")
    table.cell_set_text(timer, 0, 0, countDown)
    table.cell_set_bgcolor(timer, 0, 0, backgroundColor)

if timerTriggered
    alert(str.format("{0} seconds left in bar", alertTimeInput))
```

:::warning[Notice!]
Due to the fact that scripts only run on price updates, it is possible
for the timer to display an inaccurate time on symbols with low
liquidity. This is because the remaining time in the bar only refreshes
during each script iteration. Simply put: without a price update, the
script won\'t run and the remaining time value won\'t update.
:::

### How can I get the week of the month? 

In our example scripts, we tackle the challenge of determining the week
of the month, a useful metric for analyzing data in a time-specific
context. We present two methods to calculate the week of the month, each
with its own script example:

**Method 1:** Calculating based on mondays

-   This method calculates the week of the month by identifying the
    first Monday of the month and counting the number of Mondays that
    have passed. It takes into account the edge case where the month
    starts on a Sunday, ensuring accurate week calculation from the very
    start of the month.
-   By determining the day of the week for the first day of the month
    and calculating the days until the first Monday, this approach
    provides a robust method for counting weeks.
-   The script dynamically counts the weeks as Mondays pass, ensuring
    each week of the month is accurately represented.

``` pine
// @version=5
indicator("Week of month")

weekOfMonth(timestamp = time) =>
    int dayOfMonth = dayofmonth(timestamp)
    // Find the weekday of the first day of the month. We then count how many days until the next Monday.
    int firstDayWeekday = dayofweek(timestamp - (dayOfMonth - 1) * 86400000)
    // Days before the first Monday in the month.
    int daysBeforeFirstMonday = firstDayWeekday == 1 ? 0 : firstDayWeekday == 7 ? 1 : 9 - firstDayWeekday
    // Count the number of Mondays (or trading days after a non-trading Monday) that have passed this month up to the current day.
    int mondaysPassed = dayOfMonth <= daysBeforeFirstMonday ? 1 : 1 + math.floor((dayOfMonth - daysBeforeFirstMonday + 6) / 7)
    int result = timeframe.ismonthly ? na : mondaysPassed

plot(weekOfMonth())
bgcolor(ta.change(weekofyear) != 0 ? color.new(color.gray, 90) : na)
bgcolor(ta.change(month)      != 0 ? color.new(color.lime, 90) : na)
```

**Method 2:** Counting weeks incrementally

-   This method simplifies the calculation by incrementing a week
    counter declared with
    [var](/pine-script-docs/language/variable-declarations#var)
    each time a change in the
    [weekofyear](https://www.tradingview.com/pine-script-reference/v5/#var_weekofyear)
    built-in variable is detected, and resetting this counter to 1 at
    the start of each new month.
-   The use of
    [ta.change()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.change)
    ensures that the week counter is correctly reset at the beginning of
    a new month, addressing the transition from month to month.

``` pine
// @version=5
indicator("Week of month")

weekOfMonth(timestamp = time) =>
    var int week = na
    if ta.change(weekofyear(timestamp))
        week += 1
    if ta.change(month(timestamp))
        week := 1
    int result = timeframe.ismonthly ? na : week

plot(weekOfMonth())
bgcolor(ta.change(weekofyear) != 0 ? color.new(color.gray, 90) : na)
bgcolor(ta.change(month)      != 0 ? color.new(color.lime, 90) : na)
```

## Variables and Operators 

-   [What is the variable name for the current price?](/pine-script-docs/faq#what-is-the-variable-name-for-the-current-price)
-   `` Why and when should the \`var\` keyword be used together with a variable? <PageFaq_VariablesAndOperators_WhyAndWhenShouldTheVarKeywordBeUsedTogetherWithAVariable> ``
-   `` What is a \`varip\`? <PageFaq_VariablesAndOperators_WhatIsAVarip> ``
-   [What's the difference between ==, =, and :=?](/pine-script-docs/faq#whats-the-difference-between===and:=)
-   [Can I use the := operator to assign values to past values of a series?](/pine-script-docs/faq#can-iuse-the:=operator-to-assign-values-to-past-values-of-aseries)
-   [Why do the OHLC built-ins sometimes return different values than the ones shown on the chart?](/pine-script-docs/faq#why-do-the-ohlc-built-ins-sometimes-return-different-values-than-the-ones-shown-on-the-chart)
-   `` Why do some logical expressions not evaluate as expected when \`na\` values are involved? <PageFaq_VariablesAndOperators_WhyDoSomeLogicalExpressionsNotEvaluateAsExpectedWhenNaValuesAreInvolved> ``

### What is the variable name for the current price? 

In Pine Script™, the variable that represents the current price is known
as
[close](https://www.tradingview.com/pine-script-reference/v5/#var_close).
It provides the closing price of each bar in the historical dataset, and
when an indicator is applied to real-time bars, it delivers the current
price of the most recent bar. During realtime operation, the close
variable updates to reflect the most recent price change.

For a strategy script, the typical execution only occurs at the close of
the realtime bar. Consequently, the
[close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
variable would display the previous bar\'s closing price. To alter this
behavior, the `calc_on_every_tick` parameter can be set to true within
the
[strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
declaration statement. By doing so, the strategy acts like an indicator
and executes with each price change of the realtime bar. As a result,
[close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
mirrors the latest update from the realtime data stream.

To reference the closing price of the previous bar, `close[1]` should be
used. Here, square brackets function as the
[history-referencing operator](/pine-script-docs/language/operators#history-referencing-operator) in Pine Script™.

### Why and when should the \`var\` keyword be used together with a variable? 

The [var](/pine-script-docs/language/variable-declarations#var)
keyword in Pine Script™ is particularly useful when you need to store
data across multiple bars. Pine Script™ executes scripts on each bar,
and by default, variables are reinitialized on every bar if there is no
explicit declaration mode specified. This results in new values for
these variables on each bar.

If you declare a variable without the `var` keyword, it will not retain
its value across chart bars. However, when you use the `var` keyword,
the variable gets initialized only once. If the variable is declared in
the `global
scope <PageFaq_Programming_WhatDoesScopeMean>`, initialization happens on the first bar. If it\'s declared
within a local block, it is initialized the first time that local block
is executed. After its initial assignment, the variable maintains its
last value on subsequent bars until it is reassigned a new value.

This feature is particularly beneficial in scenarios where a variable\'s
value must be retained throughout the script\'s iterations across
successive bars. For instance, in the example below, we demonstrate how
you can accumulate volume across bars using the `var` keyword as
compared to a regular float variable.

``` pine
//@version=5
indicator("Var keyword example")

// Declaring and initializing a variable with `var`.
var float a = 0
// Declaring and initializing a regular float variable
float b = 0

// Reset the values of a and b whenever a new day begins
if timeframe.change("D")
    a := 0
    b := 0

// Add the current volume to both a and b
a += volume
b += volume

// Plot the values of `a` and `b`. Value of `a` will accumulate over time, `b` will be reinitialized at every bar
plot(a, "a", close > open ? #089981 : #f23645, style = plot.style_columns)
plot(b, "b", color.yellow)
```

### What is a \`varip\`? 

[varip](/pine-script-docs/language/variable-declarations#varip)
is a keyword in Pine Script™ that allows you to declare variables that
persist and retain their values between different price updates within
the same realtime bar. This contrasts with the
[typical behavior](/pine-script-docs/language/execution-model) of
Pine Script™, where variables are reset to their last committed value
with each realtime script execution.

This is similar, but not identical, to the
[var](/pine-script-docs/language/variable-declarations#var)
keyword, which allows a variable to retain its value from bar to bar.
While `var` escapes re-initialization on each new bar, `varip` takes
this a step further and escapes the [rollback
process](https://www.tradingview.com/pine-script-docs/en/v5/language/Execution_model.html#calculation-based-on-realtime-bars),
or re-initialization, on each price update in realtime within the same
bar.

As a result, `varip` (which stands for \"variable intrabar persist\")
can track the number of realtime updates that occur within each realtime
bar because it allows the value of a variable to be preserved between
these updates.

It\'s important to note that `varip` only affects the behavior of your
code on realtime bars, not historical ones. Therefore, backtest results
on strategies based on `varip` variables might not accurately reflect
historical bar behavior. Similarly, plots on historical bars won\'t
reproduce the script\'s realtime behavior.

To distinguish between `var` and `varip`, observe the following script
applied to a live market symbol. With realtime updates, the varip plot
increments within a bar on each price update, whereas the `var` plot
stays consistent:

![image](@assets/images/Variables-and-operators-What-is-a-varip-1.png)

``` pine
//@version=5
indicator("varip vs var demo")

// `var`  : Retains value across bars, resets on intrabar price updates.
// 'varip': Retains value across bars and across intrabar price updates within a realtime bar.
var   int varCount   = -1
varip int varipCount = -1

// Increment `varCount` on each bar and `varipCount` on each intrabar price update.
varCount   += 1
varipCount += 1

// Plot values for comparison.
plot(varCount,   "var counter",   color.fuchsia, 4)
plot(varipCount, "varip counter", color.lime)
```

### What\'s the difference between ==, =, and :=?

The ["=" operator](/pine-script-docs/language/operators#assignment-operator) is used for declaring and initializing variables, assigning
a specific value to a named variable. For example, `a = 0` sets the
variable `a` to hold the value 0.

The
[":=" operator](/pine-script-docs/language/operators#reassignment-operator) is used for reassigning values to already initialized
variables. For instance, if you declared `a = 1` earlier in your code,
`a := 2` would subsequently update the value of a to 2, illustrating its
mutability.

Finally, the [\"==\"
operator](https://www.tradingview.com/pine-script-reference/v5/#op_==)
is a
[comparison operator](/pine-script-docs/language/operators#comparison-operators). It checks the equality between two values, returning a
[boolean](/pine-script-docs/language/type-system#bool)
(true/false) result. For instance, `a == b` would be true if a and b
hold the same value. It is the opposite of
[!=](https://www.tradingview.com/pine-script-reference/v5/#op_!=), which
is true if the two variables are not equal.

This logic is demonstrated in the following script where variables `a`
and `b` are initialized, `a` is reassigned, and then equality
comparisons are performed and plotted.

``` pine
//@version=5
indicator("Variable operators demo", overlay = true)

// Define two variables `a` and `b` using `=`, representing the high and low of each bar.
float a = high
float b = low

// Define the initial line color as lime
color lineColor = color.lime

// When there are less than 10 bars remaining on the chart, 
// use `:=` to update `a` to `b` and change the line color to fuchsia.
if last_bar_index - bar_index < 10
    a := b
    lineColor := color.fuchsia

// Plot the variable 'a' to visualize its change in value. 
// Initially, 'a' represents the 'high' of each bar. 
// If there are less than 10 bars remaining in the chart, 'a' is updated to represent the 'low' of each bar.
plot(a, "Our line", lineColor, 2)

// Plot a checkmark character whenever `a` is equal to `b`.
plotchar(a == b, "a equals b", "✅", location.bottom)

// Plot a cross character whenever `a` is not equal to `b`.
plotchar(a != b, "a does not equal b", "❌", location.bottom)
```

### Can I use the := operator to assign values to past values of a series?

No, you can\'t. Historical values are fixed and cannot be changed. Just
as you can\'t alter the past in real life, you are unable to modify
historical values in a series as they are read-only. However, you can
assign a value to the current instance of a series.

### Why do the OHLC built-ins sometimes return different values than the ones shown on the chart? 

There may sometimes be discrepancies between the OHLC (Open, High, Low,
Close) values displayed on the chart and the actual values returned by
the [built-in](/pine-script-docs/built-in-functions) OHLC
variables
([open](https://www.tradingview.com/pine-script-reference/v5/#var_open),
[high](https://www.tradingview.com/pine-script-reference/v5/#var_high),
[low](https://www.tradingview.com/pine-script-reference/v5/#var_low),
[close](https://www.tradingview.com/pine-script-reference/v5/#var_close)).
This is due to the fact that data feeds can contain price points that
exceed a symbol\'s defined tick precision. While chart prices are always
rounded to tick precision, the built-in variables maintain their
original, unrounded values.

For instance, if an exchange feed provides a closing price of 30181.07
which is more precise than the symbol\'s 0.1 tick size, the chart will
display a rounded value of 30181.1, whereas the built-in variable will
hold the unrounded value of 30181.07.

Subtle differences, while not immediately obvious, can lead to
significant outcomes, especially in scenarios requiring precise
calculations or when diagnosing unexpected behaviors in scripts. An
example of this is in detecting crossover events. Discrepancies between
unrounded and rounded values can cause crossover events to be identified
in one scenario but not in the other, illustrating how minor variations
can impact the results of precision-sensitive calculations.

A possible strategy to mitigate this issue is to manually round the OHLC
built-in variables to the nearest tick size before using them in
calculations. This approach is demonstrated in the script below, which
highlights discrepancies between actual OHLC values and their rounded
counterparts by comparing them directly and visually indicating any
differences by coloring the background red:

![image](@assets/images/Variables-and-operators-Why-do-the-ohlc-built-ins-sometimes-return-different-values-than-the-ones-shown-on-the-chart-1.png)

``` pine
//@version=5
indicator("Different tick values example", overlay = true, precision = 10)

// Define a function that rounds each OHLC value to the nearest minimum tick size and returns these values in a tuple.
OHLCToMinTick() =>
    [math.round_to_mintick(open), math.round_to_mintick(high), math.round_to_mintick(low), math.round_to_mintick(close)]

// Define a function that compares two float values and returns the color blue if they are equal or red if they are not.
getTickColor(series float v1, series float v2) =>
    color result = v1 != v2 ? color.red : color.blue

// Round each OHLC value to the nearest mintick size.
[o, h, l, c] = OHLCToMinTick()

// Plot the original and rounded values of each OHLC component in the data window.
// If a value and its rounded counterpart are not equal, color the plot red. Otherwise, color it blue.
plot(o,     "o",     getTickColor(o, open),  display = display.data_window)
plot(open,  "open",  getTickColor(o, open),  display = display.data_window)
plot(h,     "h",     getTickColor(h, high),  display = display.data_window)
plot(high,  "high",  getTickColor(h, high),  display = display.data_window)
plot(l,     "l",     getTickColor(l, low),   display = display.data_window)
plot(low,   "low",   getTickColor(l, low),   display = display.data_window)
plot(c,     "c",     getTickColor(c, close), display = display.data_window)
plot(close, "close", getTickColor(c, close), display = display.data_window)

// If any of the original and rounded values of OHLC components are not equal, set the background color to red
bgcolor(o != open or h != high or l != low or c != close ? color.new(color.red, 90) : na)
```

### Why do some logical expressions not evaluate as expected when \`na\` values are involved? 

In Pine Script™, logical expressions have three possible states:
[true](https://www.tradingview.com/pine-script-reference/v5/#op_true),
[false](https://www.tradingview.com/pine-script-reference/v5/#op_false),
and [na](https://www.tradingview.com/pine-script-reference/v5/#var_na).
Here, `na` doesn\'t represent a third logical value but instead
signifies the absence of a value, similar to NULL in other programming
languages. This can lead to unexpected outcomes when a logical
expression involves `na`. Rather than resulting in `true` or `false` as
you might intuitively expect, any logical expression that includes `na`
will always result in `na`. For instance, `na == na`, `na == true`,
`na == false`, or `na != true` will all yield `na`.

If a logical expression evaluates to `na`, the `false` branch of a
[conditional structure](/pine-script-docs/language/conditional-structures) or
[ternary operator](/pine-script-docs/language/operators#ternary-operator) will execute, which may cause unpredictable results. Thus,
it\'s important to account for these special cases when writing code to
ensure it handles all possible logical expression results accurately.

Consider an example in which we\'re debugging code. Let\'s assume we
want to compare two variables that should always hold identical values,
but one or both variables may hold a `na` value. In such a scenario,
both `a == b` and `a != b` would result in `na`, rather than `true` or
`false`.

Once we understand this principle, it becomes clear why the first
[bgcolor()](https://www.tradingview.com/pine-script-reference/v5/#fun_bgcolor)
line in the provided code does not change the background color. We might
anticipate that the logical expression `a != b` would be `true`, and
thus, the background would turn lime. However, since `a` does not equal
`b`, the logical expression evaluates to `na`. As a result, the `false`
branch of the ternary operation is executed, and no color is plotted for
the background.

The second `bgcolor()` line performs as expected. If you comment out the
first `bgcolor()` line and uncomment the second one, you will observe
this. The additional lines in the script illustrate diverse
implementations of this concept, factoring in the
[handling of na values](/pine-script-docs/language/type-system#na-value). Specifically, they demonstrate how to check for `na` values
using the
[na()](https://www.tradingview.com/pine-script-reference/v5/#fun_na)
function, thereby ensuring the expected outcomes even when `na` values
are part of the logical expression.

``` pine
//@version=5
indicator("Na example")
int a = 1
int b = na
bgcolor(a != b ? color.new(color.lime, 80) : na) // na, so goes to the false branch.
// bgcolor(a == b ? na : color.new(color.red, 80)) // na, so goes to the false branch.
// bgcolor(na(a != b) ? color.new(color.orange, 80) : na) // true, so this works.
// bgcolor(a != b or na(a != b) ? color.new(color.fuchsia, 80) : na) // true, so this works.
```

## Visuals 

-   [Why can't I use a plot in an if or for statement?](/pine-script-docs/faq#why-cant-iuse-aplot-in-an-if-or-for-statement)
-   [Can I plot diagonals between two points on the chart?](/pine-script-docs/faq#can-iplot-diagonals-between-two-points-on-chart)
-   [How do I plot a line using start/stop criteria?](/pine-script-docs/faq#how-do-iplot-aline-using-start-stop-criteria)
-   [How do I plot a support or a trend line?](/pine-script-docs/faq#how-do-iplot-asupport-or-atrend-line)
-   [How can I use colors in my indicator plots?](/pine-script-docs/faq#how-can-iuse-colors-in-my-indicator-plots)
-   [How do I make my indicator plot over the chart?](/pine-script-docs/faq#how-do-imake-my-indicator-plot-over-the-chart)
-   [How can I plot vertical lines on a chart?](/pine-script-docs/faq#how-can-iplot-vertical-lines-on-achart)
-   [How can I toggle hline() plots on and off?](/pine-script-docs/faq#how-can-itoggle-hline-plots-on-and-off)
-   [How can I draw lines or labels into the future?](/pine-script-docs/faq#how-can-idraw-lines-or-labels-into-the-future)
-   [How can I keep only the last n number of objects?](/pine-script-docs/faq#how-can-ikeep-only-the-last-nnumber-of-objects)
-   [Is it possible to draw geometric shapes?](/pine-script-docs/faq#is-it-possible-to-draw-geometric-shapes)
-   `How can I color the chart's background on a condition detected on the last bar? <HowCanIColorTheChartsBackgroundOnAConditionDetectedOnTheLastBar>`

### Why can\'t I use a plot in an if or for statement? 

In Pine Script™, placing
[plot()](https://www.tradingview.com/pine-script-reference/v5/#fun_plot)
calls directly within
[if](https://www.tradingview.com/pine-script-reference/v5/#kw_if) or
[for](https://www.tradingview.com/pine-script-reference/v5/#kw_for)
statements or other
[local scopes](/pine-script-docs/faq#what-does-scope-mean) isn\'t permitted. This is because the system needs to know
all potential plots during the compilation phase, so introducing plots
conditionally during the runtime phase would be problematic.

While you can\'t dynamically introduce or remove entire `plot()` calls
based on conditions during runtime, you can still manipulate what\'s
displayed within those plots. By controlling the variables, values, or
colors fed into the `plot()` function based on specific conditions, you
can achieve dynamic visual representations. For example, let\'s say you
want to display moving averages only when they are sequentially ordered,
either in an ascending or descending manner. The approach would be:

1.  Define the relevant criteria or condition.
2.  Use the condition to manipulate either the value to be plotted, or
    the color to be used for the plot.
3.  Use the conditional value or color in the `plot()` function that is
    called in the
    [global scope](/pine-script-docs/faq#what-does-scope-mean) of your script.

In our example script, an
[ALMA](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.alma)
moving average is plotted alongside a cloud formed between two
shorter-duration averages. The moving average and cloud appear only when
the three averages are sequentially arranged. Additionally, when the
cloud\'s depth exceeds the
[ATR](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.atr)
threshold, a fourth longer-term average is shown.

![image](@assets/images/Visuals-Why-cant-i-use-a-plot-in-an-if-or-for-statement-1.png)

``` pine
//@version=5
indicator("Conditional plot example", "", true)

// ——— STEP 1: Define moving averages
// Here we are using 4 ALMA moving averages with different lengths.
float ma1 = ta.alma(close, 21,  0.85, 6)
float ma2 = ta.alma(close, 50,  0.85, 6)
float ma3 = ta.alma(close, 200, 0.85, 6)
float ma4 = ta.alma(close, 347, 0.85, 6)

// ——— STEP 2: Define conditions for plotting
// Create conditions to only show MA 1, 2, and 3 when MA's are stacked.
bool showBullFill = ma1 > ma2 and ma2 > ma3
bool showBearFill = ma1 < ma2 and ma2 < ma3
// Create condition to only show MA 4 when the distance between MA 1 and MA 2 are greater than the ATR.
bool showLongAlma = math.abs(ma1 - ma2) > ta.atr(14)

// ——— STEP 3: Plot the MAs
// These two MAs will only be shown in the data window and will be hidden on the main chart.
// We use them to create a filled area (or cloud) between them in a later step.
p1 = plot(ma1, "MA 1: Conditional fill", display = display.data_window, editable = false)
p2 = plot(ma2, "MA 2: Conditional fill", display = display.data_window, editable = false)

// Method 1: Conditional Color Plotting
// Values are plotted continuously, but because we make our color conditional, it only shows when our condition is true.
p3 = plot(ma3, "MA 3: Conditional color", showBullFill ? color.aqua : showBearFill ? color.orange : na, 2)
fill(p1, p2, showBullFill or showBearFill ? color.new(ma1 > ma2 ? color.aqua : color.orange, 70) : na)

// Method 2: Conditional Value Plotting
// This only plots a value when our condition is true, otherwise the plot value is set to `na`.
plot(showLongAlma ? ma4 : na, "MA 4: Conditional plot", color.new(color.fuchsia, 70), 4, plot.style_linebr)
```

### Can I plot diagonals between two points on the chart? 

Yes, in Pine Script™, you can plot diagonal lines between two points on
a chart. There are mainly two methods to accomplish this:

**Method 1: Using plot()**

The
[plot()](https://www.tradingview.com/pine-script-reference/v5/#fun_plot)
function in Pine Script™ is designed for visualizing data points on a
chart. By default, it connects consecutive data points with straight
lines. When a series contains
[na](https://www.tradingview.com/pine-script-reference/v5/#var_na)
values for certain bars, no value is plotted, causing the plotted points
on either side of the `na` values to connect directly. This results in a
diagonal appearance between these data points. For example, functions
like
[ta.pivotlow()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.pivotlow)
return `na` for all bars except those with identified pivots. Thus, when
the results of these functions are plotted, the isolated plot points are
inherently connected by diagonal lines.

**Method 2: Using line.new()**

The
[line.new()](https://www.tradingview.com/pine-script-reference/v5/#fun_line.new)
function offers a more explicit way to draw lines, including diagonals,
directly on the chart. Unlike the
[plot()](https://www.tradingview.com/pine-script-reference/v5/#fun_plot)
function, which connects a series of data points, `line.new()` is
specifically designed to connect two distinct points. Further, this
function allows lines to extend either forward or backward in time,
providing flexibility beyond the bar-by-bar plotting of the `plot()`
function. Another advantage is that lines drawn using `line.new()` can
be adjusted post-creation, a feature not available with `plot()`. For
functions such as `ta.pivotlow()`, one can store the identified pivot
points and then use the `line.new()` function to either manually connect
these points or create custom visual displays, sidestepping the
automatic plotting behavior inherent to the `plot()` function.

![image](@assets/images/Visuals-Can-i-plot-diagonals-between-two-points-on-the-chart-1.png)

``` pine
//@version=5
indicator("Diagonal lines", overlay = true)

// ——— Method 1: Using plot()

// Find the value of the pivot low.
float pivotLow = ta.pivotlow(20, 20)

// Plot the pivot value.
// Because `ta.pivot*()` yields na for all bars except those with pivots,
// the resulting plots form diagonal connections between bars with values.
plot(pivotLow, "Pivot Low", color.fuchsia, offset = -20, display = display.pane)
// Place a circle on each pivot low to emphasize the points being connected, offsetting it back to the pivot bar.
plot(pivotLow, "Pivot Low", color.fuchsia, 3, plot.style_circles, offset = -20)


// ——— Method 2: Using `line.new()`.

// Initialize an array to store pivot points, allowing them to be recalled for connection when a new pivot is found.
var array<chart.point> highPointArray = array.new<chart.point>(2, chart.point.new(na, na, na))

// Find the value of the pivot high.
float pivotHigh = ta.pivothigh(20, 20)

// Check that a pivot is found by ensuring the pivot value isn't `na`, a value
// present on all bars except those with identified pivots.
if not na(pivotHigh)
    // Create a new point object for the pivot, using the bar positioned "pivot right length" bars prior and the pivot value.
    chart.point pivotPoint = chart.point.from_index(bar_index - 20, pivotHigh)
    // Retrieve the most recent pivot point identified before the current one.
    chart.point prevPivot = array.last(highPointArray)
    // Store the current pivot point in the array for future reference.
    array.push(highPointArray, pivotPoint)
    // Remove the earliest pivot point from the array, ensuring it only tracks the two most recent pivots.
    array.shift(highPointArray)
    // Draw a line from the previous pivot point to the current pivot point.
    line.new(prevPivot, pivotPoint, color = color.lime, style = line.style_dotted)

// Place a circle on each pivot high to emphasize the points being connected, offsetting it back to the pivot bar.
plot(pivotHigh, "Pivot high", color.lime, 3, plot.style_circles, offset = -20)
```

**In our script we:**

-   Link pivot low points with the
    [plot()](https://www.tradingview.com/pine-script-reference/v5/#fun_plot)
    function, using an offset equal to the pivot length bars for proper
    alignment on pivot bars. While plots connect from point to point
    automatically, this method offers limited control over the process.
-   Connect pivot highs with
    [line.new()](https://www.tradingview.com/pine-script-reference/v5/#fun_line.new).
    These lines are then extended to the right, creating a ray-like
    trendline appearance, to illustrate a foundational approach to
    something beyond simple plotting.
-   Use an array-based
    [queue](/pine-script-docs/language/arrays#using-an-array-as-aqueue) to continuously store the two most recent pivot points.
    When a new pivot is detected, it\'s added to the array, replacing
    the oldest entry, and we then draw a line between these two latest
    points.
-   For both versions, we emphasize the points being connected by
    plotting circles on the pivot price. Using the `offset` parameter,
    we plot backward based on a count that matches the pivot detection
    length.

### How do I plot a line using start/stop criteria? 

To plot a line based on start and stop criteria, you should consider the
following structured approach:

1.  **Define start and stop conditions:**
    -   Specify the conditions or criteria under which the line starts
        and stops.
    -   For instance, in our example script below, we begin plotting the
        [close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
        value of the bar when a new pivot is identified and continue
        until that value is crossed, or the line exists for the maximum
        number of input bars.
2.  **Manage variable states:**
    -   Create logic to hold and manage the variable states and the
        levels at which you desire to plot. This is helpful for
        controlling when and where your plotting occurs according to the
        predefined start and stop conditions.
    -   For example, we use the `plotValue` boolean to decide whether
        the line should be plotted and the `savedValue` float variable
        to capture the level at which the line is to be drawn. The
        assignment of these values is governed by the *start* and *stop*
        conditions.
3.  **Use appropriate plotting and debug techniques:**
    -   Utilize the
        [plot()](https://www.tradingview.com/pine-script-reference/v5/#fun_plot)
        function, integrating both
        [na](https://www.tradingview.com/pine-script-reference/v5/#var_na)
        for plotting and the `style = plot.style_linebr` parameter,
        while also modifying the color. This technique avoids the
        creation of a continuous line, preventing the formation of
        inelegant joints between varying levels.
    -   Use the
        [plotchar()](https://www.tradingview.com/pine-script-reference/v5/#fun_plotchar)
        function to represent debugging information, illustrating the
        states of the boolean elements used in the logic. While not
        crucial for the final output, such plots confirm the code is
        working as expected, serving as protective measures against
        logical errors and saving time during code development.

In the following script, we begin plotting the `close` value when a new
pivot is detected and continue until the `close` crosses this value
again, with an option for the line to expire if uncrossed within a set
number of bars. The activation of the start condition sets the flag for
line plotting to true and captures the value to plot. The plot output is
adjusted to
[na](https://www.tradingview.com/pine-script-reference/v5/#var_na) and
the color modified to delineate the line strictly between the start and
stop condition bars. For clarity, right and left arrow debug characters
are plotted to illustrate the points where the plot condition holds
true, and dots are displayed to signal every instance a start or stop
condition is met:

![image](@assets/images/Visuals-How-do-i-plot-a-line-using-start-stop-criteria-1.png)

``` pine
//@version=5
indicator("Plot line from start to end condition", overlay = true)

string EQ01 = "On"
string EQ02 = "Off"

// Create an input to set a limit on the maximum number of bars for a line, and provide an option to toggle its use.
int  expiryBarsInput   = input.int(300, "Maximum bars line will plot", minval = 0, inline = "00")
bool useBarExpiryInput = input.string(EQ01, "", inline = "00", options = [EQ01, EQ02]) == EQ01

// Initialize two variables whose values persist across bars.
// One to store the line value, and another to determine whether the line should be plotted.
var bool  plotValue  = false
var float savedValue = na

// Define conditions for the start and end of the line plot.
bool startCondition = ta.pivothigh(close, 5, 2)
bool endCondition   = ta.cross(close, savedValue)
bool startEvent     = not plotValue and startCondition
bool hasExpired     = ta.barssince(startEvent) > expiryBarsInput and useBarExpiryInput
bool endEvent       = plotValue and (endCondition or hasExpired)

// If `startEvent` is `true`, update the `savedValue` and set `plotValue` to true to start plotting the line.
if startEvent
    savedValue := close
    plotValue  := true

// If the end event is `true`, set `plotValue` to `false` to stop plotting the line.
if endEvent
    plotValue := false

// Plot the line if `plotValue` is true this bar or last bar.
// Color it orange, except when a new line is initiated immediately after ending one, to avoid visual disruptions to the line.
color lineColor = startEvent and endEvent[1] ? na : color.orange
plot(plotValue or plotValue[1] ? savedValue : na, "Saved Value", lineColor, style = plot.style_linebr)

// Plot characters to visually represent various conditions and states on the chart.
// Arrows are plotted to indicate the points where the line should be plotted between.
// Dots are plotted each time a start or end condition is met.
plotchar(startCondition, "startCondition", "•", location.abovebar, color.green, size = size.tiny)
plotchar(endCondition,   "endCondition",   "•", location.belowbar, color.red,   size = size.tiny)
plotchar(startEvent,     "startEvent",     "►", location.abovebar, color.green, size = size.tiny)
plotchar(endEvent,       "endEvent",       "◄", location.belowbar, color.red,   size = size.tiny)
```

### How do I plot a support or a trend line? 

Plotting support and resistance and trend lines are intricate concepts,
both characterized by a considerable degree of subjectivity regarding
their definitions and applications. These notions revolve around
determining significant points in a price series and establishing
connections between them, thereby raising several pertinent questions:

-   *Which points are deemed significant and why?*
-   *How should these points be interconnected?*
-   *How should these concepts be displayed on the chart?*
-   *What conditions or criteria dictate the maintenance, removal, or
    invalidation of such points, or the objects that represent them?*

Each of these questions can potentially have a hundred plausible
answers, with ten different coding methodologies corresponding to each
solution, contributing to the complexity and subjectivity of these
concepts. Given the intricate nature of these topics, finding a
comprehensive answer within our FAQ is unlikely. However, we provide you
with some guidance and illustrative examples to clarify the basic
nuances of the subject, and some popular scripts that may give you some
inspiration. Keep in mind that these are complex concepts to explore in
Pine Script™ and are best served for those that have spent some time
getting to know the language and programming in general.

In our first example script, we illustrate the basic concepts of support
and resistance. The script uses the `ta.pivot*()` built-ins to detect
pivot highs and lows, drawing lines from these points until they're
crossed by the
[close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
of a bar. This way, we track levels of support and resistance until they
are broken by price action:

![image](@assets/images/Visuals-How-do-i-plot-a-support-or-a-trend-line-1.png)

``` pine
//@version=5
indicator("SnR breaches", "", true, max_lines_count = 500)

color hiPivotColorInput  = input.color(color.lime,    "High pivots")
color loPivotColorInput  = input.color(color.fuchsia, "Low pivots")
int   pivotLegsInput     = input.int(5,                 "Pivot legs")
int   qtyOfPivotsInput   = input.int(50,                "Quantity of last pivots to remember", minval = 0, maxval = 250)
int   maxLineLengthInput = input.int(400,               "Maximum line length in bars",         minval = 2)


// @function            Queues a new `arrayElement` at the end of the `id` array and de-queues
//                      the first element if the array size exceeds the specified `maxSize`.
// @param id            (<any array type>) The array in which the element is to be queued.
// @param maxSize       (int) The maximum allowed number of elements in the array.
//                      If the array size exceeds this, the first element is de-queued.
// @param arrayElement  (<type of the array's elements>) The new element to be added to the array.
// @returns             (<type of the array's elements>) The de-queued element.
arrayQueue(id, int maxSize, value) =>
    id.push(value)
    if id.size() > maxSize
        id.shift()


// @function            Evaluates each line in `lineArray`, extending their lengths and removing any
//                      line that the price has crossed or that exceeds `lineMaxLength` in length.
// @param lineArray     (array<line>) An array storing the lines to be checked.
// @param lineMaxLength (int) The maximum length a line can have before it is considered too long.
// @returns             (void) The function has no explicit return.
checkLinesForBreaches(array<line> lineArray, int lineMaxLength) =>
    int qtyOfLines = lineArray.size()
    // Don't loop in case there are no lines to check because "from" value will be `na` then.
    // We loop the array in reverse to handle element shift during item removal, ensuring every line is evaluated.  
    for lineNo = qtyOfLines > 0 ? qtyOfLines - 1 : na to 0
        // Get each line, check for crosses, or if the line is too long. 
        line  eachLine       = lineArray.get(lineNo)
        float lineLevel      = eachLine.get_price(bar_index)
        bool  lineWasCrossed = math.sign(close[1] - lineLevel) != math.sign(close - lineLevel)
        bool  lineIsTooLong  = bar_index - eachLine.get_x1() > lineMaxLength
        // Set the right `x2` coordinate of each line to the current bar. 
        eachLine.set_x2(bar_index)
        if lineWasCrossed or lineIsTooLong
            // Line stays on the chart but will no longer be extended on further bars.
            lineArray.remove(lineNo)
            // Set the `extend` parameter of the removed line to the `extend.none`.
            eachLine.set_extend(extend.none)


// @function            Checks for the presence of a pivot and, if found, draws a line from the pivot, adds this line to
//                      the array, and removes and deletes the oldest line from the array if the max count is exceeded.
// @param lineArray     (array<line>) An array to store and manage the drawn line objects.
// @param pivotValue    (float) The pivot value when a pivot is found.
// @param pivotLength   (simple int) The length of the pivot legs.
// @param maxLinesCount (int) The maximum number of lines to maintain in the `lineArray`. Excess lines are deleted.
// @param lineColor     (color) The color for the drawn line.
// @returns             (void) The function has no explicit return.
queueLines(array<line> lineArray, float pivotValue, int pivotLength, int maxLinesCount, color lineColor) =>
    if not na(pivotValue)
        line newLine = line.new(bar_index - pivotLength, pivotValue, bar_index, pivotValue, extend = extend.right, color = lineColor)
        line.delete(arrayQueue(lineArray, maxLinesCount, newLine))


// Arrays of lines containing non-crossed pivot lines.
var array<line> hiPivotLines = array.new<line>()
var array<line> loPivotLines = array.new<line>()

// Detect new pivots.
float hiPivot = ta.pivothigh(pivotLegsInput, pivotLegsInput)
float loPivot = ta.pivotlow(pivotLegsInput,  pivotLegsInput)

// Create new lines on new pivots, while removing and deleting the oldest, uncrossed lines.
queueLines(hiPivotLines, hiPivot, pivotLegsInput, qtyOfPivotsInput, hiPivotColorInput)
queueLines(loPivotLines, loPivot, pivotLegsInput, qtyOfPivotsInput, loPivotColorInput)

// Extend lines if they haven't been crossed by price, or expired.
checkLinesForBreaches(hiPivotLines, maxLineLengthInput)
checkLinesForBreaches(loPivotLines, maxLineLengthInput)
```

**In our script we:**

1.  **Identify pivot points:**
    -   We utilize
        [ta.pivotlow()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.pivotlow)
        and
        [ta.pivothigh()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.pivothigh)
        to identify pivot lows and pivot highs, which act as support and
        resistance, respectively.
2.  **Draw lines horizontally from pivots:**
    -   On detecting a pivot, draw a line from the corresponding bar and
        extend it to the current bar, setting the `extend` parameter to
        [extend.right](https://www.tradingview.com/pine-script-reference/v5/#var_extend.right)
        to project it indefinitely into the future.
3.  **Add lines to an array:**
    -   Handle lines as a group by adding all created lines to an array.
    -   Using an array enables the simultaneous adjustment of attributes
        and coordinates of each line, analysis of price crosses with
        each line, and removal of invalidated levels. By iterating
        through the array with a
        [for](https://www.tradingview.com/pine-script-reference/v5/#kw_for)
        loop, each line can be managed uniformly as a group in a single
        operation.
4.  **Implement a queue:**
    -   Manage the array like a
        [queue](/pine-script-docs/language/arrays#using-an-array-as-aqueue) to maintain only a maximum number of lines at a
        time.
    -   If this maximum is exceeded, delete the oldest uncrossed line
        and shift the array to remove that element, controlling the
        array\'s size.
5.  **Manage lines using the array:**
    -   We update the `x2` point of all lines in the array so that their
        coordinates continue to update to the current bar on each bar.
    -   Cycle through the array on each bar, assessing each line against
        the
        [close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
        value to determine if crossings occurred or if the line exceeds
        the input maximum number of bars.
    -   If a line meets either of these criteria, its extend parameter
        is set to
        [extend.none](https://www.tradingview.com/pine-script-reference/v5/#var_extend.none),
        and it is removed from the array. This prevents the line from
        projecting indefinitely into the future, ensures its `x2` point
        concludes on the crossing bar, and eliminates it from future
        tracking due to its absence from the array. Note that lines
        removed in this manner are not deleted, preserving their
        visibility in the chart\'s history.

In our second example script, we illustrate the basic concepts of trend
lines. The script uses the `ta.pivot*()` built-ins to detect pivot highs
and lows, drawing lines from the two most recent pivots and extending
indefinitely to the right. The script maintains a specified maximum
number of lines. If drawing new lines causes this maximum to be
exceeded, the oldest lines are removed and deleted. This example is kept
straightforward to serve as an initial reference without unnecessary
complexity. Management of trend line intersections is left for your
exploration:

![image](@assets/images/Visuals-How-do-i-plot-a-support-or-a-trend-line-2.png)

``` pine
//@version=5
indicator("Simple trend lines demo", overlay = true, max_lines_count = 500)

int   pivotLegsInput    = input.int(20,                "Pivot legs")
int   maxLinesInput     = input.int(2,                 "Quantity of lines to track per pivot", minval = 0, maxval = 250)
color loTrendColorInput = input.color(color.lime,    "Trend low")
color hiTrendColorInput = input.color(color.fuchsia, "Trend high")


// @function            Queues a new `arrayElement` at the end of the `id` array and de-queues
//                      the first element if the array size exceeds the specified `maxSize`.
// @param id            (<any array type>) The array in which the element is to be queued.
// @param maxSize       (int) The maximum allowed number of elements in the array.
//                      If the array size exceeds this, the first element is de-queued.
// @param arrayElement  (<type of the array's elements>) The new element to be added to the array.
// @returns             (void) The function has no explicit return.
arrayQueue(id, maxSize, arrayElement) =>
    id.push(arrayElement)
    if id.size() > maxSize
        id.shift()


// @function            Draws a line between the two most recent pivot points if a `pivotValue` is detected.
//                      Manages the `lineArray` of drawn lines to ensure it doesn't exceed a maximum count. Older
//                      lines are removed and deleted if the number of lines surpasses the `maxLinesCount`.
// @param lineArray     (array<line>) An array to store and manage the drawn line objects.
// @param pivotValue    (float) The pivot value when a pivot is found.
// @param pivotLength   (simple int) The length of the pivot legs.
// @param maxLinesCount (simple int) The maximum number of lines to maintain in the `lineArray`. Excess lines are deleted.
// @param lineColor     (color) The color for the drawn line.
// @returns             (void) The function has no explicit return.
queueLine(array<line> lineArray, float pivotValue, simple int pivotLength, simple int maxLinesCount, color lineColor) =>
    var array<chart.point> pointArray = array.new<chart.point>(2, chart.point.new(na, na, na))
    if not na(pivotValue)
        arrayQueue(pointArray, 2, chart.point.from_index(bar_index - pivotLength, pivotValue))
        chart.point firstPoint  = pointArray.first()
        chart.point secondPoint = pointArray.last()
        line ln = line.new(firstPoint, secondPoint, extend = extend.right, color = lineColor, style = line.style_dotted)
        line.delete(arrayQueue(lineArray, maxLinesCount, ln))


// Initialize 2 empty arrays for the high and low trend lines on the first bar.
var array<line> hiLinesArray = array.new<line>()
var array<line> loLinesArray = array.new<line>()

// Detect new pivots.
float hiPivot = ta.pivothigh(pivotLegsInput, pivotLegsInput)
float loPivot = ta.pivotlow(pivotLegsInput,  pivotLegsInput)

// Draw new lines between the 2 most recent pivots when a pivot is detected and add them to the line array.
// The number of lines is limited to the input qty of lines, after which lines are removed and deleted.
queueLine(hiLinesArray, hiPivot, pivotLegsInput, maxLinesInput, hiTrendColorInput)
queueLine(loLinesArray, loPivot, pivotLegsInput, maxLinesInput, loTrendColorInput)

// Visually highlight the pivot points with a dot.
plot(hiPivot, "Pivot High", hiTrendColorInput, 3, plot.style_circles, offset = -pivotLegsInput)
plot(loPivot, "Pivot Low",  loTrendColorInput, 3, plot.style_circles, offset = -pivotLegsInput)
```

**In our script we:**

1.  **Identify pivot points:**
    -   We use the [built-in](/pine-script-docs/built-in-functions) functions
        [ta.pivotlow()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.pivotlow)
        and
        [ta.pivothigh()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.pivothigh)
        to capture the pivot highs and lows. These pivot points act as
        the base for our trend lines.
2.  **Draw trend lines between pivots:**
    -   When a new pivot is detected, we generate a trend line that
        connects the most recent two pivots. This connection is extended
        indefinitely to the right by setting the `extend` parameter to
        [extend.right](https://www.tradingview.com/pine-script-reference/v5/#var_extend.right).
3.  **Store and manage lines in an array:**
    -   We maintain two arrays, `hiLinesArray` and `loLinesArray`, to
        keep track of the trend lines. Each newly drawn line is added to
        the relevant array. Storing lines in arrays allows for easier
        management, especially when checking the number of lines and
        removing old lines, or searching for crosses and invalidations.
4.  **Implement a queue:**
    -   Just as we did for support and resistance lines, we make use of
        a
        [queue](/pine-script-docs/language/arrays#using-an-array-as-aqueue) with our `arrayQueue()` function to ensure our array
        doesn\'t surpass a user-defined limit (`maxLinesInput`).
    -   If this maximum is exceeded, delete the oldest line and shift
        the array to remove that element, controlling the array\'s size.
5.  **Plot pivot points for visualization:**
    -   To make the pivot points more visible, we also plot them using
        the
        [plot()](https://www.tradingview.com/pine-script-reference/v5/#fun_plot)
        function. This highlights the pivot high and pivot low with dots
        on the chart, making it easier for a user to identify the points
        to which lines connect.
6.  **Limit complexity for clarity:**
    -   This script is kept deliberately simple, focusing solely on
        plotting trend lines from the latest two pivot high or low
        points. This makes it a perfect starting point for users who
        wish to explore more advanced features, such as determining
        intersections of trend lines or adding more detailed
        functionality.

For further insights and approaches to these intricate concepts,
consider exploring the range of [support and
resistance](https://www.tradingview.com/scripts/supportandresistance/),
and [trend line](https://www.tradingview.com/scripts/trendline/) scripts
available in the [Community
Collection](https://www.tradingview.com/scripts/?script_type=indicators).
Here are a few noteworthy examples:

**Support and resistance:**

-   [Pivots
    MTF](https://www.tradingview.com/script/VYzEUnYB-Pivots-MTF-LucF/)
    by Lucf
-   [Support and Resistance Signals
    MTF](https://www.tradingview.com/script/iOrhpIqc-Support-and-Resistance-Signals-MTF-LuxAlgo/)
    by LuxAlgo
-   [Bjorgum Key
    Levels](https://www.tradingview.com/script/CapG3ivf-Bjorgum-Key-Levels/)
    by Bjorgum
-   [Support Resistance
    Channels](https://www.tradingview.com/script/Ej53t8Wv-Support-Resistance-Channels/)
    by LonesomeTheBlue
-   [Price Action - Support &
    Resistance](https://www.tradingview.com/script/Z1byay68-Price-Action-Support-Resistance-by-DGT/)
    by dgtrd

**Trend Lines:**

-   [Pivot Trendlines with
    Breaks](https://in.tradingview.com/script/0ecaiSnU-Pivot-Trendlines-with-Breaks-HG/)
    by HoanGhetti
-   [Trendlines -
    JD](https://www.tradingview.com/script/mpeEgn5J-Trendlines-JD/) by
    Duyck
-   [Auto TrendLines
    \[HeWhoMustNotBeNamed\]](https://www.tradingview.com/script/JZZObGme-Auto-TrendLines-HeWhoMustNotBeNamed/)
    by Trendoscope

### How can I use colors in my indicator plots? 

The display of data is a multifaceted endeavor that hinges not just on
the raw numbers and figures but on how they are presented. At its core,
the strategic use of color in data visualization allows for easier
comprehension, pattern and trend recognition, and differentiation of
categories or values. Consider a monochromatic bar graph versus one with
distinct color-coded bars: the latter allows the viewer to immediately
discern between different data sets or trends without delving deep into
the actual numbers.

When we talk about communicating information, color serves as a
universal language. In a world inundated with data, the challenge lies
in presenting this data effectively and efficiently. Color helps in
distilling complex data into easily digestible visual segments. For
instance, a heat map uses varying shades to represent different data
intensities, allowing users to grasp spatial patterns at a glance.
Without such color differentiation, discerning such patterns would be a
cumbersome process.

The importance of color extends to bolstering analytical capacities. For
professionals who constantly sift through massive data sets, color-coded
visuals can streamline the analysis process. Different hues can
represent different data thresholds, and gradients can indicate
increases or decreases in value. By transforming numbers into a vibrant
spectrum, we enhance our ability to spot anomalies, trends, and
significant data points, thereby refining our analytical insights. In
essence, color acts as a bridge between sheer quantitative information
and human understanding.

In the realm of Pine Script™, there is a range of functionalities to
make your indicators not just visually appealing, but also informative
and intuitive by incorporating color:

1.  **Predefined colors:** Without needing to specify hexadecimal or RGB
    values, you can use predefined
    [color constants](/pine-script-docs/concepts/colors#constant-colors) like
    [color.red](https://www.tradingview.com/pine-script-reference/v5/#var_color.red),
    for example.
2.  **Conditional coloring:** By assigning colors to variables based on
    specific conditions, you can achieve `dynamic
    color changes <PageColors_ConditionalColoring>` that enhance data representation.
3.  **Custom colors:** For a more personalized appearance, users have
    the freedom to [define their own
    colors](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Colors.html#calculated-colors)
    using a hexadecimal code, or with a color\'s RGB values in the
    [color.rgb()](https://www.tradingview.com/pine-script-reference/v5/#fun_color.rgb)
    function.
4.  **Gradient transitions:** Use
    [color.from_gradient()](https://www.tradingview.com/pine-script-reference/v5/#fun_color%7Bdot%7Dfrom_gradient)
    to create color gradients that highlight shifts in data values by
    ensuring a smooth transition between colors. For detailed guidance
    and innovative examples on implementing gradients, consult the
    [Color Gradient
    Framework](https://www.tradingview.com/script/hqH4YIFa-Color-Gradient-Framework-PineCoders/)
    provided by PineCoders.
5.  **Fills:** Users can
    [create shaded areas](/pine-script-docs/concepts/fills)
    between lines, plots, hlines, and within boxes, which can be
    especially useful for highlighting ranges, zones, or contrasts.
6.  **Transparency settings:** [Adjusting the
    transparency](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Colors.html#mixing-transparencies)
    of a color helps to achieve the right balance between clarity and
    aesthetic appeal.
7.  **Color picker resources:** For those unsure about choosing colors
    or seeking complementary or contrasting schemes, we offer a
    selection of [color
    pickers](https://www.pinecoders.com/resources/#color-pickers-or-tools)
    on our Resources page. For some carefully chosen color options to
    use in your Pine Scripts, see ImmortalFreedom\'s [PSv5 Color Magic
    and Chart Theme
    Simulator](https://www.tradingview.com/script/f27Ejk2I-PSv5-Color-Magic-and-Chart-Theme-Simulator/).

In our sample script, we use various color display techniques such as
conditional colors, fills, and gradients to depict areas of rising or
falling values, as well as overbought and oversold levels, all while
maintaining aesthetic appeal. The script automatically recognizes
whether the user\'s chart background is light or dark, and adjusts the
color scheme accordingly. For a light theme, it captures the ambiance of
a day at the beach with coastal teal and coral hues, while for a dark
theme, it reflects the vibrant neon hues of city nightlife:

![image](@assets/images/Visuals-How-can-i-use-colors-in-my-indicator-plots-1.png)

![image](@assets/images/Visuals-How-can-i-use-colors-in-my-indicator-plots-2.png)

``` pine
//@version=5
indicator("Using colors in Pine", explicit_plot_zorder = true)

// Calculate TSI and its EMA.
float tsi = ta.tsi(close, 13, 23) * 100
float tsl = ta.ema(tsi, 13)


// @function            Determines if a given background color corresponds to a light theme based on its brightness level.
// @param bgColor       (color) The background color to check. Optional. Default value is the chart's background color.
// @returns             (bool) True if the background color is "light" (has a brightness greater than 0.5), otherwise false.
isLightTheme(color bgColor = chart.bg_color) =>
    float r = color.r(bgColor)
    float g = color.g(bgColor)
    float b = color.b(bgColor)
    float brightness = (r + g + b) / (3 * 255)
    bool  isLight = brightness > 0.5


// Check if the chart background is a light or dark theme.
var bool isLightTheme = isLightTheme()

// Define color schemes based on whether the theme is light or dark.
// Light scheme - Tropical Theme
//      Teal & coral: Fresh, vibrant, beachy vibes.
// Dark scheme - Neon Lights Theme
//      Neon purple & blue: Bright and dynamic, emulating city nightlife.
color tsiDnUpColor = isLightTheme ? #1E90FF : #BA33FF
color tsiDnDnColor = isLightTheme ? #FF6B6B : #8100FF
color tsiUpUpColor = isLightTheme ? #00CED1 : #1FE0F3
color tslBullColor = isLightTheme ? #00CED1 : #1FE0F3
color tslBearColor = isLightTheme ? #1E90FF : #0088A3
color tsiBullColor = isLightTheme ? #FFD700 : #33FF57
color tsiBearColor = isLightTheme ? #FF6B6B : #00940D
color tsiUpDnColor = isLightTheme ? #FFD700 : #FF21D4
color bullBgColor  = isLightTheme ? #FFD700 : #80FFFF
color bearBgColor  = isLightTheme ? #FF6B6B : #FF80FF
color obFillColor  = isLightTheme ? #FFD700 : #33FF57
color osFillColor  = isLightTheme ? #FF6B6B : #33FF57

// Determine the direction of the TSI and signal line,
// Determine trend direction by checking if TSI is above the signal,
// and calculate the difference for histogram values.
bool  tsiIsBull   = tsi >= tsi[1]
bool  tslIsBull   = tsl >= tsl[1]
bool  trendIsBull = tsi >= tsl
float diff        = tsi  - tsl

// Get line and fill colors based on trend and plot direction.
color tsiColor  = tsiIsBull   ? tsiBullColor : tsiBearColor
color tslColor  = tslIsBull   ? tslBullColor : tslBearColor
color fillColor = trendIsBull ? tsiIsBull ? tsiUpUpColor : tsiUpDnColor : tsiIsBull ? tsiDnUpColor: tsiDnDnColor

// Create invisible horizontal lines on the chart at +30 and -30 levels
h1 = hline( 30, color = color(na))
h2 = hline(-30, color = color(na))

// Fill areas between horizontal lines with a gradient.
fill(h2, h1, 30,   5, color.new(obFillColor, 80), color(na))
fill(h2, h1, -5, -30, color(na), color.new(osFillColor, 80))

// Define colors and transparency for the histogram bar based on trend direction and theme and plot the bar.
color barBgColor  = isLightTheme ? trendIsBull ? bullBgColor : bearBgColor : chart.bg_color
color barBdColor  = trendIsBull  ? bullBgColor : bearBgColor
int   barBdTransp = isLightTheme ? 50 : 80
int   barBgTransp = isLightTheme ? 90 : 0
float barHi = math.max(0, 0 + diff)
float barLo = math.min(0, 0 + diff)
plotcandle(barLo, barLo, barHi, barHi,
     color       = color.new(barBgColor, barBgTransp),
     bordercolor = color.new(barBdColor, barBdTransp),
     wickcolor   = color(na),
     display     = display.pane)

// Plot the TSI, its EMA
p1 = plot(tsi, "TSI",    color.new(tsiColor, 30))
p2 = plot(tsl, "Signal", color.new(tslColor, 30))
p3 = plot(tsl >  30 ?  30 : na, display = display.none)
p4 = plot(tsl < -30 ? -30 : na, display = display.none)

// Fill between the signal line and overbought or oversold levels with a gradient.
// Fill the cloud between the TSI and signal line with a gradient.
fill(p2, p3,  80,  30, bearBgColor, color.new(bearBgColor, 90))
fill(p2, p4, -30, -80, color.new(bullBgColor, 90), bullBgColor)
fill(p1, p2, tsi, tsl, fillColor, color.new(fillColor, 70))
```

**In our script we:**

1.  **Determine the chart\'s theme:**
    -   Identify the user\'s chart background as either light or dark,
        guiding our color palette.
    -   We use our `isLightTheme()` function to separate the chart
        background color into individual RGB components.
    -   An average brightness level is derived from these components,
        normalized within a 0 to 1 range.
    -   The function identifies the theme as \"light\" if this
        brightness level surpasses 0.5, enabling adaptive color settings
        based on the user\'s chart theme.
2.  **Define color schemes:**
    -   Define colors for plots, hlines, and fills based on whether the
        chart is light or dark theme.
    -   Create two colors schemes accordingly:
        -   Light Theme (Tropical Theme): A beach-inspired palette
            featuring teal & coral shades.
        -   Dark Theme (Neon Lights Theme): Bright neon purple & blue
            hues reminiscent of city nightlife.
3.  **Visualize TSI and signal direction:**
    -   Differentiate direction using distinct colors for each plot.
    -   Assign one color for rising values, another if they are falling.
4.  **Highlight overbought/oversold levels:**
    -   Implement horizontal lines to demarcate overbought and oversold
        zones and fill between them with a color gradient. This gives
        the areas an appearance of scaled severity as the plots travel
        through them.
    -   Fill between the signal line and the overbought and oversold
        levels with another gradient if the plot exceeds either to
        further emphasize potential irregularities.
5.  **Emphasize trends with histogram bars and area fill:**
    -   Utilize the
        [plotcandle()](https://www.tradingview.com/pine-script-reference/v5/#fun_plotcandle)
        function to create bordered column bars, serving as a visually
        distinct histogram that depicts the distance between the TSI and
        signal line.
    -   Bars are painted in bullish or bearish hues based on the
        trend\'s direction.
    -   Use a four-color fill between the TSI and signal line to clarify
        trend direction and changes in trend. For instance, an upward
        trend with a declining TSI will feature a distinct color from
        the general rising trend hue.

### How do I make my indicator plot over the chart? 

To make your indicator plot over the chart, use `overlay = true` in the
[strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
or
[indicator()](https://www.tradingview.com/pine-script-reference/v5/#fun_indicator)
declaration statement:

``` pine
indicator("My Script", overlay = true)
```

If your indicator was already added to your chart before applying this
change, you would need to use \"Add to Chart\" again for the change to
take effect. Additionally, if your script is intended to work
exclusively in overlay mode and you want to prevent users from moving it
to a separate pane, you can add `linktoseries = true` to your
[strategy()](https://www.tradingview.com/pine-script-reference/v5/#fun_strategy)
or
[indicator()](https://www.tradingview.com/pine-script-reference/v5/#fun_indicator)
declaration statement.

### How can I plot vertical lines on a chart? 

There are several ways to plot vertical lines in Pine Script™. Here are
a few of them:

1.  **Using the plot.style_histogram Style:**

    ``` pine
    //@version=5
    indicator("vLine", overlay = true)
    bool cond = bar_index % 10 == 0
    plot(cond ? 10e20 : na, "vLine", color.silver, 1, plot.style_histogram, histbase = -10e20)
    ```

    This method plots a very large number, 10e20, while setting the
    histbase to its negative value. Using this method, a histogram line
    is drawn vertically through the chart to connect the two points. The
    vertical lines can only be drawn where the condition is satisfied.
    This approach has an advantage of drawing an unlimited number of
    lines

2.  **Using the line.new() method:**

    ``` pine
    //@version=5
    indicator("vLine", overlay = true, max_lines_count = 500)
    bool cond = bar_index % 10 == 0
    if cond
        line.new(bar_index, 0, bar_index, 1, extend = extend.both, color = color.silver)
    ```

    This method draws lines using
    [line.new()](https://www.tradingview.com/pine-script-reference/v5/#fun_line.new).
    However, you\'re restricted to a maximum of 500 lines per indicator.
    One advantage here is the ability to adapt the lines to be drawn
    either in the future or in the past, a flexibility not available in
    the previous method.

3.  **Drawing a line at a specific date:**

    ``` pine
    //@version=5
    indicator("vLine on date", overlay = true)
    int timeInput = input.time(timestamp("25 Dec 2023 00:00"), "time")
    var line l1 = line.new(timeInput, 0, timeInput, 1, xloc.bar_time, extend.both, color.silver)
    ```

    In this method, you draw a vertical line at a specified date. You
    use
    [line.new()](https://www.tradingview.com/pine-script-reference/v5/#fun_line.new)
    with the `xloc` parameter set to
    [xloc.bar_time](https://www.tradingview.com/pine-script-reference/v5/#var_xloc.bar_time).
    The line is drawn once on the first bar at the date determined by
    the input menu, which users can adjust.

### How can I toggle hline() plots on and off? 

To toggle
[hline()](https://www.tradingview.com/pine-script-reference/v5/#fun_hline)
plots in a script, here are three methods based on user input from the
menu:

1.  **Using conditional value:**

    ``` pine
    //@version=5
    indicator("Toggle hline")
    bool showHlineInput = input.bool(true, "Show hline")
    hline(showHlineInput ? 50 : na)
    ```

    This method conditionally sets the plotted value to 50 if
    `showHlineInput` is true, otherwise it uses the
    [na](https://www.tradingview.com/pine-script-reference/v5/#var_na)
    value, effectively hiding the line.

2.  **Using conditional color:**

    ``` pine
    //@version=5
    indicator("Toggle hline")
    bool showHlineInput = input.bool(true, "Show hline")
    hline(50, color = showHlineInput ? color.blue : color(na))
    ```

    Here, the plotted value is always 50, but the visibility of the line
    is controlled by its color. When `showHlineInput` is true, the line
    color is blue, otherwise, it\'s set to
    [na](https://www.tradingview.com/pine-script-reference/v5/#var_na),
    making it invisible.

3.  **Using the display parameter:**

    ``` pine
    //@version=5
    indicator("Toggle hline")
    bool showHlineInput = input.bool(true, "Show hline")
    hline(50, display = showHlineInput ? display.all : display.none)
    ```

    In this method, the display property of the
    [hline()](https://www.tradingview.com/pine-script-reference/v5/#fun_hline)
    function is used to control its visibility. When `showHlineInput` is
    true, the line is displayed with
    [display.all](https://www.tradingview.com/pine-script-reference/v5/#var_display.all),
    otherwise, it\'s hidden using
    [display.none.](https://www.tradingview.com/pine-script-reference/v5/#var_display.none)

### How can I draw lines or labels into the future? 

In Pine Script™, extending visual elements beyond the last data point is
a common need. There are two primary techniques to achieve this:

1.  **Using bar_index:**

    [bar_index](https://www.tradingview.com/pine-script-reference/v5/#var_bar_index)
    represents the sequential number of the current bar, starting from
    the first bar in the chart history as 0 and incrementing by 1 for
    each subsequent bar. Objects with their `xloc` parameter set to
    [xloc.bar_index](https://www.tradingview.com/pine-script-reference/v5/#var_xloc.bar_index)
    can use a `bar_index` as their x coordinates.

    -   **Advantage: Easy**
        -   The clearest benefit of `bar_index` is its simplicity. If
            you want to project a certain number of bars into the future
            or past, you merely add or subtract that number from the
            current `bar_index`. For instance, `bar_index + 20` will
            position your object 20 bars into the future.
    -   **Disadvantage: Limitation on number of bars**
        -   While `bar_index` is straightforward, it has a constraint of
            a
            [maximum of 500 bars](/pine-script-docs/writing/limitations#maximum-bars-forward) into the future. Exceeding this will result in a
            runtime error.

2.  **Using time:**

    Pine Script™ also allows objects to be positioned based on UNIX time
    values. Using
    [xloc.bar_time](https://www.tradingview.com/pine-script-reference/v5/#var_xloc.bar_time)
    for an object\'s `xloc` parameter, you can position objects on the
    chart based on specific time values, like timestamps or a bar\'s
    open time. This lets you place visual elements at exact dates and
    times on the x-axis.

    -   **Advantage: Unlimited projections.**
        -   With this method, you\'re not bound by any limitation in
            terms of how far into the future you can project. As long as
            you provide the correct timestamp, the object will be
            positioned accordingly.
    -   **Disadvantages:**
        -   **Precision challenges:** When looking to project a specific
            number of bars into the future using time, it can become
            complex. Calculating based on milliseconds (e.g.,
            determining how many milliseconds ten 1-hour bars represent)
            won\'t account for weekends and market holidays. This can
            lead to discrepancies in non-24/7 markets. For instance,
            trying to project 10 hourly bars ahead on a Friday evening
            might inadvertently position the object during a non-trading
            weekend slot. As real-time advances, these gaps can lead to
            inconsistent positioning of your visual objects, especially
            when specific bar counts are crucial.
        -   **Time zone considerations:** bar
            [time](https://www.tradingview.com/pine-script-reference/v5/#var_time)
            is based on UNIX time. When using raw date values, it\'s
            important to consider both the exchange\'s time zone and the
            user\'s local settings. Discrepancies can arise due to time
            zone differences, leading to objects being displayed in
            unexpected positions on the chart. This can be particularly
            confusing if users of your script are spread across various
            time zones or if the script is used on symbols from
            exchanges located in different regions.

In summary, both methods come with their strengths and challenges. The
choice between them will largely depend on the exact specific needs of
your script and how the objects are implemented within it.

In our example script we draw lines and labels on the most recent pivot
high and low and extend the lines into the future past the last bar:

![image](@assets/images/Visuals-How-can-i-draw-lines-or-labels-into-the-future-1.png)

``` pine
//@version=5
indicator("Draw into the future", overlay = true)

int offsetInput    = input.int(20, "Offset bars", maxval = 500)
int pivotLegsInput = input.int(20, "Pivot legs",  minval = 2)

var line  phLine  = line.new(na, na, na, na, color = chart.fg_color, style = line.style_dotted)
var line  plLine  = line.new(na, na, na, na, color = chart.fg_color, style = line.style_dotted)
var label phLabel = label.new(na, na, na, color = color(na), textcolor = chart.fg_color, style = label.style_label_left)
var label plLabel = label.new(na, na, na, color = color(na), textcolor = chart.fg_color, style = label.style_label_left)

float ph = ta.pivothigh(pivotLegsInput, pivotLegsInput)
float pl = ta.pivotlow(pivotLegsInput,  pivotLegsInput)

if not na(ph)
    line.set_xy1(phLine, bar_index - pivotLegsInput, ph), line.set_y2(phLine, ph)
    label.set_y(phLabel, ph)
    label.set_text(phLabel, str.tostring(ph, format.mintick))
if not na(pl)
    line.set_xy1(plLine, bar_index - pivotLegsInput, pl), line.set_y2(plLine, pl)
    label.set_y(plLabel, pl)
    label.set_text(plLabel, str.tostring(pl, format.mintick))

if barstate.islast
    line.set_x2(phLine,  bar_index + offsetInput)
    line.set_x2(plLine,  bar_index + offsetInput)
    label.set_x(phLabel, bar_index + offsetInput)
    label.set_x(plLabel, bar_index + offsetInput)
```

**In our script we:**

1.  **Set user inputs:**
    -   Allow users to define the number of bars to offset into the
        future with an input titled \"*Offset bars*\".
    -   Let users specify the number of bars to consider for pivot
        detection using an input titled \"*Pivot legs*\".
2.  **Initialize visual elements:**
    -   We use the
        [var](/pine-script-docs/language/variable-declarations#var) keyword to declare two lines and two labels,
        ensuring they are drawn once and persist from bar to bar. This
        allows us to modify their properties during runtime.
3.  **Detect pivots and update visual elements:**
    -   Utilize the
        [ta.pivothigh()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.pivothigh)
        and
        [ta.pivotlow()](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.pivotlow)
        functions to identify the most recent pivot high and pivot low.
    -   If a pivot is detected, update the starting point (`x1`) of the
        corresponding line to the bar where the pivot was identified and
        set its y-value to the detected pivot price. Similarly, update
        the associated label\'s y-value to the pivot price and text to
        display the pivot value.
4.  **Extend visual elements into the future:**
    -   On the last bar of the dataset, adjust the `x2` point of both
        lines and the `x` point of the labels to extend into the future
        by the user-defined offset amount. This ensures that both lines
        and labels project forward by the specified number of future
        bars.

For individuals seeking to project objects forward by a specific number
of time units, refer to the [Time Offset Calculation
Framework](https://www.tradingview.com/script/5mZ7hV66-Time-Offset-Calculation-Framework-PineCoders-FAQ/)
by Pinecoders.

### How can I keep only the last *n* number of objects? 

To retain only the last *n* number of objects, it\'s necessary to track
the references of these objects. Rather than assigning individual
reference IDs to each object, a more efficient approach involves
utilizing an [array](/pine-script-docs/language/arrays) to store
these references.

We manage the array in a way that mimics a *queue*: each time a new
element is to be added, the oldest element is removed from the array and
the new element is added to the end. This queuing technique ensures that
the array maintains the most recent *n* elements for comparison. The
technique is explained in the Pine Script™ User Manual's
[page on arrays](/pine-script-docs/language/arrays#using-an-array-as-aqueue), but we will implement a function that allows us to save
lines:

``` pine
//@version=5

// Set the `max_labels_count` to 500, which is the maximum allowable for a script.
indicator("Limit labels demo", overlay = true, max_labels_count = 500)

// Get required number of historical labels to preserve, using our constant to limit its value. If user chooses 0, no labels will display.
int labelQtyInput = input.int(50, "Quantity of last labels to show", minval = 0, maxval = 500)


// @function            Queues a new element to the end of an array and de-queues the first element.
// @param id            (any array type) An array object.
// @param val       (<type of the array's elements>) The new element to queue to the end of the array.
// @returns             (<type of the array's elements>) The element that was removed from the start of the array.
arrayQueue(id, val) =>
    id.push(val)
    id.shift()


// Create an array of label ids once. Use the user-selected quantity to determine its size.
var array<label> labelsArray = array.new<label>(labelQtyInput)

// On each bar:
// 1. Create a new label.
// 2. Add its id to the end of the `labelsArray` array.
// 3. Remove the oldest label id from the array"s beginning and return its id.
// 4. Delete the label corresponding to that id.
// Note that on early bars, until the array fills to capacity, we will be deleting ids with `na` values, but that doesn"t generate runtime errors.
label.delete(arrayQueue(labelsArray, label.new(bar_index, high, str.tostring(high), style = label.style_label_down, color = color(na))))
```

**In our script we:**

1.  Create the user input `labelQtyInput` for the desired quantity of
    labels to display, ranging from 0 to a
    [maximum of 500](/pine-script-docs/writing/limitations#line-box-polyline-and-label-limits). The default is set to 50.
2.  Declare a function `arrayQueue()` that handles the queueing logic.
    It takes an array and a new value as arguments, pushes the new value
    onto the end of the array, and de-queues and returns the oldest
    element by shifting the array.
3.  Declare an array named `labelsArray` to store label references with
    the [var](/pine-script-docs/language/variable-declarations#var) keyword to ensure it is initialized only once and
    retains its state from bar to bar. The size of this array is
    determined by the user input `labelQtyInput`. By declaring the
    array\'s size without explicitly defining its elements, it is
    initially filled with a number of
    [na](https://www.tradingview.com/pine-script-reference/v5/#var_na)
    objects equal to the declared size.
4.  On each bar the script:
    -   Creates a new label at the current bar\'s high price with the
        high price as its text.
    -   Utilizes the `arrayQueue()` function to add the new label\'s ID
        to `labelsArray` and remove the oldest label\'s ID.
    -   Deletes the label associated with the oldest ID, ensuring that
        the chart displays only the most recent labels, with the
        quantity matching the value specified by `labelQtyInput`. Since
        our `arrayQueue()` function returns the shifted element, we can
        utilize its return value directly in the label deletion
        operation.
    -   Note that on early bars, the array will contain
        [na](https://www.tradingview.com/pine-script-reference/v5/#var_na)
        values until they are gradually replaced with labels. During
        this phase, the process will involve deleting ids that have
        [na](https://www.tradingview.com/pine-script-reference/v5/#var_na)
        values. This action does not cause runtime errors and is
        considered normal behavior.

It\'s important to note that while the above example demonstrates this
queuing system with labels, the same logic can be applied to manage
other kinds of objects. The `arrayQueue()` function can also be used in
[local scopes](/pine-script-docs/faq#what-does-scope-mean) to queue elements conditionally.

### Is it possible to draw geometric shapes? 

It is possible to create geometric shapes to illustrate patterns, mark
zones of interest, or create other visual aids for technical analysis.
In Pine Script™, two primary methods are used for drawing shapes:
[polylines](/pine-script-docs/concepts/lines-and-boxes#polylines)
and [lines](/pine-script-docs/concepts/lines-and-boxes#lines).
Each has its distinct use cases and benefits.

1.  **Drawing with Polylines**

    Polylines offer an efficient method for constructing complex shapes
    on a chart. To draw a shape with polylines, follow these steps:

    -   Start by creating an array composed of
        [chart.points](https://www.tradingview.com/pine-script-reference/v5/#type_chart.point),
        which define the vertices of your desired shape.
    -   Pass this array to the
        [polyline.new()](https://www.tradingview.com/pine-script-reference/v5/#fun_polyline.new)
        function. This function will sequentially draw lines between the
        points in the order they appear in the array, joining each point
        to the next.
    -   When defining the polyline, you have the option to choose
        between straight or curved lines, enabling the creation of a
        diverse range of shapes.

    This method is particularly useful for joining many points with a
    single object. A single polyline object is capable of joining up to
    10,000 points. It\'s important to note, though, that there is a
    [limitation](/pine-script-docs/concepts/lines-and-boxes#limitations) within any given script to include no more than 100
    polyline objects.

    ![image](@assets/images/Visuals-Is-it-possible-to-draw-geometric-shapes-1.png)

    ``` pine
    //@version=5
    indicator("Polylines example", overlay = true)

    //@variable If `true`, connects all points in the polyline with curved line segments.
    bool curvedInput = input.bool(false, "Curve Polyline")
    //@variable If `true`, connects the first point in the polyline to the last point.
    bool closedInput = input.bool(true,  "Close Polyline")
    //@variable The color of the space filled by the polyline.
    color fillcolor = input.color(color.new(color.blue, 90), "Fill Color")

    // Time and price inputs for the polyline's points.
    int    p1x = input.time( 0, "p1", confirm = true, inline = "p1")
    float  p1y = input.price(0, "  ", confirm = true, inline = "p1")
    int    p2x = input.time( 0, "p2", confirm = true, inline = "p2")
    float  p2y = input.price(0, "  ", confirm = true, inline = "p2")
    int    p3x = input.time( 0, "p3", confirm = true, inline = "p3")
    float  p3y = input.price(0, "  ", confirm = true, inline = "p3")
    int    p4x = input.time( 0, "p4", confirm = true, inline = "p4")
    float  p4y = input.price(0, "  ", confirm = true, inline = "p4")
    int    p5x = input.time( 0, "p5", confirm = true, inline = "p5")
    float  p5y = input.price(0, "  ", confirm = true, inline = "p5")

    if barstate.islastconfirmedhistory
        //@variable An array of `chart.point` objects for the new polyline.
        var array<chart.point> points = array.new<chart.point>()
        // Push new `chart.point` instances into the `points` array.
        points.push(chart.point.from_time(p1x, p1y))
        points.push(chart.point.from_time(p2x, p2y))
        points.push(chart.point.from_time(p3x, p3y))
        points.push(chart.point.from_time(p4x, p4y))
        points.push(chart.point.from_time(p5x, p5y))
        // Add labels for each `chart.point` in `points`.
        label l1p1 = label.new(points.get(0), "p1", xloc.bar_time, color = na)
        label l1p2 = label.new(points.get(1), "p2", xloc.bar_time, color = na)
        label l2p1 = label.new(points.get(2), "p3", xloc.bar_time, color = na)
        label l2p2 = label.new(points.get(3), "p4", xloc.bar_time, color = na)
        label l3p1 = label.new(points.get(4), "p5", xloc.bar_time, color = na)
        // Create a new polyline that connects each `chart.point` in the `points` array, starting from the first.
        polyline.new(points, curvedInput, closedInput, xloc.bar_time, fill_color = fillcolor)
    ```

    In this script we create five sets of *interactive points* by
    placing price and time inputs inline. When the script is added to
    the chart, the user is prompted with five mouse clicks to place
    points on the chart. The points are added to an array and passed to
    the `polyline.new()` function, which connects the points with lines,
    thereby constructing a shape.

2.  **Drawing with Lines**

    Lines, on the other hand, are more basic building blocks compared to
    polylines. A [line](/pine-script-docs/concepts/lines-and-boxes#lines) in Pine Script™ is a simple, straight connection between
    two points. Here\'s how to use lines for drawing shapes:

    -   Determine the start and end points for each line, recognizing
        that every edge of your shape must be delineated separately.
    -   For each side of the shape, input the precise starting and
        ending coordinates to create individual line segments.
    -   Sequentially link these line segments to form the perimeter of
        the shape, ensuring that the end of one line meets the start of
        the next to \"close\" the shape.

    Using separate lines provides greater individual control over the
    appearance of each segment. This technique is optimal for forming
    simple shapes with a minimal number of points. In Pine Script™, you
    can incorporate up to 500 individual lines in a single script.
    Additionally, while arrays can be employed to manage lines, they are
    not mandatory as they are with polylines, which may simplify the
    scripting process for some designs.

    ![image](@assets/images/Visuals-Is-it-possible-to-draw-geometric-shapes-2.png)

    ``` pine
    //@version=5
    indicator("Triangle", "", true)

    // Create interactive inputs using the `confirm` parameter.
    // To create an interactive point that can be selected with the cursor, we inline both price and time.
    string GRP1     = "Triangle A"
    int    x1AInput = input.time( 0, "Point 1", inline = "A1", group = GRP1, confirm = true)
    float  y1AInput = input.price(0, "",        inline = "A1", group = GRP1, confirm = true)
    int    x2AInput = input.time( 0, "Point 2", inline = "A2", group = GRP1, confirm = true)
    float  y2AInput = input.price(0, "",        inline = "A2", group = GRP1, confirm = true)
    int    x3AInput = input.time( 0, "Point 3", inline = "A3", group = GRP1, confirm = true)
    float  y3AInput = input.price(0, "",        inline = "A3", group = GRP1, confirm = true)

    string GRP2     = "Triangle B"
    int    x1BInput = input.time( 0, "Point 1", inline = "B1", group = GRP2, confirm = true)
    float  y1BInput = input.price(0, "",        inline = "B1", group = GRP2, confirm = true)
    int    x2BInput = input.time( 0, "Point 2", inline = "B2", group = GRP2, confirm = true)
    float  y2BInput = input.price(0, "",        inline = "B2", group = GRP2, confirm = true)
    int    x3BInput = input.time( 0, "Point 3", inline = "B3", group = GRP2, confirm = true)
    float  y3BInput = input.price(0, "",        inline = "B3", group = GRP2, confirm = true)


    // @function                Constructs a triangle on the chart using three vertices and a specified line color.
    // @param vx1               (int) The bar time of the first vertex.
    // @param vy1               (float) The price of the first vertex.
    // @param vx2               (int) The bar time of the second vertex.
    // @param vy2               (float) The price of the second vertex.
    // @param vx3               (int) The bar time of the third vertex.
    // @param vy3               (float) The price of the third vertex.
    // @param lineColor         (color) The color of the triangle's edges.
    // @param labelName         (string) The text to display in the label at the triangle's peak.
    // @returns                 (label) The label used to plot the text for the triangle.
    drawTriangle(int vx1, float vy1, int vx2, float vy2, int vx3, float vy3, color lineColor, string name) =>
        line.new(vx1, vy1, vx2, vy2, xloc = xloc.bar_time, color = lineColor)
        line.new(vx2, vy2, vx3, vy3, xloc = xloc.bar_time, color = lineColor)
        line.new(vx1, vy1, vx3, vy3, xloc = xloc.bar_time, color = lineColor)
        array<int>   xValues = array.from(vx1, vx2, vx3)
        array<float> yValues = array.from(vy1, vy2, vy3)
        float yMax = array.max(yValues)
        int   xMax = array.get(xValues, array.indexof(yValues, yMax))
        label.new(xMax, yMax, name, xloc = xloc.bar_time, color = color(na), textcolor = color.gray)


    // We draw the shapes only once for efficiency.
    // We pass the inputs as coordinates for the shapes and set the color and text.
    if barstate.isfirst
        drawTriangle(x1AInput, y1AInput, x2AInput, y2AInput, x3AInput, y3AInput, color.lime,    "A")
        drawTriangle(x1BInput, y1BInput, x2BInput, y2BInput, x3BInput, y3BInput, color.fuchsia, "B")
    ```

    In this script we create six sets of *interactive points* by placing
    price and time inputs inline. When the script is added to the chart,
    the user is prompted with six mouse clicks to place points on the
    chart. The price and time values of the point are passed to a
    function designed to link 3 points with lines to form a triangle.
    Once the user selects the points, two triangles are produced on the
    chart.

    Both methods have their merits: polylines for their elegance and
    ease of creating complex and dynamic shapes, and lines for their
    simplicity and precise control over each segment. The choice between
    using polylines or lines will depend on the specific requirements of
    the shape you intend to draw and the level of complexity you
    require. For further inspiration on shape construction, the
    Community Collection offers some innovative examples:

    -   [\[RS\]Function - Geometric Line
        Drawings](https://www.tradingview.com/script/KhKqjR0J-RS-Function-Geometric-Line-Drawings/)
        by RicardoSantos.
    -   [Zig-Zag Volume
        Profile](https://www.tradingview.com/script/L2LxYayS-Zig-Zag-Volume-Profile-Bull-vs-Bear-Kioseff-Trading/)
        by KioseffTrading
    -   [Circular Candlestick
        Chart](https://www.tradingview.com/script/3BjFD0A2-Circular-Candlestick-Chart/)
        by alexgrover.
    -   [Euler Cubes -
        Cubᵋ](https://www.tradingview.com/script/C839rurW-Euler-Cubes-Cub%E1%B5%8B/)
        by fikira.
    -   [RSI Radar Multi Time
        Frame](https://www.tradingview.com/script/8UtWhfo3-RSI-Radar-Multi-Time-Frame/)
        by LonesomeTheBlue
    -   [Penrose
        Diagram](https://www.tradingview.com/script/N8flt7gC-Penrose-Diagram/)
        by DayTradingOil.
    -   [Speedometer
        Toolbox](https://www.tradingview.com/script/1T498Yog-Speedometer-Toolbox/)
        by rumpypumpydumpy.
    -   [Analog/Digital World
        Clock](https://www.tradingview.com/script/QH7jc8Tx-Analog-Digital-World-Clock-by-DGT/)
        by dgtrd.

### How can I color the chart\'s background on a condition detected on the last bar? 

See this example in the Pine Script™ User Manual's [page on
tables](https://www.tradingview.com/pine-script-docs/en/v5/concepts/Tables.html#coloring-the-chart-s-background).


