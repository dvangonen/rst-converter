---
layout: '@layouts/Docs.astro'
sidebar-title: Maps
page-title: Language / Maps
labels: advanced
---


# Maps 


#### \`map.contains()\` 

To check if a specific `key` exists within a map `id`, use
[map.contains()](https://www.tradingview.com/pine-script-reference/v5/#fun_map.contains).
This function is a convenient alternative to calling
[array.includes()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.includes)
on the
[array](https://www.tradingview.com/pine-script-reference/v5/#type_array)
returned from
[map.keys()](https://www.tradingview.com/pine-script-reference/v5/#fun_map.keys).

For example, this script checks if various keys exist within an `m` map,
then displays the results in a
[label](https://www.tradingview.com/pine-script-reference/v5/#type_label):

![image](@assets/language/Maps-Reading-and-writing-Inspecting-keys-and-values-3.png)

``` pine
//@version=5
indicator("Inspecting keys demo")

//@variable A map containing `string` keys and `string` values.
m = map.new<string, string>()

// Put key-value pairs into the map.
m.put("A", "B")
m.put("C", "D")
m.put("E", "F")

//@variable An array of keys to check for in `m`.
array<string> testKeys = array.from("A", "B", "C", "D", "E", "F")

//@variable An array containing all elements from `testKeys` found in the keys of `m`.
array<string> mappedKeys = array.new<string>()

for key in testKeys
    // Add the `key` to `mappedKeys` if `m` contains it.
    if m.contains(key)
        mappedKeys.push(key)

//@variable A string representing the `testKeys` array and the elements found within the keys of `m`.
string testText = str.format("Tested keys: {0}\nKeys found: {1}", testKeys, mappedKeys)

if bar_index == last_bar_index - 1
    //@variable Displays the `testText` in a label at the `bar_index` before the last.
    label debugLabel = label.new(
         bar_index, 0, testText, style = label.style_label_center, 
         textcolor = color.white, size = size.huge
     )
```

### Removing key-value pairs 

To remove a specific key-value pair from a map `id`, use
[map.remove()](https://www.tradingview.com/pine-script-reference/v5/#fun_map.remove).
This function removes the `key` and its associated value from the map
while preserving the insertion order of other key-value pairs. It
returns the removed value if the map
`contained <PageMaps_ReadingAndWriting_InspectingKeysAndValues_MapContains>` the `key`. Otherwise, it returns
[na](https://www.tradingview.com/pine-script-reference/v5/#var_na).

To remove all key-value pairs from a map `id` at once, use
[map.clear()](https://www.tradingview.com/pine-script-reference/v5/#fun_map.clear).

The following script creates a new `m` map,
`puts <PageMaps_ReadingAndWriting_PuttingAndGettingKeyValuePairs>` key-value pairs into the map, uses
[m.remove()](https://www.tradingview.com/pine-script-reference/v5/#fun_map.remove)
within a loop to remove each valid `key` listed in the `removeKeys`
array, then calls
[m.clear()](https://www.tradingview.com/pine-script-reference/v5/#fun_map.clear)
to remove all remaining key-value pairs. It uses a custom `debugLabel()`
method to display the
[size](https://www.tradingview.com/pine-script-reference/v5/#fun_map.size),
[keys](https://www.tradingview.com/pine-script-reference/v5/#fun_map.keys),
and
[values](https://www.tradingview.com/pine-script-reference/v5/#fun_map.values)
of `m` after each change:

![image](@assets/language/Maps-Reading-and-writing-Removing-key-value-pairs-1.png)

``` pine
//@version=5
indicator("Removing key-value pairs demo")

//@function Returns a label to display the keys and values from a map.
method debugLabel(
     map<string, int> this, int barIndex = bar_index,
     color bgColor = color.blue, string note = ""
 ) =>
    //@variable A string representing the size, keys, and values in `this` map.
    string repr = str.format(
         "{0}\nSize: {1}\nKeys: {2}\nValues: {3}",
         note, this.size(), str.tostring(this.keys()), str.tostring(this.values())
     )
    label.new(
         barIndex, 0, repr, color = bgColor, style = label.style_label_center,
         textcolor = color.white, size = size.huge
     )

if bar_index == last_bar_index - 1
    //@variable A map containing `string` keys and `int` values.
    m = map.new<string, int>()

    // Put key-value pairs into `m`.
    for [i, key] in array.from("A", "B", "C", "D", "E")
        m.put(key, i)
    m.debugLabel(bar_index, color.green, "Added pairs")

    //@variable An array of keys to remove from `m`.
    array<string> removeKeys = array.from("B", "B", "D", "F", "a")

    // Remove each `key` in `removeKeys` from `m`.
    for key in removeKeys
        m.remove(key)
    m.debugLabel(bar_index + 10, color.red, "Removed pairs")

    // Remove all remaining keys from `m`.
    m.clear()
    m.debugLabel(bar_index + 20, color.purple, "Cleared the map")
```

Note that:

    -   Not all strings in the `removeKeys` array were present in the
        keys of `m`. Attempting to remove non-existent keys (\"F\",
        \"a\", and the second \"B\" in this example) has no effect on a
        map\'s contents.

### Combining maps 

Scripts can combine two maps via
[map.put_all()](https://www.tradingview.com/pine-script-reference/v5/#fun_map.put_all).
This function puts *all* key-value pairs from the `id2` map, in their
insertion order, into the `id1` map. As with
[map.put()](https://www.tradingview.com/pine-script-reference/v5/#fun_map.put),
if any keys in `id2` are also present in `id1`, this function
**replaces** the key-value pairs that contain those keys without
affecting their initial insertion order.

This example contains a user-defined `hexMap()` function that maps
decimal
[int](https://www.tradingview.com/pine-script-reference/v5/#type_int)
keys to
[string](https://www.tradingview.com/pine-script-reference/v5/#type_string)
representations of their
[hexadecimal](https://en.wikipedia.org//wiki/Hexadecimal) forms. The
script uses this function to create two maps, `mapA` and `mapB`, then
uses
[mapA.put_all(mapB)](https://www.tradingview.com/pine-script-reference/v5/#fun_map.put_all)
to put all key-value pairs from `mapB` into `mapA`.

The script uses a custom `debugLabel()` function to display labels
showing the
[keys](https://www.tradingview.com/pine-script-reference/v5/#fun_map.keys)
and
[values](https://www.tradingview.com/pine-script-reference/v5/#fun_map.values)
of `mapA` and `mapB`, then another label displaying the contents of
`mapA` after putting all key-value pairs from `mapB` into it:

![image](@assets/language/Maps-Reading-and-writing-Combining-maps-1.png)

``` pine
//@version=5
indicator("Combining maps demo", "Hex map")

//@variable An array of string hex digits.
var array<string> hexDigits = str.split("0123456789ABCDEF", "")

//@function Returns a hexadecimal string for the specified `value`.
hex(int value) =>
    //@variable A string representing the hex form of the `value`.
    string result = ""
    //@variable A temporary value for digit calculation.
    int tempValue = value  
    while tempValue > 0
        //@variable The next integer digit.
        int digit = tempValue % 16
        // Add the hex form of the `digit` to the `result`.
        result := hexDigits.get(digit) + result
        // Divide the `tempValue` by the base.
        tempValue := int(tempValue / 16)
    result

//@function Returns a map holding the `numbers` as keys and their `hex` strings as values.  
hexMap(array<int> numbers) =>
    //@variable A map associating `int` keys with `string` values.
    result = map.new<int, string>()
    for number in numbers
        // Put a pair containing the `number` and its `hex()` representation into the `result`.
        result.put(number, hex(number))
    result

//@function Returns a label to display the keys and values of a hex map.
debugLabel(
     map<int, string> this, int barIndex = bar_index, color bgColor = color.blue, 
     string style = label.style_label_center, string note = ""
 ) =>
    string repr = str.format(
         "{0}\nDecimal: {1}\nHex: {2}", 
         note, str.tostring(this.keys()), str.tostring(this.values())
     )
    label.new(
         barIndex, 0, repr, color = bgColor, style = style,
         textcolor = color.white, size = size.huge
     )

if bar_index == last_bar_index - 1
    //@variable A map with decimal `int` keys and hexadecimal `string` values.
    map<int, string> mapA = hexMap(array.from(101, 202, 303, 404))
    debugLabel(mapA, bar_index, color.navy, label.style_label_down, "A")

    //@variable A map containing key-value pairs to add to `mapA`.
    map<int, string> mapB = hexMap(array.from(303, 404, 505, 606, 707, 808))
    debugLabel(mapB, bar_index, color.maroon, label.style_label_up, "B")

    // Put all pairs from `mapB` into `mapA`.
    mapA.put_all(mapB)
    debugLabel(mapA, bar_index + 10, color.purple, note = "Merge B into A")
```

## Looping through a map 

There are several ways scripts can iteratively access the keys and
values in a map. For example, one could loop through a map\'s
[keys()](https://www.tradingview.com/pine-script-reference/v5/#fun_map.keys)
array and
[get()](https://www.tradingview.com/pine-script-reference/v5/#fun_map.get)
the value for each `key`, like so:

``` pine
for key in thisMap.keys()
    value = thisMap.get(key)
```

However, we recommend using a `for...in` loop directly on a map, as it
iterates over the map\'s key-value pairs in their insertion order,
returning a tuple containing the next pair\'s key and value on each
iteration.

For example, this line of code loops through each `key` and `value` in
`thisMap`, starting from the first key-value pair put into it:

``` pine
for [key, value] in thisMap
```

Let\'s use this structure to write a script that displays a map\'s
key-value pairs in a
[table](https://www.tradingview.com/pine-script-reference/v5/#type_table).
In the example below, we\'ve defined a custom `toTable()` method that
creates a
[table](https://www.tradingview.com/pine-script-reference/v5/#type_table),
then uses a `for...in` loop to iterate over the map\'s key-value pairs
and populate the table\'s cells. The script uses this method to
visualize a map containing `length`-bar `averages` of price and volume
data:

![image](@assets/language/Maps-Looping-through-a-map-1.png)

``` pine
//@version=5
indicator("Looping through a map demo", "Table of averages")

//@variable The length of the moving average.
int length = input.int(20, "Length")
//@variable The size of the table text.
string txtSize = input.string(
     size.huge, "Text size",
     options = [size.auto, size.tiny, size.small, size.normal, size.large, size.huge]
 )

//@function Displays the pairs of `this` map within a table.
//@param    this A map with `string` keys and `float` values.
//@param    position The position of the table on the chart.
//@param    header The string to display on the top row of the table.
//@param    textSize The size of the text in the table.
//@returns  A new `table` object with cells displaying each pair in `this`.
method toTable(
     map<string, float> this, string position = position.middle_center, string header = na,
     string textSize = size.huge
 ) =>
    // Color variables
    borderColor = #000000
    headerColor = color.rgb(1, 88, 80)
    pairColor   = color.maroon
    textColor   = color.white

    //@variable A table that displays the key-value pairs of `this` map.
    table result = table.new(
         position, this.size() + 1, 3, border_width = 2, border_color = borderColor
     )
    // Initialize top and side header cells.
    result.cell(1, 0, header, bgcolor = headerColor, text_color = textColor, text_size = textSize)
    result.merge_cells(1, 0, this.size(), 0)
    result.cell(0, 1, "Key", bgcolor = headerColor, text_color = textColor, text_size = textSize)
    result.cell(0, 2, "Value", bgcolor = headerColor, text_color = textColor, text_size = textSize)

    //@variable The column index of the table. Updates on each loop iteration.
    int col = 1

    // Loop over each `key` and `value` from `this` map in the insertion order.
    for [key, value] in this
        // Initialize a `key` cell in the `result` table on row 1.
        result.cell(
             col, 1, str.tostring(key), bgcolor = color.maroon,
             text_color = color.white, text_size = textSize
         )
        // Initialize a `value` cell in the `result` table on row 2.
        result.cell(
             col, 2, str.tostring(value), bgcolor = color.maroon,
             text_color = color.white, text_size = textSize
         )
        // Move to the next column index.
        col += 1
    result // Return the `result` table.

//@variable A map with `string` keys and `float` values to hold `length`-bar averages.
averages = map.new<string, float>()

// Put key-value pairs into the `averages` map.
averages.put("Open", ta.sma(open, length))
averages.put("High", ta.sma(high, length))
averages.put("Low", ta.sma(low, length))
averages.put("Close", ta.sma(close, length))
averages.put("Volume", ta.sma(volume, length))

//@variable The text to display at the top of the table.
string headerText = str.format("{0} {1}-bar averages", "'" + syminfo.tickerid + "'", length)
// Display the `averages` map in a `table` with the `headerText`.
averages.toTable(header = headerText, textSize = txtSize)
```

## Copying a map 

### Shallow copies 

Scripts can make a *shallow copy* of a map `id` using the
[map.copy()](https://www.tradingview.com/pine-script-reference/v5/#fun_map.copy)
function. Modifications to a shallow copy do not affect the original
`id` map or its internal insertion order.

For example, this script constructs an `m` map with the keys \"A\",
\"B\", \"C\", and \"D\" assigned to four
[random](https://www.tradingview.com/pine-script-reference/v5/#fun_math.random)
values between 0 and 10. It then creates an `mCopy` map as a shallow
copy of `m` and updates the values associated with its keys. The script
displays the key-value pairs in `m` and `mCopy` on the chart using our
custom `debugLabel()` method:

![image](@assets/language/Maps-Copying-a-map-Shallow-copies-1.png)

``` pine
//@version=5
indicator("Shallow copy demo")

//@function Displays the key-value pairs of `this` map in a label. 
method debugLabel(
     map<string, float> this, int barIndex = bar_index, color bgColor = color.blue,
     color textColor = color.white, string note = ""
 ) =>
    //@variable The text to display in the label.
    labelText = note + "\n{"
    for [key, value] in this
        labelText += str.format("{0}: {1}, ", key, value)
    labelText := str.replace(labelText, ", ", "}", this.size() - 1)

    if barstate.ishistory
        label result = label.new(
             barIndex, 0, labelText, color = bgColor, style = label.style_label_center, 
             textcolor = textColor, size = size.huge
         )

if bar_index == last_bar_index - 1
    //@variable A map of `string` keys and random `float` values.
    m = map.new<string, float>()

    // Assign random values to an array of keys in `m`.
    for key in array.from("A", "B", "C", "D")
        m.put(key, math.random(0, 10))

    //@variable A shallow copy of `m`.
    mCopy = m.copy()

    // Assign the insertion order value `i` to each `key` in `mCopy`.
    for [i, key] in mCopy.keys()
        mCopy.put(key, i)

    // Display the labels.
    m.debugLabel(bar_index, note = "Original")
    mCopy.debugLabel(bar_index + 10, color.purple, note = "Copied and changed")
```

### Deep copies 

While a
`shallow copy <PageMaps_CopyingAMap_ShallowCopies>` will suffice when copying maps that have values of a
*fundamental type*, it\'s important to remember that shallow copies of a
map holding values of a *reference type*
([line](https://www.tradingview.com/pine-script-reference/v5/#type_line),
[linefill](https://www.tradingview.com/pine-script-reference/v5/#type_linefill),
[box](https://www.tradingview.com/pine-script-reference/v5/#type_box),
[polyline](https://www.tradingview.com/pine-script-reference/v5/#type_polyline),
[label](https://www.tradingview.com/pine-script-reference/v5/#type_label),
[table](https://www.tradingview.com/pine-script-reference/v5/#type_table),
[chart.point](https://www.tradingview.com/pine-script-reference/v5/#type_chart.point)
or a `UDT <PageTypeSystem_UserDefinedTypes>`) point to the same objects as the original. Modifying the
objects referenced by a shallow copy will affect the instances
referenced by the original map and vice versa.

To ensure changes to objects referenced by a copied map do not affect
instances referenced in other locations, one can make a *deep copy* by
creating a new map with key-value pairs containing copies of each value
in the original map.

This example creates an `original` map of
[string](https://www.tradingview.com/pine-script-reference/v5/#type_string)
keys and
[label](https://www.tradingview.com/pine-script-reference/v5/#type_label)
values and
[puts](https://www.tradingview.com/pine-script-reference/v5/#fun_map.put)
a key-value pair into it. The script copies the map to a `shallow`
variable via the built-in
[copy()](https://www.tradingview.com/pine-script-reference/v5/#fun_map.copy)
method, then to a `deep` variable using a custom `deepCopy()` method.

As we see from the chart, changes to the label retrieved from the
`shallow` copy also affect the instance referenced by the `original`
map, but changes to the one from the `deep` copy do not:

![image](@assets/language/Maps-Copying-a-map-Deep-copies-1.png)

``` pine
//@version=5
indicator("Deep copy demo")

//@function Returns a deep copy of `this` map.
method deepCopy(map<string, label> this) =>
    //@variable A deep copy of `this` map.
    result = map.new<string, label>()
    // Add key-value pairs with copies of each `value` to the `result`.
    for [key, value] in this
        result.put(key, value.copy())
    result //Return the `result`.

//@variable A map containing `string` keys and `label` values.
var original = map.new<string, label>()

if bar_index == last_bar_index - 1
    // Put a new key-value pair into the `original` map.
    map.put(
         original, "Test",
         label.new(bar_index, 0, "Original", textcolor = color.white, size = size.huge)
     )

    //@variable A shallow copy of the `original` map.
    map<string, label> shallow = original.copy()
    //@variable A deep copy of the `original` map.
    map<string, label> deep = original.deepCopy()

    //@variable The "Test" label from the `shallow` copy.
    label shallowLabel = shallow.get("Test")
    //@variable The "Test" label from the `deep` copy.
    label deepLabel = deep.get("Test")

    // Modify the "Test" label's `y` attribute in the `original` map.
    // This also affects the `shallowLabel`.
    original.get("Test").set_y(label.all.size())

    // Modify the `shallowLabel`. Also modifies the "Test" label in the `original` map.
    shallowLabel.set_text("Shallow copy")
    shallowLabel.set_color(color.red)
    shallowLabel.set_style(label.style_label_up)

    // Modify the `deepLabel`. Does not modify any other label instance.
    deepLabel.set_text("Deep copy")
    deepLabel.set_color(color.navy)
    deepLabel.set_style(label.style_label_left)
    deepLabel.set_x(bar_index + 5)
```

Note that:

    -   The `deepCopy()` method loops through the `original` map,
        copying each `value` and
        `putting <PageMaps_ReadingAndWriting_PuttingAndGettingKeyValuePairs>` key-value pairs containing the copies into a
        [new](https://www.tradingview.com/pine-script-reference/v5/#fun_map.new%3Ctype,type%3E)
        map instance.

## Scope and history 

As with other collections in Pine, map variables leave historical trails
on each bar, allowing a script to access past map instances assigned to
a variable using the history-referencing operator
[\[\]](https://www.tradingview.com/pine-script-reference/v5/#op_%5B%5D).
Scripts can also assign maps to global variables and interact with them
from the scopes of
`functions <PageUserDefinedFunctions>`,
`methods <PageMethods>`, and
`conditional structures <PageConditionalStructures>`.

As an example, this script uses a global map and its history to
calculate an aggregate set of
[EMAs](https://www.tradingview.com/support/solutions/43000592270/). It
declares a `globalData` map of
[int](https://www.tradingview.com/pine-script-reference/v5/#type_int)
keys and
[float](https://www.tradingview.com/pine-script-reference/v5/#type_float)
values, where each key in the map corresponds to the length of each EMA
calculation. The user-defined `update()` function calculates each
`key`-length EMA by mixing the values from the `previous` map assigned
to `globalData` with the current `source` value.

The script plots the
[maximum](https://www.tradingview.com/pine-script-reference/v5/#fun_array.max)
and
[minimum](https://www.tradingview.com/pine-script-reference/v5/#fun_array.min)
values in the global map\'s
[values()](https://www.tradingview.com/pine-script-reference/v5/#fun_map.values)
array and the value from `globalData.get(50)` (i.e., the 50-bar EMA):

![image](@assets/language/Maps-Scope-and-history-1.png)

``` pine
//@version=5
indicator("Scope and history demo", overlay = true)

//@variable The source value for EMA calculation.
float source = input.source(close, "Source")

//@variable A map containing global key-value pairs.
globalData = map.new<int, float>()

//@function Calculates a set of EMAs and updates the key-value pairs in `globalData`.
update() =>
    //@variable The previous map instance assigned to `globalData`.
    map<int, float> previous = globalData[1]

    // Put key-value pairs with keys 10-200 into `globalData` if `previous` is `na`.
    if na(previous)
        for i = 10 to 200
            globalData.put(i, source)
    else
        // Iterate each `key` and `value` in the `previous` map.
        for [key, value] in previous
            //@variable The smoothing parameter for the `key`-length EMA.
            float alpha = 2.0 / (key + 1.0)
            //@variable The `key`-length EMA value.
            float ema = (1.0 - alpha) * value + alpha * source
            // Put the `key`-length `ema` into the `globalData` map.
            globalData.put(key, ema)

// Update the `globalData` map.
update()

//@variable The array of values from `globalData` in their insertion order.
array<float> values = globalData.values()

// Plot the max EMA, min EMA, and 50-bar EMA values.
plot(values.max(), "Max EMA", color.green, 2)
plot(values.min(), "Min EMA", color.red, 2)
plot(globalData.get(50), "50-bar EMA", color.orange, 3)
```

## Maps of other collections 

Maps cannot directly use other maps,
`arrays <PageArrays>`, or
`matrices <PageMatrices>` as values, but
they can hold values of a
`user-defined type <PageTypeSystem_UserDefinedTypes>` that contains collections within its fields.

For example, suppose we want to create a \"2D\" map that uses
[string](https://www.tradingview.com/pine-script-reference/v5/#type_string)
keys to access *nested maps* that hold pairs of
[string](https://www.tradingview.com/pine-script-reference/v5/#type_string)
keys and
[float](https://www.tradingview.com/pine-script-reference/v5/#type_float)
values. Since maps cannot use other collections as values, we will first
create a *wrapper type* with a field to hold a `map<string, float>`
instance, like so:

``` pine
//@type A wrapper type for maps with `string` keys and `float` values.
type Wrapper
    map<string, float> data
```

With our `Wrapper` type defined, we can create maps of
[string](https://www.tradingview.com/pine-script-reference/v5/#type_string)
keys and `Wrapper` values, where the `data` field of each value in the
map points to a `map<string, float>` instance:

``` pine
mapOfMaps = map.new<string, Wrapper>()
```

The script below uses this concept to construct a map containing maps
that hold OHLCV data requested from multiple tickers. The user-defined
`requestData()` function requests price and volume data from a ticker,
creates a `<string, float>` map,
[puts](https://www.tradingview.com/pine-script-reference/v5/#fun_map.put)
the data into it, then returns a `Wrapper` instance containing the new
map.

The script
[puts](https://www.tradingview.com/pine-script-reference/v5/#fun_map.put)
the results from each call to `requestData()` into the `mapOfMaps`, then
creates a
[string](https://www.tradingview.com/pine-script-reference/v5/#type_string)
representation of the nested maps with a user-defined `toString()`
method, which it displays on the chart in a
[label](https://www.tradingview.com/pine-script-reference/v5/#type_label):

![image](@assets/language/Maps-Maps-of-other-collections-1.png)

``` pine
//@version=5
indicator("Nested map demo")

//@variable The timeframe of the requested data.
string tf = input.timeframe("D", "Timeframe")
// Symbol inputs.
string symbol1 = input.symbol("EURUSD", "Symbol 1")
string symbol2 = input.symbol("GBPUSD", "Symbol 2")
string symbol3 = input.symbol("EURGBP", "Symbol 3")

//@type A wrapper type for maps with `string` keys and `float` values.
type Wrapper
    map<string, float> data

//@function Returns a wrapped map containing OHLCV data from the `tickerID` at the `timeframe`.
requestData(string tickerID, string timeframe) =>
    // Request a tuple of OHLCV values from the specified ticker and timeframe.
    [o, h, l, c, v] = request.security(
         tickerID, timeframe,
         [open, high, low, close, volume]
     )
    //@variable A map containing requested OHLCV data.
    result = map.new<string, float>()
    // Put key-value pairs into the `result`.
    result.put("Open", o)
    result.put("High", h)
    result.put("Low", l)
    result.put("Close", c)
    result.put("Volume", v)
    //Return the wrapped `result`.
    Wrapper.new(result)

//@function Returns a string representing `this` map of `string` keys and `Wrapper` values.
method toString(map<string, Wrapper> this) =>
    //@variable A string representation of `this` map.
    string result = "{"

    // Iterate over each `key1` and associated `wrapper` in `this`.
    for [key1, wrapper] in this
        // Add `key1` to the `result`.
        result += key1

        //@variable A string representation of the `wrapper.data` map.
        string innerStr = ": {"
        // Iterate over each `key2` and associated `value` in the wrapped map.
        for [key2, value] in wrapper.data
            // Add the key-value pair's representation to `innerStr`.
            innerStr += str.format("{0}: {1}, ", key2, str.tostring(value))

        // Replace the end of `innerStr` with "}" and add to `result`.
        result += str.replace(innerStr, ", ", "},\n", wrapper.data.size() - 1)

    // Replace the blank line at the end of `result` with "}".
    result := str.replace(result, ",\n", "}", this.size() - 1)
    result

//@variable A map of wrapped maps containing OHLCV data from multiple tickers.
var mapOfMaps = map.new<string, Wrapper>()

//@variable A label showing the contents of the `mapOfMaps`.
var debugLabel = label.new(
     bar_index, 0, color = color.navy, textcolor = color.white, size = size.huge,
     style = label.style_label_center, text_font_family = font.family_monospace
 )

// Put wrapped maps into `mapOfMaps`.
mapOfMaps.put(symbol1, requestData(symbol1, tf))
mapOfMaps.put(symbol2, requestData(symbol2, tf))
mapOfMaps.put(symbol3, requestData(symbol3, tf))

// Update the label.
debugLabel.set_text(mapOfMaps.toString())
debugLabel.set_x(bar_index)
```


