---
layout: '@layouts/Docs.astro'
sidebar-title: Debugging
page-title: Writing / Debugging
---

# Debugging 


### Creating logs 

Scripts can create logs by calling the functions in the `log.*()`
namespace.

All `log.*()` functions have the following signatures:

``` text
log.*(message) → void

log.*(formatString, arg0, arg1, ...) → void
```

The first overload logs a specified `message` in the Pine Logs pane. The
second overload is similar to
[str.format()](https://www.tradingview.com/pine-script-reference/v5/#fun_str.format),
as it logs a formatted message based on the `formatString` and the
additional arguments supplied in the call.

Each `log.*()` function has a different *debug level*, allowing
programmers to categorize and
`filter <PageDebugging_PineLogs_FilteringLogs>` results shown in the pane:

-   The
    [log.info()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.info)
    function logs an entry with the *\"info\"* level that appears in the
    pane with gray text.
-   The
    [log.warning()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.warning)
    function logs an entry with the *\"warning\"* level that appears in
    the pane with orange text.
-   The
    [log.error()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.error)
    function logs an entry with the *\"error\"* level that appears in
    the pane with red text.

This code demonstrates the difference between all three `log.*()`
functions. It calls
[log.info()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.info),
[log.warning()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.warning),
and
[log.error()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.error)
on the first available bar:

![image](@assets/writing/Debugging-Pine-logs-Creating-logs-1.png)

``` pine
//@version=5
indicator("Debug levels demo", overlay = true)

if barstate.isfirst
    log.info("This is an 'info' message.")
    log.warning("This is a 'warning' message.")
    log.error("This is an 'error' message.")
```

Pine Logs can execute anywhere within a script\'s execution. They allow
programmers to track information from historical bars and monitor how
their scripts behave on realtime, *unconfirmed* bars. When executing on
historical bars, scripts generate a new message once for each `log.*()`
call on a bar. On realtime bars, calls to `log.*()` functions can create
new entries on *each new tick*.

For example, this script calculates the average ratio between each
bar\'s `close - open` value to its `high - low` range. When the
`denominator` is nonzero, the script calls
[log.info()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.info)
to print the values of the calculation\'s variables on confirmed bars
and
[log.warning()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.warning)
to print the values on unconfirmed bars. Otherwise, it uses
[log.error()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.error)
to indicate that division by zero occurred, as such cases can affect the
`average` result:

![image](@assets/writing/Debugging-Pine-logs-Creating-logs-2.png)

``` pine
//@version=5
indicator("Logging historical and realtime data demo", "Average bar ratio")

//@variable The current bar's change from the `open` to `close`.
float numerator = close - open
//@variable The current bar's `low` to `high` range.
float denominator = high - low
//@variable The ratio of the bar's open-to-close range to its full range.
float ratio = numerator / denominator
//@variable The average `ratio` over 10 non-na values.
float average = ta.sma(ratio, 10)

// Plot the `average`.
plot(average, "average", color.purple, 3)

if barstate.isconfirmed
    // Log a division by zero error if the `denominator` is 0.
    if denominator == 0.0
        log.error("Division by 0 in confirmed results!")
    // Otherwise, log the confirmed values.
    else
        log.info(
             "Values (confirmed):\nnumerator: {1, number, #.########}\ndenominator: {2, number, #.########}
             \nratio: {0, number, #.########}\naverage: {3, number, #.########}",
             ratio, numerator, denominator, average
         )
else
    // Log a division by zero error if the `denominator` is 0.
    if denominator == 0.0
        log.error("Division by 0 on unconfirmed bar.")
    // Otherwise, log the unconfirmed values.
    else
        log.warning(
             "Values (unconfirmed):\nnumerator: {1, number, #.########}\ndenominator: {2, number, #.########}
             \nratio: {0, number, #.########}\naverage: {3, number, #.########}",
             ratio, numerator, denominator, average
         )
```

Note that:

    -   Pine Logs *do not roll back* on each tick in an unconfirmed bar,
        meaning the results for those ticks show in the pane until the
        script restarts its execution. To only log messages on
        *confirmed* bars, use
        [barstate.isconfirmed](https://www.tradingview.com/pine-script-reference/v5/#var_barstate.isconfirmed)
        in the conditions that trigger a `log.*()` call.
    -   When logging on unconfirmed bars, we recommend ensuring those
        logs contain *unique information* or use different *debug
        levels* so you can
        `filter <PageDebugging_PineLogs_FilteringLogs>` the results as needed.
    -   The Pine Logs pane will show up to the most recent 10,000
        entries for historical bars. If a script generates more than
        10,000 logs on historical bars and a programmer needs to view
        earlier entries, they can use conditional logic to limit
        `log.*()` calls to specific occurrences. See
        `this <PageDebugging_PineLogs_FilteringLogs_UsingInputs>` section for an example that limits log generation to
        a user-specified time range.

### Inspecting logs 

Pine Logs include some helpful features that simplify the inspection
process. Whenever a script generates a log, it automatically prefixes
the message with a granular timestamp to signify where the log event
occurred in the time series. Additionally, each entry contains
**\"Source code\"** and **\"Scroll to bar\"** icons, which appear when
hovering over it in the Pine Logs pane:

![image](@assets/writing/Debugging-Pine-logs-Inspecting-logs-1.png)

Clicking an entry\'s \"Source code\" icon opens the script in the Pine
Editor and highlights the specific line of code that triggered the log:

![image](@assets/writing/Debugging-Pine-logs-Inspecting-logs-2.png)

Clicking an entry\'s \"Scroll to bar\" icon navigates the chart to the
specific bar where the log occurred, then temporarily displays a tooltip
containing time information for that bar:

![image](@assets/writing/Debugging-Pine-logs-Inspecting-logs-3.png)

Note that:

    -   The time information in the tooltip depends on the chart\'s
        timeframe, just like the x-axis label linked to the chart\'s
        cursor and drawing tools. For example, the tooltip on an EOD
        chart will only show the weekday and the date, whereas the
        tooltip on a 10-second chart will also contain the time of day,
        including seconds.

When a chart includes more than one script that generates logs, it\'s
important to note that each script maintains its own *independent*
message history. To inspect the messages from a specific script when
multiple are on the chart, select its title from the dropdown at the top
of the Pine Logs pane:

![image](@assets/writing/Debugging-Pine-logs-Inspecting-logs-4.png)

### Filtering logs 

A single script can generate numerous logs, depending on the conditions
that trigger its `log.*()` calls. While directly scrolling through the
log history to find specific entries may suffice when a script only
generates a few, it can become unwieldy when searching through hundreds
or thousands of messages.

The Pine Logs pane includes multiple options for filtering messages,
which allows one to simplify their results by isolating specific
*character sequences*, *start times*, and *debug levels*.

Clicking the \"Search\" icon at the top of the pane opens a search bar,
which matches text to filter logged messages. The search filter also
highlights the matched portion of each message in blue for visual
reference. For example, here, we entered \"confirmed\" to match all
results generated by our previous script with the word somewhere in
their text:

![image](@assets/writing/Debugging-Pine-logs-Filtering-logs-1.png)

Notice that the results from this search also considered messages with
*\"unconfirmed\"* as matches since the word contains our query. We can
omit these matches by selecting the \"Whole Word\" checkbox in the
options at the right of the search bar:

![image](@assets/writing/Debugging-Pine-logs-Filtering-logs-2.png)

This filter also supports [regular expressions
(regex)](https://en.wikipedia.org/wiki/Regular_expression), which allow
users to perform advanced searches that match custom *character
patterns* when selecting the \"Regex\" checkbox in the search options.
For example, this regex matches all entries that contain \"average\"
followed by a sequence representing a number greater than 0.5 and less
than or equal to 1:

`average:\s*(0\.[6-9]\d*|0\.5\d*[1-9]\d*|1\.0*)`

![image](@assets/writing/Debugging-Pine-logs-Filtering-logs-3.png)

Clicking the \"Start date\" icon opens a dialog that allows users to
specify the date and time of the first log shown in the results:

![image](@assets/writing/Debugging-Pine-logs-Filtering-logs-4.png)

After specifying the starting point, a tag containing the starting time
will appear above the log history:

![image](@assets/writing/Debugging-Pine-logs-Filtering-logs-5.png)

Users can filter results by *debug level* using the checkboxes available
when selecting the rightmost icon in the filtering options. Here, we\'ve
deactivated the \"info\" and \"warning\" levels so the results will only
contain \"error\" messages:

![image](@assets/writing/Debugging-Pine-logs-Filtering-logs-6.png)

#### Using inputs 

Another, more involved way to interactively filter a script\'s logged
results is to create `inputs <PageInputs>`
linked to conditional logic that activates specific `log.*()` calls in
the code.

Let\'s look at an example. This code calculates an
[RMA](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.rma)
of
[close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
prices and declares a few unique conditions to form a
`compound condition <PageDebugging_Conditions_CompoundAndNestedConditions>`. The script uses
[log.info()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.info)
to display important debugging information in the Pine Logs pane,
including the values of the `compoundCondition` variable and the
\"bool\" variables that determine its result.

We declared the `filterLogsInput`, `logStartInput`, and `logEndInput`
variables respectively assigned to an
[input.bool()](https://www.tradingview.com/pine-script-reference/v5/#fun_input.bool)
and two
[input.time()](https://www.tradingview.com/pine-script-reference/v5/#fun_input.time)
calls for custom log filtering. When `filterLogsInput` is `true`, the
script will only generate a new log if the bar\'s
[time](https://www.tradingview.com/pine-script-reference/v5/#var_time)
is between the `logStartInput` and `logEndInput` values, allowing us to
interactively isolate the entries that occurred within a specific time
range:

![image](@assets/writing/Debugging-Pine-logs-Filtering-logs-Using-inputs-1.png)

``` pine
//@version=5
indicator("Filtering logs using inputs demo", "Compound condition in input range", true)

//@variable The length for moving average calculations.
int lengthInput = input.int(20, "Length", 2)

//@variable If `true`, only allows logs within the input time range.
bool filterLogsInput = input.bool(true, "Only log in time range", group = "Log filter")
//@variable The starting time for logs if `filterLogsInput` is `true`.
int logStartInput = input.time(0, "Start time", group = "Log filter", confirm = true)
//@variable The ending time for logs if `filterLogsInput` is `true`.
int logEndInput = input.time(0, "End time", group = "Log filter", confirm = true)

//@variable The RMA of `close` prices.
float rma = ta.rma(close, lengthInput)

//@variable Is `true` when `close` exceeds the `rma`.
bool priceBelow = close <= rma
//@variable Is `true` when the current `close` is greater than the max of the previous `hl2` and `close`.
bool priceRising = close > math.max(hl2[1], close[1])
//@variable Is `true` when the `rma` is positively accelerating.
bool rmaAccelerating = rma - 2.0 * rma[1] + rma[2] > 0.0
//@variable Is `true` when the difference between `rma` and `close` exceeds 2 times the current ATR.
bool closeAtThreshold = rma - close > ta.atr(lengthInput) * 2.0
//@variable Is `true` when all the above conditions occur.
bool compoundCondition = priceBelow and priceRising and rmaAccelerating and closeAtThreshold

// Plot the `rma`.
plot(rma, "RMA", color.teal, 3)
// Highlight the chart background when the `compoundCondition` occurs.
bgcolor(compoundCondition ? color.new(color.aqua, 80) : na, title = "Compound condition highlight")

//@variable If `filterLogsInput` is `true`, is only `true` in the input time range. Otherwise, always `true`.
bool showLog = filterLogsInput ? time >= logStartInput and time <= logEndInput : true

// Log results for a confirmed bar when `showLog` is `true`.
if barstate.isconfirmed and showLog
    log.info(
         "\nclose: {0, number, #.#####}\nrma: {1, number, #.#####}\npriceBelow: {2}\npriceRising: {3}
         \nrmaAccelerating: {4}\ncloseAtThreshold: {5}\n\ncompoundCondition: {6}",
         close, rma, priceBelow, priceRising, rmaAccelerating, closeAtThreshold, compoundCondition
     )
```

Note that:

    -   The `input.*()` functions assigned to the `filterLogsInput`,
        `logStartInput`, and `logEndInput` variables include a `group`
        argument to oragnize and distinguish them in the script\'s
        settings.
    -   The
        [input.time()](https://www.tradingview.com/pine-script-reference/v5/#fun_input.time)
        calls include `confirm = true` so that we can interactively set
        the start and end times directly on the chart. To reset the
        inputs, select \"Reset points\...\" from the options in the
        script\'s \"More\" menu.
    -   The condition that triggers each
        [log.info()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.info)
        call includes
        [barstate.isconfirmed](https://www.tradingview.com/pine-script-reference/v5/#var_barstate.isconfirmed)
        to limit log generation to *confirmed* bars.

## Debugging functions 

`User-defined functions <PageUserDefinedFunctions>` and
`methods <PageMethods_UserDefinedMethods>`
are custom functions written by users. They encapsulate sequences of
operations that a script can invoke later in its execution.

Every
`user-defined function <PageUserDefinedFunctions>` or
`method <PageMethods_UserDefinedMethods>`
has a *local scope* that embeds into the script\'s global scope. The
parameters in a function\'s signature and the variables declared within
the function body belong to that function\'s local scope, and they are
*not* directly accessible to a script\'s outer scope or the scopes of
other functions.

The segments below explain a few ways programmers can debug the values
from a function\'s local scope. We will use this script as the starting
point for our subsequent examples. It contains a `customMA()` function
that returns an exponential moving average whose smoothing parameter
varies based on the `source` distance outside the 25th and 75th
[percentiles](https://www.tradingview.com/pine-script-reference/v5/#fun_ta.percentile_linear_interpolation)
over `length` bars:

![image](@assets/writing/Debugging-Debugging-functions-1.png)

``` pine
//@version=5
indicator("Debugging functions demo", "Custom MA", true)

//@variable The number of bars in the `customMA()` calculation.
int lengthInput = input.int(50, "Length", 2)

//@function      Calculates a moving average that only responds to values outside the first and third quartiles.
//@param source  The series of values to process.
//@param length  The number of bars in the calculation.
//@returns       The moving average value.
customMA(float source, int length) =>
    //@variable The custom moving average.
    var float result = na
    // Calculate the 25th and 75th `source` percentiles.
    float q1 = ta.percentile_linear_interpolation(source, length, 25)
    float q3 = ta.percentile_linear_interpolation(source, length, 75)
    // Calculate the range values.
    float outerRange = math.max(source - q3, q1 - source, 0.0)
    float totalRange = ta.range(source, length)
    //@variable Half the ratio of the `outerRange` to the `totalRange`.
    float alpha = 0.5 * outerRange / totalRange
    // Mix the `source` with the `result` based on the `alpha` value.
    result := (1.0 - alpha) * nz(result, source) + alpha * source
    // Return the `result`.
    result

//@variable The `customMA()` result over `lengthInput` bars.
float maValue = customMA(close, lengthInput)

// Plot the `maValue`.
plot(maValue, "Custom MA", color.blue, 3)
```

### Extracting local variables 

When a programmer wants to inspect a
`user-defined function's <PageUserDefinedFunctions>` local variables by
`plotting <PageDebugging_NumericValues_PlottingNumbers>` its values,
`coloring <PageDebugging_Conditions_ConditionalColors>` the background or chart bars, etc., they must *extract* the
values to the *global scope*, as the built-in functions that produce
such outputs can only accept global variables and literals.

Since the values returned by a function are available to the scope where
a call occurs, one straightforward extraction approach is to have the
function return a `tuple <PageTypeSystem_Tuples>` containing all the values that need inspection.

Here, we\'ve modified the `customMA()` function to return a
`tuple <PageTypeSystem_Tuples>` containing
all the function\'s calculated variables. Now, we can call the function
with a *tuple declaration* to make the values available in the global
scope and inspect them with
`plots <PageDebugging_NumericValues_PlottingNumbers>`:

![image](@assets/writing/Debugging-Debugging-functions-Extracting-local-variables-1.png)

``` pine
//@version=5
indicator("Extracting local variables with tuples demo", "Custom MA", true)

//@variable The number of bars in the `customMA()` calculation.
int lengthInput = input.int(50, "Length", 2)

//@function      Calculates a moving average that only responds to values outside the first and third quartiles.
//@param source  The series of values to process.
//@param length  The number of bars in the calculation.
//@returns       The moving average value.
customMA(float source, int length) =>
    //@variable The custom moving average.
    var float result = na
    // Calculate the 25th and 75th `source` percentiles.
    float q1 = ta.percentile_linear_interpolation(source, length, 25)
    float q3 = ta.percentile_linear_interpolation(source, length, 75)
    // Calculate the range values.
    float outerRange = math.max(source - q3, q1 - source, 0.0)
    float totalRange = ta.range(source, length)
    //@variable Half the ratio of the `outerRange` to the `totalRange`.
    float alpha = 0.5 * outerRange / totalRange
    // Mix the `source` with the `result` based on the `alpha` value.
    result := (1.0 - alpha) * nz(result, source) + alpha * source
    // Return a tuple containing the `result` and other local variables.
    [result, q1, q3, outerRange, totalRange, alpha]

// Declare a tuple containing all values returned by `customMA()`.
[maValue, q1Debug, q3Debug, outerRangeDebug, totalRangeDebug, alphaDebug] = customMA(close, lengthInput)

// Plot the `maValue`.
plot(maValue, "Custom MA", color.blue, 3)

//@variable Display location for plots with different scale.
notOnPane = display.all - display.pane

// Display the extracted `q1` and `q3` values in all plot locations.
plot(q1Debug, "q1", color.new(color.maroon, 50))
plot(q3Debug, "q3", color.new(color.teal, 50))
// Display the other extracted values in the status line and Data Window to avoid impacting the scale.
plot(outerRangeDebug, "outerRange", chart.fg_color, display = notOnPane)
plot(totalRangeDebug, "totalRange", chart.fg_color, display = notOnPane)
plot(alphaDebug, "alpha", chart.fg_color, display = notOnPane)
// Highlight the chart when `alphaDebug` is 0, i.e., when the `maValue` does not change.
bgcolor(alphaDebug == 0.0 ? color.new(color.orange, 90) : na, title = "`alpha == 0.0` highlight")
```

Note that:

    -   We used `display.all - display.pane` for the plots of the
        `outerRangeDebug`, `totalRangeDebug`, and `alphaDebug` variables
        to
        `avoid impacting the chart's scale <PageDebugging_NumericValues_PlottingNumbers_WithoutAffectingTheScale>`.
    -   The script also uses a
        `conditional color <PageDebugging_Conditions_ConditionalColors>` to highlight the chart pane\'s
        [background](https://www.tradingview.com/pine-script-reference/v5/#fun_bgcolor)
        when `debugAlpha` is 0, indicating the `maValue` does not
        change.

Another, more *advanced* way to extract the values of a function\'s
local variables is to pass them to a *reference type* variable declared
in the global scope.

Function scopes can access global variables for their calculations.
While a script cannot directly reassign the values of global variables
from within a function\'s scope, it can update the *elements or
properties* of those values if they are reference types, such as
`arrays <PageArrays>`,
`matrices <PageMatrices>`,
`maps <PageMaps>`, and
`user-defined types <PageTypeSystem_UserDefinedTypes>`.

This version declares a `debugData` variable in the global scope that
references a
[map](https://www.tradingview.com/pine-script-reference/v5/#type_map)
with \"string\" keys and \"float\" values. Within the local scope of the
`customMA()` function, the script puts *key-value pairs* containing each
local variable\'s name and value into the map. After calling the
function, the script plots the stored `debugData` values:

``` pine
//@version=5
indicator("Extracting local variables with reference types demo", "Custom MA", true)

//@variable The number of bars in the `customMA()` calculation.
int lengthInput = input.int(50, "Length", 2)

//@variable A map with "string" keys and "float" values for debugging the `customMA()`.
map<string, float> debugData = map.new<string, float>()

//@function      Calculates a moving average that only responds to values outside the first and third quartiles.
//@param source  The series of values to process.
//@param length  The number of bars in the calculation.
//@returns       The moving average value.
customMA(float source, int length) =>
    //@variable The custom moving average.
    var float result = na
    // Calculate the 25th and 75th `source` percentiles.
    float q1 = ta.percentile_linear_interpolation(source, length, 25),    map.put(debugData, "q1", q1)
    float q3 = ta.percentile_linear_interpolation(source, length, 75),    map.put(debugData, "q3", q3)
    // Calculate the range values.
    float outerRange = math.max(source - q3, q1 - source, 0.0),           map.put(debugData, "outerRange", outerRange)
    float totalRange = ta.range(source, length),                          map.put(debugData, "totalRange", totalRange)
    //@variable Half the ratio of the `outerRange` to the `totalRange`.
    float alpha = 0.5 * outerRange / totalRange,                          map.put(debugData, "alpha", alpha)
    // Mix the `source` with the `result` based on the `alpha` value.
    result := (1.0 - alpha) * nz(result, source) + alpha * source
    // Return the `result`.
    result

//@variable The `customMA()` result over `lengthInput` bars.
float maValue = customMA(close, lengthInput)

// Plot the `maValue`.
plot(maValue, "Custom MA", color.blue, 3)

//@variable Display location for plots with different scale.
notOnPane = display.all - display.pane

// Display the extracted `q1` and `q3` values in all plot locations.
plot(map.get(debugData, "q1"), "q1", color.new(color.maroon, 50))
plot(map.get(debugData, "q3"), "q3", color.new(color.teal, 50))
// Display the other extracted values in the status line and Data Window to avoid impacting the scale.
plot(map.get(debugData, "outerRange"), "outerRange", chart.fg_color, display = notOnPane)
plot(map.get(debugData, "totalRange"), "totalRange", chart.fg_color, display = notOnPane)
plot(map.get(debugData, "alpha"), "alpha", chart.fg_color, display = notOnPane)
// Highlight the chart when the extracted `alpha` is 0, i.e., when the `maValue` does not change.
bgcolor(map.get(debugData, "alpha") == 0.0 ? color.new(color.orange, 90) : na, title = "`alpha == 0.0` highlight")
```

Note that:

    -   We placed each
        [map.put()](https://www.tradingview.com/pine-script-reference/v5/#fun_map.put)
        call on the same line as each variable declaration, separated by
        a comma, to keep things concise and avoid adding extra lines to
        the `customMA()` code.
    -   We used
        [map.get()](https://www.tradingview.com/pine-script-reference/v5/#fun_map.get)
        to retrieve each value for the debug
        [plot()](https://www.tradingview.com/pine-script-reference/v5/#fun_plot)
        and
        [bgcolor()](https://www.tradingview.com/pine-script-reference/v5/#fun_bgcolor)
        calls.

### Local drawings and logs 

Unlike `plot.*()` functions and others that require values accessible to
the global scope, scripts can generate
`drawing objects <PageTypeSystem_Types_DrawingTypes>` and `Pine Logs <PageDebugging_PineLogs>` from directly within a function, allowing programmers to
flexibly debug its local variables *without* extracting values to the
outer scope.

In this example, we used
`labels <PageTextAndShapes_Labels>` and
`Pine Logs <PageDebugging_PineLogs>` to
display
`string representations <PageDebugging_Strings_RepresentingOtherTypes>` of the values within the `customMA()` scope. Inside the
function, the script calls
[str.format()](https://www.tradingview.com/pine-script-reference/v5/#fun_str.format)
to create a formatted string representing the local scope\'s data, then
calls
[label.new()](https://www.tradingview.com/pine-script-reference/v5/#fun_label.new)
and
[log.info()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.info)
to respectively display the text on the chart in a tooltip and log an
\"info\" message containing the text in the
`Pine Logs <PageDebugging_PineLogs>` pane:

![image](@assets/writing/Debugging-Debugging-functions-Local-drawings-and-logs-1.png)

``` pine
//@version=5
indicator("Local drawings and logs demo", "Custom MA", true, max_labels_count = 500)

//@variable The number of bars in the `customMA()` calculation.
int lengthInput = input.int(50, "Length", 2)

//@function      Calculates a moving average that only responds to values outside the first and third quartiles.
//@param source  The series of values to process.
//@param length  The number of bars in the calculation.
//@returns       The moving average value.
customMA(float source, int length) =>
    //@variable The custom moving average.
    var float result = na
    // Calculate the 25th and 75th `source` percentiles.
    float q1 = ta.percentile_linear_interpolation(source, length, 25)
    float q3 = ta.percentile_linear_interpolation(source, length, 75)
    // Calculate the range values.
    float outerRange = math.max(source - q3, q1 - source, 0.0)
    float totalRange = ta.range(source, length)
    //@variable Half the ratio of the `outerRange` to the `totalRange`.
    float alpha = 0.5 * outerRange / totalRange
    // Mix the `source` with the `result` based on the `alpha` value.
    result := (1.0 - alpha) * nz(result, source) + alpha * source

    //@variable A formatted string containing representations of all local variables.
    string debugText = str.format(
         "\n`customMA()` data\n----------\nsource: {0, number, #.########}\nlength: {1}\nq1: {2, number, #.########}
         \nq3: {3, number, #.########}\nouterRange: {4, number, #.########}\ntotalRange: {5, number, #.########}
         \nalpha{6, number, #.########}\nresult: {7, number, #.########}",
         source, length, q1, q3, outerRange, totalRange, alpha, result
     )
    // Draw a label with a tooltip displaying the `debugText`.
    label.new(bar_index, high, color = color.new(chart.fg_color, 80), tooltip = debugText)
    // Print an "info" message in the Pine Logs pane when the bar is confirmed.
    if barstate.isconfirmed
        log.info(debugText)

    // Return the `result`.
    result

//@variable The `customMA()` result over `lengthInput` bars.
float maValue = customMA(close, lengthInput)

// Plot the `maValue`.
plot(maValue, "Custom MA", color.blue, 3)
```

Note that:

    -   We included `max_labels_count = 500` in the
        [indicator()](https://www.tradingview.com/pine-script-reference/v5/#fun_indicator)
        function to display
        `labels <PageTextAndShapes_Labels>` for the most recent 500 `customMA()` calls.
    -   The function uses
        [barstate.isconfirmed](https://www.tradingview.com/pine-script-reference/v5/#var_barstate.isconfirmed)
        in an
        [if](https://www.tradingview.com/pine-script-reference/v5/#kw_if)
        statement to only call
        [log.info()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.info)
        on *confirmed* bars. It does not log a new message on each
        realtime tick.

## Debugging loops 

`Loops <PageLoops>` are structures that
repeatedly execute a code block based on a *counter*
([for](https://www.tradingview.com/pine-script-reference/v5/#kw_for)),
the contents of a
`collection <PageTypeSystem_Types_Collections>`
([for\...in](https://www.tradingview.com/pine-script-reference/v5/#kw_for...in)),
or a *condition*
([while](https://www.tradingview.com/pine-script-reference/v5/#kw_while)).
They allow scripts to perform repetitive tasks without the need for
redundant lines of code.

Each loop instance maintains a separate local scope, which all outer
scopes cannot access. All variables declared within a loop\'s scope are
specific to that loop, meaning one cannot use them in an outer scope.

As with other structures in Pine, there are numerous possible ways to
debug loops. This section explores a few helpful techniques, including
extracting local values for `plots <PagePlots>`, inspecting values with
`drawings <PageTypeSystem_Types_DrawingTypes>`, and tracing a loop\'s execution with
`Pine Logs <PageDebugging_PineLogs>`.

We will use this script as a starting point for the examples in the
following segments. It aggregates the
[close](https://www.tradingview.com/pine-script-reference/v5/#var_close)
value\'s rates of change over 1 - `lookbackInput` bars and accumulates
them in a
[for](https://www.tradingview.com/pine-script-reference/v5/#kw_for)
loop, then divides the result by the `lookbackInput` to calculate a
final average value:

![image](@assets/writing/Debugging-Debugging-loops-1.png)

``` pine
//@version=5
indicator("Debugging loops demo", "Aggregate ROC")

//@variable The number of bars in the calculation.
int lookbackInput = input.int(20, "Lookback", 1)

//@variable The average ROC of `close` prices over each length from 1 to `lookbackInput` bars.
float aroc = 0.0

// Calculation loop.
for length = 1 to lookbackInput
    //@variable The `close` value `length` bars ago.
    float pastClose = close[length]
    //@variable The `close` rate of change over `length` bars.
    float roc = (close - pastClose) / pastClose
    // Add the `roc` to `aroc`.
    aroc += roc

// Divide `aroc` by the `lookbackInput`.
aroc /= lookbackInput

// Plot the `aroc`.
plot(aroc, "aroc", color.blue, 3)
```

Note that:

    -   The `aroc` is a *global* variable modified within the loop,
        whereas `pastClose` and `roc` are *local* variables inaccessible
        to the outer scope.

### Inspecting a single iteration 

When a programmer needs to focus on a specific loop iteration, there are
multiple techniques they can use, most of which entail using a
*condition* inside the loop to trigger debugging actions, such as
extracting values to outer variables, creating
`drawings <PageTypeSystem_Types_DrawingTypes>`, `logging <PageDebugging_PineLogs>` messages, etc.

This example inspects the local `roc` value from a single iteration of
the loop in three different ways. When the loop counter\'s value equals
the `debugCounterInput`, the script assigns the `roc` to an `rocDebug`
variable from the global scope for
`plotting <PageDebugging_NumericValues_PlottingNumbers>`, draws a vertical
[line](https://www.tradingview.com/pine-script-reference/v5/#type_line)
from 0 to the `roc` value using
[line.new()](https://www.tradingview.com/pine-script-reference/v5/#fun_line.new),
and logs a message in the
`Pine Logs <PageDebugging_PineLogs>` pane
using
[log.info()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.info):

![image](@assets/writing/Debugging-Debugging-loops-Inspecting-a-single-iteration-1.png)

``` pine
//@version=5
indicator("Inspecting a single iteration demo", "Aggregate ROC", max_lines_count = 500)

//@variable The number of bars in the calculation.
int lookbackInput = input.int(20, "Lookback", 1)
//@variable The `length` value in the loop's execution where value extraction occurs.
int debugCounterInput = input.int(1, "Loop counter value", 1, group = "Debugging")

//@variable The `roc` value extracted from the loop.
float rocDebug = na

//@variable The average ROC of `close` over lags from 1 to `lookbackInput` bars.
float aroc = 0.0

// Calculation loop.
for length = 1 to lookbackInput
    //@variable The `close` value `length` bars ago.
    float pastClose = close[length]
    //@variable The `close` rate of change over `length` bars.
    float roc = (close - pastClose) / pastClose
    // Add the `roc` to `aroc`.
    aroc += roc

    // Trigger debug actions when the `length` equals the `debugCounterInput`.
    if length == debugCounterInput
        // Assign `roc` to `rocDebug` so the script can plot its value.
        rocDebug := roc
        // Draw a vertical line from 0 to the `roc` at the `bar_index`.
        line.new(bar_index, 0.0, bar_index, roc, color = color.new(color.gray, 50), width = 4)
        // Log an "info" message in the Pine Logs pane.
        log.info("{0}-bar `roc`{1}: {2, number, #.########}", length, barstate.isconfirmed ? " (confirmed)" : "", roc)

// Divide `aroc` by the `lookbackInput`.
aroc /= lookbackInput

// Plot the `aroc`.
plot(aroc, "aroc", color.blue, 3)

// Plot the `rocDebug`.
plot(rocDebug, "Extracted roc", color.new(color.rgb(206, 55, 136), 40), 2)
```

Note that:

    -   The
        [input.int()](https://www.tradingview.com/pine-script-reference/v5/#fun_input.int)
        call assigned to the `debugCounterInput` includes a `group`
        argument to distinguish it in the script\'s settings.
    -   The
        [log.info()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.info)
        call includes \"(confirmed)\" in the formatted message whenever
        [barstate.isconfirmed](https://www.tradingview.com/pine-script-reference/v5/#var_barstate.isconfirmed)
        is `true`. Searching this text in the
        `Pine Logs <PageDebugging_PineLogs>` pane will filter out the entries from unconfirmed
        bars. See the
        `Filtering logs <PageDebugging_PineLogs_FilteringLogs>` section above.

### Inspecting multiple iterations 

When inspecting the values from several loop iterations, it\'s often
helpful to utilize
`collections <PageTypeSystem_Types_Collections>` or strings to gather the results for use in output functions
after the loop terminates.

This version demonstrates a few ways to collect and display the loop\'s
values from all iterations. It declares a `logText` string and a
`debugValues` array in the global scope. Inside the local scope of the
[for](https://www.tradingview.com/pine-script-reference/v5/#kw_for)
loop, the script *concatenates* a
`string representation <PageDebugging_Strings_RepresentingOtherTypes>` of the `length` and `roc` with the `logText` and calls
[array.push()](https://www.tradingview.com/pine-script-reference/v5/#fun_array.push)
to push the iteration\'s `roc` value into the `debugValues` array.

After the loop ends, the script
`plots <PageDebugging_NumericValues_PlottingNumbers>` the
[first](https://www.tradingview.com/pine-script-reference/v5/#fun_array.first)
and
[last](https://www.tradingview.com/pine-script-reference/v5/#fun_array.last)
value from the `debugValues` array, draws a
[label](https://www.tradingview.com/pine-script-reference/v5/#type_label)
with a *tooltip* showing a
`string representation <PageDebugging_Strings_RepresentingOtherTypes>` of the
[array](https://www.tradingview.com/pine-script-reference/v5/#type_array),
and displays the `logText` in the
`Pine Logs <PageDebugging_PineLogs>` pane
upon the bar\'s confirmation:

![image](@assets/writing/Debugging-Debugging-loops-Inspecting-multiple-iterations-1.png)

``` pine
//@version=5
indicator("Inspecting multiple iterations demo", "Aggregate ROC", max_labels_count = 500)

//@variable The number of bars in the calculation.
int lookbackInput = input.int(20, "Lookback", 1)

//@variable An array containing the `roc` value from each loop iteration.
array<float> debugValues = array.new<float>()
//@variable A "string" containing information about the `roc` on each iteration.
string logText = ""

//@variable The average ROC of `close` over lags from 1 to `lookbackInput` bars.
float aroc = 0.0

// Calculation loop.
for length = 1 to lookbackInput
    //@variable The `close` value `length` bars ago.
    float pastClose = close[length]
    //@variable The `close` rate of change over `length` bars.
    float roc = (close - pastClose) / pastClose
    // Add the `roc` to `aroc`.
    aroc += roc

    // Concatenate a new "string" representation with the `debugText`.
    logText += "\nlength: " + str.tostring(length) + ", roc: " + str.tostring(roc)
    // Push the `roc` value into the `debugValues` array.
    array.push(debugValues, roc)

// Divide `aroc` by the `lookbackInput`.
aroc /= lookbackInput

// Plot the `aroc`.
plot(aroc, "aroc", color.blue, 3)

// Plot the `roc` values from the first and last iteration.
plot(array.first(debugValues), "First iteration roc", color.new(color.rgb(166, 84, 233), 50), 2)
plot(array.last(debugValues), "Last iteration roc", color.new(color.rgb(115, 86, 218), 50), 2)
// Draw a label with a tooltip containing a "string" representation of the `debugValues` array.
label.new(bar_index, aroc, color = color.new(color.rgb(206, 55, 136), 70), tooltip = str.tostring(debugValues))
// Log the `logText` in the Pine Logs pane when the bar is confirmed.
if barstate.isconfirmed
    log.info(logText)
```

Another way to inspect a loop over several iterations is to generate
sequential `Pine Logs <PageDebugging_PineLogs>` or create/modify
`drawing objects <PageTypeSystem_Types_DrawingTypes>` within the loop\'s scope to trace its execution pattern with
granular detail.

This example uses `Pine Logs <PageDebugging_PineLogs>` to trace the execution flow of our script\'s loop. It
generates a new \"info\" message on each iteration to track the local
scope\'s calculations as the loop progresses on each confirmed bar:

![image](@assets/writing/Debugging-Debugging-loops-Inspecting-multiple-iterations-2.png)

``` pine
//@version=5
indicator("Inspecting multiple iterations demo", "Aggregate ROC")

//@variable The number of bars in the calculation.
int lookbackInput = input.int(20, "Lookback", 1)

//@variable The average ROC of `close` over lags from 1 to `lookbackInput` bars.
float aroc = 0.0

// Calculation loop.
for length = 1 to lookbackInput
    //@variable The `close` value `length` bars ago.
    float pastClose = close[length]
    //@variable The `close` rate of change over `length` bars.
    float roc = (close - pastClose) / pastClose
    // Add the `roc` to `aroc`.
    aroc += roc
    if barstate.isconfirmed
        log.info(
             "{0}\nlength (counter): {1}\npastClose: {2, number, #.#####}\n
             distance to pastClose: {3, number, #.########}\nroc: {4, number, #.########}\n
             aroc (before division): {5, number, #.########}\n{6}",
             length == 1 ? "LOOP START" : "",
             length, pastClose, close - pastClose, roc, aroc,
             length == lookbackInput ? "LOOP END" : ""
         )

// Divide `aroc` by the `lookbackInput`.
aroc /= lookbackInput

// Plot the `aroc`.
plot(aroc, "aroc", color.blue, 3)
```

Note that:

    -   When iteratively generating
        `logs <PageDebugging_PineLogs>` or
        drawings from inside a loop, make it a point to avoid
        unnecessary clutter and strive for easy navigation. More is not
        always better for debugging, especially when working within
        loops.

## Tips 

### Organization and readability 

When writing scripts, it\'s wise to prioritize organized, readable
source codes. Code that\'s organized and easy to read helps streamline
the debugging process. Additionally, well-written code is easier to
maintain over time.

Here are a few quick tips based on our
`Style guide <PageStyleGuide>` and the
examples on this page:

-   Aim to follow the general
    `script organization <PageStyleGuide_ScriptOrganization>` recommendations. Organizing scripts using this structure
    makes things easier to locate and inspect.
-   Choose variable and function names that make them easy to *identify*
    and *understand*. See the
    `Naming conventions <PageStyleGuide_NamingConventions>` section for some examples.
-   It\'s often helpful to temporarily assign important parts of
    expressions to variables with informative names while debugging.
    Breaking expressions down into reusable parts helps simplify
    inspection processes.
-   Use *comments* and *annotations* (`//@function`, `//@variable`,
    etc.) to document your code. Annotations are particularly helpful,
    as the Pine Editor\'s autosuggest displays variable and function
    descriptions in a pop-up when hovering over their identifiers
    anywhere in the code.
-   Remember that *less is more* in many cases. Don\'t overwhelm
    yourself with excessive script outputs or unnecessary information
    while debugging. Keep things simple, and only include as much
    information as you need.

### Speeding up repetitive tasks 

There are a few handy techniques we often utilize when debugging our
code:

-   We use
    [plotchar()](https://www.tradingview.com/pine-script-reference/v5/#fun_plotchar)
    or
    [plotshape()](https://www.tradingview.com/pine-script-reference/v5/#fun_plotshape)
    to quickly display the results of \"int\", \"float\", or \"bool\"
    variables and expressions in the script\'s status line and the Data
    Window.
-   We often use
    [bgcolor()](https://www.tradingview.com/pine-script-reference/v5/#fun_bgcolor)
    to visualize the history of certain
    `conditions <PageDebugging_Conditions>` on the chart.
-   We use a one-line version of our `printLabel()` function from
    `this section <PageDebugging_Strings_UsingLabels_AtTheEndOfTheChart>` to print strings at the end of the chart.
-   We use a
    [label.new()](https://www.tradingview.com/pine-script-reference/v5/#fun_label.new)
    call with a `tooltip` argument to display strings in tooltips
    `on successive bars <PageDebugging_Strings_UsingLabels_OnSuccessiveBars>`.
-   We use the `log.*()` functions to quickly display data with
    `string representations <PageDebugging_Strings_RepresentingOtherTypes>` in the
    `Pine Logs <PageDebugging_PineLogs>`
    pane.

When one establishes their typical debugging processes, it\'s often
helpful to create *keyboard macros* to speed up repetitive tasks and
spend less time setting up debug outputs in each code.

The following is a simple *AutoHotkey* script (**not** Pine Script™
code) that includes hotstrings for the above five techniques. The script
generates code snippets by entering a specified character sequence
followed by a whitespace:

``` ahk
; ————— This is AHK code, not Pine Script™. —————

; Specify that hotstrings trigger when they end with space, tab, linefeed, or carriage return.
#Hotstring EndChars `t `n `r

:X:,,show::SendInput, plotchar(%Clipboard%, "%Clipboard%", "", color = chart.fg_color, display = display.all - display.pane){Enter}
:X:,,highlight::SendInput, bgcolor(bool(%Clipboard%) ? color.new(color.orange, 80) : na, title = "%Clipboard% highlight"){Enter}
:X:,,print::SendInput, printLabel(string txt, float price = na) => int labelTime = math.max(last_bar_time, chart.right_visible_bar_time), var label result = label.new(labelTime, na, txt, xloc.bar_time, na(price) ? yloc.abovebar : yloc.price, na, label.style_none, chart.fg_color, size.large), label.set_text(result, txt), label.set_y(result, price), result`nprintLabel(){Left}
:X:,,tooltip::SendInput, label.new(bar_index, high, color = color.new(chart.fg_color, 70), tooltip = str.tostring(%Clipboard%)){Enter}
:X:,,log::SendInput, log.info(str.tostring(%Clipboard%)){Enter}
```

The \",,show\" macro generates a
[plotchar()](https://www.tradingview.com/pine-script-reference/v5/#fun_plotchar)
call that uses the clipboard\'s contents for the `series` and `title`
arguments. Copying a `variableName` variable or the `close > open`
expression and typing \",,show\" followed by a space will respectively
yield:

    plotchar(variableName, "variableName", "", color = chart.fg_color, display = display.all - display.pane)
    plotchar(close > open, "close > open", "", color = chart.fg_color, display = display.all - display.pane)

The \",,highlight\" macro generates a
[bgcolor()](https://www.tradingview.com/pine-script-reference/v5/#fun_bgcolor)
call that highlights the chart pane\'s background with a
`conditional color <PageDebugging_Conditions_ConditionalColors>` based on the variable or expression copied to the clipboard.
For example, copying the
[barstate.isrealtime](https://www.tradingview.com/pine-script-reference/v5/#var_barstate.isrealtime)
variable and typing \",,highlight\" followed by a space will yield:

    bgcolor(bool(barstate.isrealtime) ? color.new(color.orange, 80) : na, title = "barstate.isrealtime highlight")

The \",,print\" macro generates the one-line `printLabel()` function and
creates an empty `printLabel()` call with the cursor placed inside it.
All you need to do after typing \",,print\" followed by a space is enter
the text you want to display:

    printLabel(string txt, float price = na) => int labelTime = math.max(last_bar_time, chart.right_visible_bar_time), var label result = label.new(labelTime, na, txt, xloc.bar_time, na(price) ? yloc.abovebar : yloc.price, na, label.style_none, chart.fg_color, size.large), label.set_text(result, txt), label.set_y(result, price), result
    printLabel()

The \",,tooltip\" macro generates a
[label.new()](https://www.tradingview.com/pine-script-reference/v5/#fun_label.new)
call with a `tooltip` argument that uses
[str.tostring()](https://www.tradingview.com/pine-script-reference/v5/#fun_str.tostring)
on the clipboard\'s contents. Copying the `variableName` variable and
typing \",,tooltip\" followed by a space yields:

    label.new(bar_index, high, color = color.new(chart.fg_color, 70), tooltip = str.tostring(variableName))

The \",,log\" macro generates a
[log.info()](https://www.tradingview.com/pine-script-reference/v5/#fun_log.info)
call with a `message` argument that uses
[str.tostring()](https://www.tradingview.com/pine-script-reference/v5/#fun_str.tostring)
on the clipboard\'s contents to display string representations of
variables and expressions in the
`Pine Logs <PageDebugging_PineLogs>` pane.
Copying the expression `bar_index % 2 == 0` and typing \",,log\"
followed by a space yields:

    log.info(str.tostring(bar_index % 2 == 0))

Note that:

    -   AHK is available for *Windows* devices. Research other software
        to employ a similar process if your machine uses a different
        operating system.


